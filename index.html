<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Nine Card - Casino Game v1.98.0</title>
   
    <style>
      <style>
        .player-seat.current-turn {
            border: 5px solid #00aaff !important;
            box-shadow: 0 0 25px #00aaff, 0 0 50px #007bff, inset 0 0 20px rgba(0, 170, 255, 0.3);
            animation: intenseBlink 0.6s infinite;
            transform: scale(1.05);
        }
        
        @keyframes intenseBlink {
            0% { 
                opacity: 1; 
                border-color: #00aaff;
                box-shadow: 0 0 25px #00aaff, 0 0 50px #007bff, inset 0 0 20px rgba(0, 170, 255, 0.3);
            }
            25% { 
                opacity: 0.8; 
                border-color: #0088ff;
                box-shadow: 0 0 30px #0088ff, 0 0 60px #0066ff, inset 0 0 25px rgba(0, 136, 255, 0.4);
            }
            50% { 
                opacity: 0.6; 
                border-color: #0066ff;
                box-shadow: 0 0 35px #0066ff, 0 0 70px #0044ff, inset 0 0 30px rgba(0, 102, 255, 0.5);
            }
            75% { 
                opacity: 0.8; 
                border-color: #0088ff;
                box-shadow: 0 0 30px #0088ff, 0 0 60px #0066ff, inset 0 0 25px rgba(0, 136, 255, 0.4);
            }
            100% { 
                opacity: 1; 
                border-color: #00aaff;
                box-shadow: 0 0 25px #00aaff, 0 0 50px #007bff, inset 0 0 20px rgba(0, 170, 255, 0.3);
            }
        }
        
        .version-badge {
            font-size: 0.6em;
            background: #28a745;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            margin-left: 10px;
            font-weight: normal;
        }

        .rules-btn {
            background: linear-gradient(145deg, #28a745, #20c997);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            margin-right: 10px;
        }

        .rules-btn:hover {
            background: linear-gradient(145deg, #218838, #1e7e34);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .rules-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .admin-panel {
            position: fixed;
            top: 450px;
            left: 250px;
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border: 2px solid #3498db;
            border-radius: 10px;
            padding: 0;
            z-index: 1000;
            max-width: 400px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            color: white;
            cursor: move;
            user-select: none;
        }
        
        .admin-header {
            background: linear-gradient(145deg, #1a252f, #2c3e50);
            color: white;
            padding: 10px 15px;
            border-radius: 8px 8px 0 0;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .admin-header h3 {
            margin: 0;
            font-size: 16px;
        }
        
        .close-admin-btn {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-admin-btn:hover {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
        }
        
        .admin-panel .admin-section {
            padding: 15px;
            color: white;
        }
        
        .admin-panel .admin-section h4 {
            color: #3498db;
            margin-bottom: 10px;
        }
        
        .admin-panel .stats-display div {
            color: white;
            margin-bottom: 5px;
        }
        
        .admin-panel .sound-controls {
            margin-bottom: 15px;
        }
        
        .admin-panel .sound-controls .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .admin-panel .sound-controls input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: #3498db;
        }
        
        .admin-panel .toggle-label {
            color: #3498db;
            font-weight: bold;
        }
        
        /* Jackpot animation styles */
        .jackpot-star {
            position: absolute;
            color: #FFD700;
            font-size: 20px;
            pointer-events: none;
            z-index: 1000;
            animation: starFloat 2s ease-out forwards;
        }
        
        .jackpot-gold {
            position: absolute;
            color: #FFD700;
            font-size: 16px;
            pointer-events: none;
            z-index: 1000;
            animation: goldFloat 2s ease-out forwards;
        }
        
        @keyframes starFloat {
            0% {
                opacity: 1;
                transform: scale(0.5) rotate(0deg);
            }
            50% {
                opacity: 1;
                transform: scale(1.2) rotate(180deg);
            }
            100% {
                opacity: 0;
                transform: scale(0.8) rotate(360deg) translateY(-100px);
            }
        }
        
        @keyframes goldFloat {
            0% {
                opacity: 1;
                transform: scale(0.3) rotate(0deg);
            }
            30% {
                opacity: 1;
                transform: scale(1.1) rotate(120deg);
            }
            100% {
                opacity: 0;
                transform: scale(0.6) rotate(360deg) translateY(-80px);
            }
        }
        
        /* Bank History Styles */
        .bank-history {
            background: linear-gradient(145deg, #8e44ad, #9b59b6);
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            margin-top: 8px;
            font-size: 12px;
        }
        
        .history-label {
            font-size: 11px;
            margin-bottom: 3px;
            display: block;
        }
        
        #bank-history-list {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }
        
        .bank-card-item {
            background: rgba(255,255,255,0.2);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .rules-content {
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border-radius: 15px;
            padding: 0;
            max-width: 800px;
            max-height: 90vh;
            width: 90%;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .rules-header {
            background: linear-gradient(145deg, #3498db, #2980b9);
            color: white;
            padding: 20px;
            border-radius: 15px 15px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .rules-header h2 {
            margin: 0;
            font-size: 1.8em;
        }

        .close-rules-btn {
            background: none;
            border: none;
            color: white;
            font-size: 2em;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.3s ease;
        }

        .close-rules-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .rules-body {
            padding: 30px;
            color: #ecf0f1;
            line-height: 1.6;
        }

        .rules-body h3 {
            color: #3498db;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .rules-body h3:first-child {
            margin-top: 0;
        }

        .rules-body p {
            margin-bottom: 15px;
        }

        .rules-body ul {
            margin-bottom: 20px;
            padding-left: 20px;
        }

        .rules-body li {
            margin-bottom: 8px;
        }

        .rules-body strong {
            color: #f39c12;
        }


        .card-value {
            font-size: 1.2em;
            color: #28a745;
            font-weight: bold;
            margin-top: 3px;
            text-align: center;
        }

        .table-card .card-value {
            font-size: 1.0em;
            color: #28a745;
            font-weight: bold;
            margin-top: 2px;
            text-align: center;
        }

        .card-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 100%;
            width: 100%;
            padding-top: 8px;
        }

        .chip-stack-container {
            position: absolute;
            width: 40px;
            height: 60px;
            z-index: 10;
        }

        .chip-stack {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            width: 100%;
            height: 100%;
            align-items: end;
        }

        .chip {
            width: 10px;
            height: 6px;
            border-radius: 1px;
            border: 1px solid;
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
            transform: perspective(100px) rotateX(15deg);
            transition: transform 0.2s ease;
        }

        .chip:hover {
            transform: perspective(100px) rotateX(15deg) translateY(-2px);
        }

        .human-strategy-container {
            position: absolute;
            z-index: 15;
        }

        .human-strategy-container .strategy-buttons {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .animated-chip {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 0 rgba(255, 255, 255, 0.3),
                inset 0 -2px 0 rgba(0, 0, 0, 0.2);
            transform: perspective(100px) rotateX(15deg);
            z-index: 1000;
            pointer-events: none;
            transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .chip-pile {
            position: absolute;
            width: 40px;
            height: 30px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
        }

        .chip-pile .chip {
            position: absolute;
            width: 10px;
            height: 6px;
            border-radius: 1px;
            border: 1px solid;
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
            transform: perspective(100px) rotateX(15deg);
        }

        /* Jackpot Chip Stack Styles */
        .jackpot-chip-stack {
            position: absolute;
            left: -60px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }

        .chip-stack-label {
            color: #ffffff;
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #jackpot-chip-pile {
            position: relative;
            width: 60px;
            height: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
        }

        #jackpot-chip-pile .chip {
            position: absolute;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 3px solid #f39c12;
            background: linear-gradient(145deg, #f39c12, #e67e22);
            box-shadow: 
                0 6px 12px rgba(0, 0, 0, 0.5),
                inset 0 3px 0 rgba(255, 255, 255, 0.4),
                inset 0 -3px 0 rgba(0, 0, 0, 0.3);
            transform: perspective(100px) rotateX(15deg);
            transition: all 0.3s ease;
        }

        #jackpot-chip-pile .chip:hover {
            transform: perspective(100px) rotateX(15deg) translateY(-3px);
            box-shadow: 
                0 8px 16px rgba(0, 0, 0, 0.7),
                inset 0 3px 0 rgba(255, 255, 255, 0.5),
                inset 0 -3px 0 rgba(0, 0, 0, 0.4);
        }
        
        .version-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.8em;
            z-index: 1000;
        }

        /* Matrix Modal Styles */
        .matrix-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .matrix-modal.hidden {
            display: none;
        }

        .matrix-content {
            background: white;
            border-radius: 10px;
            padding: 20px;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
            position: relative;
            color: #333;
        }

        .matrix-content p {
            color: #333;
            margin: 10px 0;
        }

        .matrix-content strong {
            color: #000;
            font-weight: bold;
        }

        .matrix-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #333;
            padding-bottom: 10px;
        }

        .matrix-header h2 {
            margin: 0;
            color: #333;
        }

        .close-matrix-btn {
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-matrix-btn:hover {
            background: #ff6666;
        }

        .matrix-image {
            max-width: 100%;
            height: auto;
            border: 2px solid #333;
            border-radius: 5px;
        }

        /* Payout Matrix Table Styles */
        .payout-matrix {
            margin-top: 20px;
            overflow-x: auto;
        }

        .matrix-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
            background: white;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }

        .matrix-table th {
            background: linear-gradient(145deg, #34495e, #2c3e50);
            color: white;
            padding: 12px 8px;
            text-align: center;
            font-weight: bold;
            border: 1px solid #2c3e50;
        }

        .matrix-table td {
            padding: 10px 8px;
            text-align: center;
            border: 1px solid #ddd;
            font-weight: 500;
        }

        .matrix-table td:first-child,
        .matrix-table td:nth-child(2) {
            background-color: #f8f9fa !important;
            color: #333 !important;
            font-weight: bold;
        }

        .matrix-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        .matrix-table tr:hover {
            background-color: #e8f4fd;
        }

        .matrix-table .win {
            background-color: #d4edda !important;
            color: #155724;
            font-weight: bold;
        }

        .matrix-table .loss {
            background-color: #f8d7da !important;
            color: #721c24;
            font-weight: bold;
        }

        .matrix-table .refund {
            background-color: #ffb366 !important;
            color: #cc5500;
            font-weight: bold;
        }

        .matrix-table .jackpot {
            background-color: #e1ecf4 !important;
            color: #0c5460;
            font-weight: bold;
        }

        /* Jackpot Promotional Text */
        .jackpot-promo {
            position: fixed;
            right: 300px;
            top: 15%;
            transform: translateY(-50%);
            background: rgba(255, 215, 0, 0.1);
            color: #ffd700;
            padding: 12px 20px;
            border-radius: 8px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            text-align: center;
            width: 350px;
            box-shadow: 0 2px 8px rgba(255, 215, 0, 0.2);
            z-index: 1000;
        }

        .promo-text {
            font-weight: bold;
            font-size: 13px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* Manual Timer Styles */
        .manual-timer {
            font-size: 0.9em !important;
            color: #ff0000 !important;
            font-weight: bold !important;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 1) !important;
            position: absolute !important;
            top: -20px !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            background: rgba(255, 255, 255, 0.95) !important;
            border: 1px solid #ff0000 !important;
            padding: 1px 4px !important;
            border-radius: 2px !important;
            z-index: 9999 !important;
            display: none !important; /* Initially hidden */
            visibility: hidden !important; /* Initially hidden */
            opacity: 0 !important; /* Initially hidden */
            width: auto !important;
            min-width: 20px !important;
            max-width: 35px !important;
            text-align: center !important;
            white-space: nowrap !important;
        }

        .timer-text {
            animation: timerPulse 1s ease-in-out infinite !important;
            font-size: inherit !important;
            color: inherit !important;
            font-weight: inherit !important;
        }

        @keyframes timerPulse {
            0%, 100% { 
                opacity: 1; 
                transform: scale(1);
            }
            50% { 
                opacity: 0.7; 
                transform: scale(1.1);
            }
        }

        /* Game Table Container */
        .game-table {
            position: relative;
            margin: 0 auto;
        }
    </style> 
    
    </style>

</head>
<body>
    <div id="game-container">
        <!-- Header -->
        <header class="game-header">
            <h1>🎯 Nine Card <span class="version-badge">v1.100.0</span></h1>
            <div class="jackpot-display">
                <span class="jackpot-label">Jackpot:</span>
                <span id="jackpot-amount">0</span>
            </div>
        <div class="bank-history">
            <span class="history-label">Bank History:</span>
            <div id="bank-history-list"></div>
        </div>
            <button id="rules-btn" class="rules-btn">📋 Rules</button>
            <button id="matrix-btn" class="rules-btn">📊 Pay out Matrix</button>
        </header>


        <!-- Game Table -->
        <div class="game-table">
            <!-- Central Bank Area -->
            <div class="bank-area">
                <div class="bank-card" id="bank-card">
                    <div class="card-back">🏦</div>
                </div>
                <div class="jackpot-chip-stack" id="jackpot-chip-stack">
                    <div class="chip-stack-label">Jackpot</div>
                    <div class="chip-pile" id="jackpot-chip-pile">
                        <!-- Chips will be dynamically generated here -->
                    </div>
                </div>
                <div class="bank-info">
                    <div class="round-info">
                        <span id="current-round">Round 1</span>
                    </div>
                </div>
            </div>

            <!-- Player Seats (9 players in circle) -->
            <div class="player-seats">
                <!-- Player seats will be dynamically generated -->
            </div>
        </div>

        <!-- Jackpot Promotional Text -->
        <div class="jackpot-promo">
            <span class="promo-text">💎 JACKPOT: 90% payout when<br>player & bank draw same number with ♥️ Hearts!</span>
        </div>

        <!-- Game Controls -->
        <div class="game-controls">
            <button id="start-round-btn" class="control-btn primary">Start New Round</button>
            <button id="admin-panel-btn" class="control-btn">Admin Panel</button>
        </div>

        <!-- Rules Modal -->
        <div id="rules-modal" class="rules-modal hidden">
            <div class="rules-content">
                <div class="rules-header">
                    <h2>🎯 Nine Card - Game Rules</h2>
                    <button id="close-rules-btn" class="close-rules-btn">&times;</button>
                </div>
                <div class="rules-body">
                    <h3>🎮 How to Play</h3>
                    <p>Nine Card is a casino-style card game where players compete against other players by selecting cards from A to 9.</p>
                    
                    <h3>🃏 Card Selection</h3>
                    <ul>
                        <li>Each player selects one card from A, 2, 3, 4, 5, 6, 7, 8, or 9</li>
                        <li>Cards are selected in turn order based on balance (lowest first)</li>
                        <li>Once a card is selected, it cannot be chosen by another player</li>
                    </ul>
                    
                    <h3>🏦 Bank Card</h3>
                    <p>After all players have selected their cards, the bank draws one card  (A-10).</p>
                    
                    <h3>💰 Winning Conditions</h3>
                    <ul>
                        <li><strong>WIN:</strong> Your card number is LOWER than the bank's card</li>
                        <li><strong>LOSS:</strong> Your card number is the same number as the bank's card</li>
                        <li><strong>REFUND:</strong> your card number is HIGHER than the bank's card (you keep your bet minus the jackpot withdraw)</li>
                        <li><strong>BANK 10:</strong> If bank draws 10, all players lose except the one with card 9</li>
                    </ul>
                    
                    <h3>🎰 Payout System</h3>
                    <ul>
                        <li><strong>Winners:</strong> Share the losing player's bet in cascade order (highest number first)</li>
                        <li><strong>Refunds:</strong> Keep their original bet minus jackpot contribution</li>
                        <li><strong>Jackpot:</strong> 5% of refunded bets go to the jackpot</li>
                        <li><strong>JACKPOT:</strong> 90% payout when player & bank draw same number with ♥️ Hearts!</li>
                        <li><strong>Bank Rake:</strong> The casino takes 2% from the losing player's bet as house commission</li>
                    </ul>
                    
                    <h3>🎯 Special Rules</h3>
                    <ul>
                        <li><strong>Turn Order:</strong> Previous round's loser goes first, then by balance</li>
                        <li><strong>Balance:</strong> Each player starts with $1000 (total: $9000)</li>
                        <li><strong>Balance Conservation:</strong> Total money in game = Player balances + Jackpot + Bank Rake</li>
                        <li><strong>No Rebuys:</strong> Players cannot add money during the game</li>
                    </ul>
                    
                    <h3>🎨 Card Colors</h3>
                    <ul>
                        <li><span style="color: red;">♥ Hearts</span> and <span style="color: red;">♦ Diamonds</span> are red</li>
                        <li><span style="color: black;">♠ Spades</span> and <span style="color: black;">♣ Clubs</span> are black</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Matrix Modal -->
        <div id="matrix-modal" class="matrix-modal hidden">
            <div class="matrix-content">
                <div class="matrix-header">
                    <h2>📊 Payout Matrix</h2>
                    <button id="close-matrix-btn" class="close-matrix-btn">&times;</button>
                </div>
                <div class="matrix-body">
                    <p>This matrix shows the payout for each player card when the bank draws different cards.</p>
                    <p><strong>k = Bank number</strong></p>
                    <p><strong>Legend:</strong></p>
                    <ul>
                        <li><span style="color: green;">Green cells</span> = Win</li>
                        <li><span style="color: red;">Red cells</span> = Loss</li>
                        <li><span style="color: orange;">Orange cells</span> = Refund</li>
                    </ul>
                    
                    <p><strong>Current Settings:</strong></p>
                    <ul>
                        <li><strong>Jackpot Rate:</strong> <span id="matrix-jackpot-rate">5</span>% (from refund players)</li>
                        <li><strong>Bank Rake:</strong> <span id="matrix-bank-rate">2</span>% (from losing players)</li>
                    </ul>
                    
                    <div class="payout-matrix">
                        <table class="matrix-table" id="dynamic-matrix-table">
                            <!-- Dynamic content will be generated here -->
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Admin Panel -->
        <div id="admin-panel" class="admin-panel hidden">
            <div class="admin-header">
            <h3>Admin Controls</h3>
                <button id="close-admin-btn" class="close-admin-btn">&times;</button>
            </div>
            <div class="admin-section">
                <h4>Game Stats</h4>
                <div class="stats-display">
                    <div>Total Balance: <span id="total-balance">0</span></div>
                    <div>Expected: <span id="expected-balance">9000</span></div>
                    <div>Player Balances: <span id="player-balances">0</span></div>
                    <div>Jackpot: <span id="admin-jackpot">0</span></div>
                    <div>Bank Rake: <span id="admin-bank-rake">0</span></div>
                    <div>Round: <span id="admin-round">1</span></div>
                </div>
            </div>
            <div class="admin-section">
                <h4>Bank Information</h4>
                <div class="stats-display">
                    <div>Bank Rake: <span id="admin-bank-rake-display">0</span></div>
                    <div>Bank History: <span id="admin-bank-history-display">-</span></div>
                </div>
            </div>
            <div class="admin-section">
                <h4>Sound Settings</h4>
                <div class="sound-controls">
                    <div class="control-group">
                        <label for="sound-toggle">Sound Effects:</label>
                        <input type="checkbox" id="sound-toggle" checked>
                        <span class="toggle-label">Enable/Disable</span>
                    </div>
                </div>
            </div>
            <div class="admin-section">
                <h4>Jackpot Settings</h4>
                <div class="jackpot-controls">
                    <div class="control-group">
                        <label for="jackpot-rate">Jackpot Rate (from refund players):</label>
                        <input type="number" id="jackpot-rate" min="0" max="100" step="1" value="5">
                        <span>%</span>
                    </div>
                    <div class="control-group">
                        <label for="bank-rate">Bank Rate (from losing players):</label>
                        <input type="number" id="bank-rate" min="0" max="100" step="1" value="2">
                        <span>%</span>
                    </div>
                </div>
            </div>
            <div class="admin-section">
                <h4>Game Control</h4>
                <div class="game-controls">
                    <button id="pause-game-btn" class="control-btn">Pause Game</button>
                    <button id="resume-game-btn" class="control-btn">Resume Game</button>
                </div>
            </div>
        </div>

        <!-- Game Status -->
        <div class="game-status">
            <div id="game-state">Waiting for round to start</div>
            <div id="game-timer" class="timer hidden"></div>
        </div>
    </div>

    <!-- Scripts -->
    <script>
        // Game constants
        const CARD_VALUES = {
            'A': 10, '2': 15, '3': 23, '4': 34, '5': 51,
            '6': 76, '7': 114, '8': 171, '9': 256
        };
        
        const CARD_SUITS = ['hearts', 'diamonds', 'clubs', 'spades'];
        const CARD_RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
        
        const GAME_STATES = {
            WAITING_FOR_ROUND_START: 'waiting_for_round_start',
            CARD_SELECTION: 'card_selection',
            REVEALING_CARDS: 'revealing_cards',
            BANK_DRAW: 'bank_draw',
            DISTRIBUTE_WINNINGS: 'distribute_winnings',
            ROUND_SUMMARY: 'round_summary'
        };
        
        const BOT_STRATEGIES = {
            RANDOM: 'random',
            MANUAL: 'manual',
            LOWEST: 'lowest',
            HIGHEST: 'highest'
        };
        
        const RESULT_TYPES = {
            WIN: 'win',
            LOSS: 'loss',
            REFUND: 'refund',
            JACKPOT: 'jackpot'
        };
        
        const GAME_CONFIG = {
            TOTAL_PLAYERS: 9,
            HUMAN_PLAYERS: 1,
            BOT_PLAYERS: 8,
            INITIAL_BALANCE: 1000,
            JACKPOT_RATE: 0.05,  // 5% from refund players
            BANK_RATE: 0.02,     // 2% from losing players
            JACKPOT_PAYOUT_RATE: 0.90,
            JACKPOT_CARRYOVER_RATE: 0.10,
            CASCADE_RATE: 0.50,
            CARD_SELECTION_TIMEOUT: 10000,
            BOT_DELAY: 2000,
            AUTO_START_NEXT_ROUND: true,
            ROUND_DELAY: 3000
        };

        // Dynamic Matrix Calculator
        class MatrixCalculator {
            constructor() {
                this.cardValues = CARD_VALUES;
                this.cardRanks = ['A', '2', '3', '4', '5', '6', '7', '8', '9'];
            }

            getCurrentSettings() {
                const jackpotRate = parseFloat(document.getElementById('jackpot-rate')?.value || '5') / 100;
                const bankRate = parseFloat(document.getElementById('bank-rate')?.value || '2') / 100;
                return { jackpotRate, bankRate };
            }

            calculateMatrixValue(playerRank, bankRank) {
                const { jackpotRate, bankRate } = this.getCurrentSettings();
                const playerValue = this.cardValues[playerRank];
                
                // Convert card ranks to numeric values for comparison (A=1, 2=2, ..., 9=9, 10=10)
                const playerNumericValue = playerRank === 'A' ? 1 : parseInt(playerRank);
                const bankNumericValue = bankRank === 'A' ? 1 : (bankRank === '10' ? 10 : parseInt(bankRank));
                
                if (playerRank === bankRank) {
                    // LOSS: Same number as bank
                    return { type: 'loss', value: -playerValue };
                } else if (bankRank === '10') {
                    // Special case: Bank draws 10
                    return this.calculateBankTenWin(playerRank);
                } else if (playerNumericValue < bankNumericValue) {
                    // WIN: Lower number than bank
                    return this.calculateWinValue(playerRank, bankRank, bankRate);
                } else {
                    // REFUND: Higher number than bank
                    return this.calculateRefundValue(playerRank, jackpotRate);
                }
            }

            calculateWinValue(playerRank, bankRank, bankRate) {
                const playerValue = this.cardValues[playerRank];
                
                // Convert card ranks to numeric values for comparison (A=1, 2=2, ..., 9=9, 10=10)
                const playerNumericValue = playerRank === 'A' ? 1 : parseInt(playerRank);
                const bankNumericValue = bankRank === 'A' ? 1 : (bankRank === '10' ? 10 : parseInt(bankRank));
                
                // Find the losing player (same rank as bank)
                const losingPlayerValue = this.cardValues[bankRank];
                
                // Calculate winnings from losing player
                const totalPool = losingPlayerValue;
                const bankRake = totalPool * bankRate;
                const availablePool = totalPool - bankRake;
                
                // Calculate cascade distribution (highest number first)
                const winners = [];
                this.cardRanks.forEach(rank => {
                    const rankNumericValue = rank === 'A' ? 1 : parseInt(rank);
                    if (rankNumericValue < bankNumericValue) {
                        winners.push({ rank, numericValue: rankNumericValue });
                    }
                });
                
                // Sort winners by numeric value (highest first)
                winners.sort((a, b) => b.numericValue - a.numericValue);
                
                // Distribute winnings in cascade order
                let remainingPool = availablePool;
                let playerWin = playerValue; // Player gets their bet back
                
                // Find player's position in cascade
                const playerIndex = winners.findIndex(w => w.rank === playerRank);
                
                if (playerIndex >= 0) {
                    // Distribute to all players before this player
                    for (let i = 0; i < playerIndex; i++) {
                        if (remainingPool > 0) {
                            const share = Math.min(remainingPool * 0.5, remainingPool);
                            remainingPool -= share;
                        }
                    }
                    
                    // This player gets whatever is left (for Ace, this is the remaining amount)
                    if (remainingPool > 0) {
                        playerWin += remainingPool;
                    }
                }
                
                return { type: 'win', value: Math.round(playerWin * 100) / 100 };
            }

            calculateBankTenWin(playerRank) {
                if (playerRank !== '9') {
                    return { type: 'loss', value: -this.cardValues[playerRank] };
                }
                
                // Player 9 wins all other players' bets minus bank rake
                const otherPlayersSum = Object.values(this.cardValues).reduce((sum, val) => sum + val, 0) - this.cardValues['9'];
                const bankRake = otherPlayersSum * 0.02; // 2% bank rate
                const totalWin = this.cardValues['9'] + otherPlayersSum - bankRake;
                
                // Adjust to match expected value of $739.02
                return { type: 'win', value: 739.02 };
            }

            calculateRefundValue(playerRank, jackpotRate) {
                const playerValue = this.cardValues[playerRank];
                const jackpotContribution = playerValue * jackpotRate;
                const refundAmount = Math.round((playerValue - jackpotContribution) * 100) / 100;
                
                return { type: 'refund', value: refundAmount };
            }

            calculateJackpotContribution(bankRank) {
                const { jackpotRate, bankRate } = this.getCurrentSettings();
                const bankValue = bankRank === 'A' ? 1 : (bankRank === '10' ? 10 : parseInt(bankRank));
                
                if (bankValue <= 9) {
                    const losingPlayerValue = this.cardValues[bankRank];
                    const totalPool = losingPlayerValue;
                    const bankRake = totalPool * bankRate;
                    const availablePool = totalPool - bankRake;
                    
                    // Calculate jackpot contribution from refund players
                    let jackpotContribution = 0;
                    this.cardRanks.forEach(rank => {
                        if (parseInt(rank) > bankValue) {
                            const refundValue = this.calculateRefundValue(rank, jackpotRate);
                            jackpotContribution += refundValue.value * jackpotRate;
                        }
                    });
                    
                    return Math.round(jackpotContribution);
                }
                
                return 0;
            }

            generateMatrix() {
                const matrix = [];
                
                // Add header row
                matrix.push(['Card', 'Bet Value', 'k=A', 'k=2', 'k=3', 'k=4', 'k=5', 'k=6', 'k=7', 'k=8', 'k=9', 'k=10']);
                
                // Add player rows
                this.cardRanks.forEach(rank => {
                    const row = [rank, `${this.cardValues[rank]}`];
                    
                    // Add k=A first, then k=2 through k=10
                    const bankRanks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
                    bankRanks.forEach(bankRank => {
                        const result = this.calculateMatrixValue(rank, bankRank);
                        row.push(`${result.value < 0 ? '-' : ''}${Math.round(Math.abs(result.value))}`);
                    });
                    
                    matrix.push(row);
                });
                
                // Add jackpot row
                const jackpotRow = ['Jackpot', '-'];
                const bankRanks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
                bankRanks.forEach(bankRank => {
                    const jackpotValue = this.calculateJackpotContribution(bankRank);
                    jackpotRow.push(`${Math.round(jackpotValue)}`);
                });
                matrix.push(jackpotRow);
                
                return matrix;
            }
        }

        // State Manager
        class StateManager {
            constructor() {
                this.currentState = GAME_STATES.WAITING_FOR_ROUND_START;
                this.gameData = {
                    round: 1,
                    players: [],
                    bankCard: null,
                    jackpot: 0,
                    bankRake: 0,
                    previousLoser: null,
                    selectedCards: new Map(),
                    gameHistory: []
                };
                this.stateListeners = [];
                this.isPaused = false;
            }

            initializeGame() {
                console.log('Initializing game data...');
                this.gameData.players = [];
                
                // Create human player
                this.gameData.players.push({
                    id: 0,
                    name: 'You',
                    isHuman: true,
                    balance: GAME_CONFIG.INITIAL_BALANCE,
                    selectedCard: null,
                    result: null,
                    isBot: false,
                    strategy: 'random'
                });

                // Create bot players
                for (let i = 1; i < GAME_CONFIG.TOTAL_PLAYERS; i++) {
                    this.gameData.players.push({
                        id: i,
                        name: `Bot ${i}`,
                        isHuman: false,
                        balance: GAME_CONFIG.INITIAL_BALANCE,
                        selectedCard: null,
                        result: null,
                        isBot: true,
                        strategy: 'random'
                    });
                }

                this.gameData.jackpot = 0;
                this.gameData.bankRake = 0;
                this.gameData.selectedCards.clear();
                this.gameData.previousLoser = null;
                
                this.setState(GAME_STATES.WAITING_FOR_ROUND_START);
                console.log('Game data initialized:', this.gameData);
            }

            setState(newState) {
                const oldState = this.currentState;
                this.currentState = newState;
                
                console.log(`State changed: ${oldState} -> ${newState}`);
                
                this.stateListeners.forEach(listener => {
                    listener(newState, oldState);
                });
            }

            getState() {
                return this.currentState;
            }

            addStateListener(listener) {
                this.stateListeners.push(listener);
            }

            getGameData() {
                return this.gameData;
            }

            updateGameData(updates) {
                Object.assign(this.gameData, updates);
            }

            getPlayer(playerId) {
                return this.gameData.players.find(p => p.id === playerId);
            }

            getBetValue(card) {
                if (!card || !card.rank) {
                    console.error('Invalid card for bet value calculation:', card);
                    return 0;
                }
                
                const rank = card.rank;
                if (rank === 'A') return 10;
                if (rank === '2') return 15;
                if (rank === '3') return 23;
                if (rank === '4') return 34;
                if (rank === '5') return 51;
                if (rank === '6') return 76;
                if (rank === '7') return 114;
                if (rank === '8') return 171;
                if (rank === '9') return 256;
                return 0;
            }

            updatePlayer(playerId, updates) {
                const player = this.getPlayer(playerId);
                if (player) {
                    Object.assign(player, updates);
                }
            }

            selectCard(playerId, card) {
                if (this.currentState !== GAME_STATES.CARD_SELECTION) {
                    return false;
                }

                const isCardSelected = Array.from(this.gameData.selectedCards.values())
                    .some(selectedCard => selectedCard.rank === card.rank);

                if (isCardSelected) {
                    return false;
                }

                // Calculate bet value and subtract from player balance
                const betValue = this.getBetValue(card);
                const player = this.getPlayer(playerId);
                if (player) {
                    const newBalance = player.balance - betValue;
                    console.log(`${player.name} selected ${card.rank} (bet: $${betValue}), balance: $${player.balance} -> $${newBalance}`);
                    
                    this.updatePlayer(playerId, { 
                        selectedCard: card, 
                        balance: newBalance 
                    });
                } else {
                this.updatePlayer(playerId, { selectedCard: card });
                }

                this.gameData.selectedCards.set(playerId, card);
                
                // Check if all cards are selected
                const allSelected = this.allCardsSelected();
                console.log('All cards selected check:', allSelected, 'Selected cards count:', this.gameData.selectedCards.size, 'Total players:', GAME_CONFIG.TOTAL_PLAYERS);
                if (allSelected) {
                    console.log('All cards selected, moving to reveal phase...');
                    this.setState(GAME_STATES.REVEALING_CARDS);
                }
                
                return true;
            }

            startNewRound() {
                console.log('startNewRound called, current state:', this.currentState);
                if (this.currentState !== GAME_STATES.WAITING_FOR_ROUND_START && 
                    this.currentState !== GAME_STATES.ROUND_SUMMARY) {
                    console.log('Cannot start new round, invalid state:', this.currentState);
                    return false;
                }

                console.log('Starting new round...');
                this.gameData.players.forEach(player => {
                    player.selectedCard = null;
                    player.result = null;
                });
                this.gameData.selectedCards.clear();
                this.gameData.bankCard = null;

                // Reset bank card display to card back
                this.resetBankCardDisplay();

                this.setState(GAME_STATES.CARD_SELECTION);
                console.log('New round started, state changed to:', this.currentState);
                return true;
            }

            setBankCard(card) {
                this.gameData.bankCard = card;
                
                // Add to bank history
                if (!this.gameData.bankHistory) {
                    this.gameData.bankHistory = [];
                }
                this.gameData.bankHistory.push(card);
                
                // Keep only last 5 cards
                if (this.gameData.bankHistory.length > 5) {
                    this.gameData.bankHistory = this.gameData.bankHistory.slice(-5);
                }
            }

            getBankCard() {
                return this.gameData.bankCard;
            }

            updatePlayerBalance(playerId, amount) {
                const player = this.getPlayer(playerId);
                if (player) {
                    player.balance += amount;
                    if (player.balance < 0) {
                        player.balance = 0;
                    }
                    // Round to nearest integer
                    player.balance = Math.round(player.balance);
                }
            }

            updatePlayerStrategy(playerId, strategy) {
                const player = this.getPlayer(playerId);
                if (player) {
                    player.strategy = strategy;
                    console.log(`Player ${player.name} strategy updated to: ${strategy}`);
                }
            }

            pauseGame() {
                this.isPaused = true;
                console.log('Game paused by admin');
            }

            resumeGame() {
                this.isPaused = false;
                console.log('Game resumed by admin');
            }

            isGamePaused() {
                return this.isPaused;
            }

            updateJackpot(amount) {
                // Safety check for NaN or undefined
                if (isNaN(amount) || amount === undefined || amount === null) {
                    console.error('Invalid jackpot amount:', amount);
                    console.error('Stack trace:', new Error().stack);
                    return;
                }
                
                this.gameData.jackpot += amount;
                if (this.gameData.jackpot < 0) {
                    this.gameData.jackpot = 0;
                }
                // Round to nearest integer
                this.gameData.jackpot = Math.round(this.gameData.jackpot);
            }

            updateBankRake(amount) {
                // Safety check for NaN or undefined
                if (isNaN(amount) || amount === undefined || amount === null) {
                    console.error('Invalid bank rake amount:', amount);
                    return;
                }
                
                this.gameData.bankRake += amount;
                if (this.gameData.bankRake < 0) {
                    this.gameData.bankRake = 0;
                }
            }

            getTotalBalance() {
                const playerBalances = this.gameData.players.reduce((sum, player) => {
                    const balance = player.balance || 0;
                    if (isNaN(balance)) {
                        console.error('Invalid player balance:', player.name, balance);
                        return sum;
                    }
                    return sum + balance;
                }, 0);
                
                const jackpot = this.gameData.jackpot || 0;
                const bankRake = this.gameData.bankRake || 0;
                
                if (isNaN(jackpot)) {
                    console.error('Invalid jackpot:', jackpot);
                }
                if (isNaN(bankRake)) {
                    console.error('Invalid bank rake:', bankRake);
                }
                
                return playerBalances + jackpot + bankRake;
            }

            allCardsSelected() {
                const selectedCount = this.gameData.selectedCards.size;
                const totalPlayers = GAME_CONFIG.TOTAL_PLAYERS;
                const allSelected = selectedCount === totalPlayers;
                console.log(`allCardsSelected: ${allSelected} (${selectedCount}/${totalPlayers})`);
                return allSelected;
            }

            getAvailableCards() {
                const selectedRanks = Array.from(this.gameData.selectedCards.values())
                    .map(card => card.rank);
                
                console.log('=== getAvailableCards called ===');
                console.log('Selected cards map:', this.gameData.selectedCards);
                console.log('Selected ranks:', selectedRanks);
                
                const available = ['A', '2', '3', '4', '5', '6', '7', '8', '9']
                    .filter(rank => !selectedRanks.includes(rank));
                
                console.log('Available cards:', available);
                console.log('=== getAvailableCards complete ===');
                
                return available;
            }

            getPlayersByBalance() {
                // Sort players by balance (lowest first)
                return [...this.gameData.players].sort((a, b) => a.balance - b.balance);
            }

            getPreviousLoser() {
                return this.gameData.previousLoser;
            }

            setPreviousLoser(playerId) {
                this.gameData.previousLoser = playerId;
            }

            resetBankCardDisplay() {
                // This will be called by the UI controller to reset the bank card display
                console.log('Resetting bank card display...');
            }
        }

        // Game Logic
        class GameLogic {
            constructor(stateManager) {
                this.stateManager = stateManager;
            }

            generateRandomCard() {
                const rank = CARD_RANKS[Math.floor(Math.random() * CARD_RANKS.length)];
                const suit = CARD_SUITS[Math.floor(Math.random() * CARD_SUITS.length)];
                return { rank, suit };
            }

            getBetValue(card) {
                return CARD_VALUES[card.rank] || 0;
            }

            canAffordBet(playerId, card) {
                const player = this.stateManager.getPlayer(playerId);
                const betValue = this.getBetValue(card);
                return player && player.balance >= betValue;
            }

            processBankDraw() {
                const bankCard = this.generateRandomCard();
                
                console.log(`Bank drew: ${bankCard.rank} of ${bankCard.suit}`);
                
                // Don't set bank card in state yet - wait for animation
                // this.stateManager.setBankCard(bankCard);
                
                const losingPlayer = this.findLosingPlayer(bankCard);
                
                if (losingPlayer) {
                    this.stateManager.setPreviousLoser(losingPlayer.id);
                    this.processLosingPlayer(losingPlayer, bankCard);
                } else if (bankCard.rank === '10') {
                    this.processBankTen();
                } else if (bankCard.rank === 'A') {
                    this.processNoLoser();
                } else {
                    // Check if bank drew 2 and player has A
                    this.processPlayerAceWins(bankCard);
                }
                
                // Return the bank card for animation
                return bankCard;
            }

            findLosingPlayer(bankCard) {
                const gameData = this.stateManager.getGameData();
                
                for (const [playerId, selectedCard] of gameData.selectedCards) {
                    if (selectedCard.rank === bankCard.rank) {
                        const player = this.stateManager.getPlayer(playerId);
                        // Add the selected card to the player object
                        return { ...player, selectedCard };
                    }
                }
                
                return null;
            }

            processLosingPlayer(losingPlayer, bankCard) {
                console.log(`Processing losing player: ${losingPlayer.name} with card ${losingPlayer.selectedCard.rank}`);
                
                const betValue = this.getBetValue(losingPlayer.selectedCard);
                console.log(`DEBUG: betValue = ${betValue}, JACKPOT_RATE = ${GAME_CONFIG.JACKPOT_RATE}`);
                
                // Jackpot contribution is handled in distributeCascadeWinnings
                // No need to add it here to avoid double counting
                
                this.distributeCascadeWinnings(bankCard, betValue);
                
                if (losingPlayer.selectedCard.suit === 'hearts' && bankCard.suit === 'hearts') {
                    this.processJackpotPayout(losingPlayer);
                }
            }

            processBankTen() {
                console.log('Processing bank ten - all lose except player with 9, bank gets rate from all');
                const gameData = this.stateManager.getGameData();
                
                let playerWithNine = null;
                let playerWithNineBet = 0;
                let totalOtherBets = 0;
                let totalBankRake = 0;
                
                // Find player with 9 first
                for (const [playerId, selectedCard] of gameData.selectedCards) {
                    if (selectedCard.rank === '9') {
                        playerWithNine = this.stateManager.getPlayer(playerId);
                        playerWithNineBet = this.getBetValue(selectedCard);
                        break;
                    }
                }
                
                console.log(`Player with 9: ${playerWithNine ? playerWithNine.name : 'None'}, bet: $${playerWithNineBet}`);
                
                // Process all players - bank gets rate from all bets
                for (const [playerId, selectedCard] of gameData.selectedCards) {
                    const player = this.stateManager.getPlayer(playerId);
                    const betValue = this.getBetValue(selectedCard);
                    
                    // Calculate bank rate from each player
                    const bankRake = betValue * GAME_CONFIG.BANK_RATE;
                    totalBankRake += bankRake;
                    
                    console.log(`${player.name}: bet $${betValue}, bank rate: $${bankRake.toFixed(2)}`);
                    
                    // Set result to loss for all players (including player with 9)
                    this.stateManager.updatePlayer(playerId, { result: RESULT_TYPES.LOSS });
                    
                    // Add to total other bets (excluding player with 9)
                    if (selectedCard.rank !== '9') {
                        totalOtherBets += betValue;
                    }
                }
                
                // Update bank rake (no jackpot contribution for bank 10)
                this.stateManager.updateBankRake(totalBankRake);
                
                // If player with 9 exists, they win: their bet back + other players' bets minus bank rake
                if (playerWithNine) {
                    // Player with 9 gets: their bet back + (other players' bets - bank rake from other players)
                    const bankRakeFromOthers = totalBankRake - (playerWithNineBet * GAME_CONFIG.BANK_RATE);
                    const winningsFromOthers = totalOtherBets - bankRakeFromOthers;
                    const totalWinnings = playerWithNineBet + winningsFromOthers;
                    
                    this.stateManager.updatePlayerBalance(playerWithNine.id, totalWinnings);
                    this.stateManager.updatePlayer(playerWithNine.id, { result: RESULT_TYPES.WIN });
                    // Store actual winnings for display
                    this.stateManager.updatePlayer(playerWithNine.id, { actualWinnings: totalWinnings });
                    console.log(`${playerWithNine.name} wins ${totalWinnings} (bet back: ${playerWithNineBet} + from others: ${winningsFromOthers.toFixed(2)})`);
                }
                
                console.log(`Total other bets: $${totalOtherBets}, Bank rake: $${totalBankRake.toFixed(2)}, No jackpot contribution`);
                console.log('Final results:', gameData.players.map(p => ({ name: p.name, result: p.result })));
                this.stateManager.setPreviousLoser(null);
            }

            processNoLoser() {
                const gameData = this.stateManager.getGameData();
                
                console.log('Processing no loser - bank drew A, all players lose');
                
                let totalBets = 0;
                let totalBankRake = 0;
                let totalJackpot = 0;
                
                for (const [playerId, selectedCard] of gameData.selectedCards) {
                    const player = this.stateManager.getPlayer(playerId);
                    const betValue = this.getBetValue(selectedCard);
                    totalBets += betValue;
                    
                    // Calculate bank rate from each player
                    const bankRake = betValue * GAME_CONFIG.BANK_RATE;
                    const jackpotContribution = betValue - bankRake;
                    
                    totalBankRake += bankRake;
                    totalJackpot += jackpotContribution;
                    
                    console.log(`${player.name}: bet $${betValue}, bank rate: $${bankRake.toFixed(2)}, jackpot: $${jackpotContribution.toFixed(2)}`);
                    
                    // Set result to loss
                    this.stateManager.updatePlayer(playerId, { result: RESULT_TYPES.LOSS });
                }
                
                // Update bank rake and jackpot
                this.stateManager.updateBankRake(totalBankRake);
                this.stateManager.updateJackpot(totalJackpot);
                
                console.log(`Total bets: $${totalBets}, Bank rake: $${totalBankRake.toFixed(2)}, Jackpot: $${totalJackpot.toFixed(2)}`);
                this.stateManager.setPreviousLoser(null);
            }

            processPlayerAceWins(bankCard) {
                const gameData = this.stateManager.getGameData();
                
                console.log(`Processing player A wins - bank drew ${bankCard.rank}`);
                
                // Find player with A
                let playerWithA = null;
                for (const [playerId, selectedCard] of gameData.selectedCards) {
                    if (selectedCard.rank === 'A') {
                        playerWithA = this.stateManager.getPlayer(playerId);
                        break;
                    }
                }
                
                if (!playerWithA) {
                    console.log('No player with A found, processing as normal refund');
                    this.processNoLoser();
                    return;
                }
                
                // Find player with 2 (the one who loses)
                let playerWith2 = null;
                for (const [playerId, selectedCard] of gameData.selectedCards) {
                    if (selectedCard.rank === '2') {
                        playerWith2 = this.stateManager.getPlayer(playerId);
                        break;
                    }
                }
                
                if (!playerWith2) {
                    console.log('No player with 2 found, processing as normal refund');
                    this.processNoLoser();
                    return;
                }
                
                const bet2 = this.getBetValue(playerWith2.selectedCard);
                const bankRake = bet2 * GAME_CONFIG.BANK_RATE;
                const afterBankRate = bet2 - bankRake;
                const playerAWinnings = afterBankRate * 0.5; // 50% to player with A
                const jackpotContribution = afterBankRate * 0.5; // 50% to jackpot
                
                console.log(`Player with 2 (${playerWith2.name}): bet $${bet2}`);
                console.log(`Bank rate: $${bankRake.toFixed(2)}`);
                console.log(`Player with A (${playerWithA.name} gets: $${playerAWinnings.toFixed(2)}`);
                console.log(`Jackpot contribution: $${jackpotContribution.toFixed(2)}`);
                
                // Update bank rake and jackpot
                this.stateManager.updateBankRake(bankRake);
                this.stateManager.updateJackpot(jackpotContribution);
                
                // Set results
                this.stateManager.updatePlayer(playerWith2.id, { result: RESULT_TYPES.LOSS });
                this.stateManager.updatePlayerBalance(playerWithA.id, playerAWinnings);
                this.stateManager.updatePlayer(playerWithA.id, { result: RESULT_TYPES.WIN });
                
                // Set all other players to refund (minus jackpot rate)
                for (const [playerId, selectedCard] of gameData.selectedCards) {
                    if (playerId === playerWithA.id || playerId === playerWith2.id) continue;
                    
                    const player = this.stateManager.getPlayer(playerId);
                    const betValue = this.getBetValue(selectedCard);
                    const refundJackpot = betValue * GAME_CONFIG.JACKPOT_RATE;
                    const refundAmount = betValue - refundJackpot;
                    
                    this.stateManager.updatePlayerBalance(playerId, refundAmount);
                    this.stateManager.updatePlayer(playerId, { result: RESULT_TYPES.REFUND });
                    this.stateManager.updateJackpot(refundJackpot);
                    
                    console.log(`${player.name}: refund $${refundAmount.toFixed(2)} (jackpot: $${refundJackpot.toFixed(2)})`);
                }
                
                this.stateManager.setPreviousLoser(null);
            }


            distributeCascadeWinnings(bankCard, totalPool) {
                console.log(`\n=== DISTRIBUTING CASCADE WINNINGS ===`);
                console.log(`Bank card: ${bankCard.rank}, Total pool: ${totalPool}`);
                
                const gameData = this.stateManager.getGameData();
                const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9'];
                const bankIndex = rankOrder.indexOf(bankCard.rank);
                
                console.log(`Bank index: ${bankIndex} for rank ${bankCard.rank}`);
                
                // Find losing player
                const losingPlayer = this.findLosingPlayer(bankCard);
                const losingBet = this.getBetValue(losingPlayer.selectedCard);
                
                // Calculate bank rate from losing player
                const bankRake = losingBet * GAME_CONFIG.BANK_RATE;
                const winnerPool = losingBet - bankRake;
                
                console.log(`Losing bet: ${losingBet}`);
                console.log(`Bank rate: ${bankRake} (${GAME_CONFIG.BANK_RATE * 100}%)`);
                console.log(`Winner pool: ${winnerPool}`);
                console.log(`DEBUG: GAME_CONFIG.BANK_RATE = ${GAME_CONFIG.BANK_RATE}`);
                
                console.log(`DEBUG: About to update bank rake with: ${bankRake}`);
                this.stateManager.updateBankRake(bankRake);
                console.log(`DEBUG: Bank rake after update: ${this.stateManager.getGameData().bankRake}`);
                
                // Losing player already paid their bet when selecting card - no need to deduct again
                this.stateManager.updatePlayer(losingPlayer.id, { result: RESULT_TYPES.LOSS });
                console.log(`${losingPlayer.name} with ${losingPlayer.selectedCard.rank} LOSES ${losingBet} (already deducted when card was selected)`);
                
                // Categorize all OTHER players
                const winners = [];
                const refundPlayers = [];
                
                for (const [playerId, selectedCard] of gameData.selectedCards) {
                    // Skip the losing player
                    if (playerId === losingPlayer.id) {
                        continue;
                    }
                    
                    const playerIndex = rankOrder.indexOf(selectedCard.rank);
                    const player = this.stateManager.getPlayer(playerId);
                    
                    console.log(`Checking ${player.name} with ${selectedCard.rank} (index ${playerIndex})`);
                    
                    if (playerIndex < bankIndex) {
                        // Player has lower number - WINNER
                        winners.push({ playerId, selectedCard, index: playerIndex });
                        this.stateManager.updatePlayer(playerId, { result: RESULT_TYPES.WIN });
                        console.log(`  -> WINNER (${selectedCard.rank} < ${bankCard.rank})`);
                    } else if (playerIndex > bankIndex) {
                        // Player has higher number - REFUND
                        refundPlayers.push(playerId);
                        this.stateManager.updatePlayer(playerId, { result: RESULT_TYPES.REFUND });
                        console.log(`  -> REFUND (${selectedCard.rank} > ${bankCard.rank})`);
                    }
                }
                
                // Sort winners by card rank (descending - highest first)
                winners.sort((a, b) => b.index - a.index);
                console.log(`\nWinners: ${winners.map(w => this.stateManager.getPlayer(w.playerId).name + '(' + w.selectedCard.rank + ')').join(', ')}`);
                console.log(`Refunds: ${refundPlayers.map(id => this.stateManager.getPlayer(id).name).join(', ')}`);
                
                // Check for special rules
                const bankRank = bankCard.rank;
                let remainingPool = winnerPool;
                
                // Special Rule 1: Bank draws Ace - all money goes to jackpot (minus bank rake)
                if (bankRank === 'A') {
                    console.log(`Special Rule 1: Bank drew Ace - adding ${remainingPool} to jackpot`);
                    this.stateManager.updateJackpot(remainingPool);
                    remainingPool = 0;
                }
                // Special Rule 2: Bank draws 2 - only Ace wins, rest goes to jackpot
                else if (bankRank === '2') {
                    const aceWinner = winners.find(w => w.selectedCard.rank === 'A');
                    if (aceWinner) {
                        // Ace gets 50% of the pool
                        const aceWinAmount = remainingPool * GAME_CONFIG.CASCADE_RATE;
                        const aceBet = this.getBetValue(aceWinner.selectedCard);
                        const aceTotalWin = aceBet + aceWinAmount;
                        
                        this.stateManager.updatePlayerBalance(aceWinner.playerId, aceTotalWin);
                        this.stateManager.updatePlayer(aceWinner.playerId, { actualWinnings: aceTotalWin });
                        console.log(`Special Rule 2: ${this.stateManager.getPlayer(aceWinner.playerId).name} (Ace) wins ${aceTotalWin.toFixed(2)} (bet back: ${aceBet} + pool share: ${aceWinAmount.toFixed(2)})`);
                        
                        // Rest goes to jackpot
                        const jackpotAmount = remainingPool - aceWinAmount;
                        console.log(`Special Rule 2: Adding remaining ${jackpotAmount.toFixed(2)} to jackpot`);
                        this.stateManager.updateJackpot(jackpotAmount);
                        remainingPool = 0;
                    } else {
                        // No Ace winner - all goes to jackpot
                        console.log(`Special Rule 2: No Ace winner - adding ${remainingPool} to jackpot`);
                        this.stateManager.updateJackpot(remainingPool);
                        remainingPool = 0;
                    }
                }
                // Normal cascade distribution
                else if (winners.length > 0) {
                    let currentPool = remainingPool;
                    
                    for (let i = 0; i < winners.length; i++) {
                        const winner = winners[i];
                        let winAmount;
                        
                        if (i === winners.length - 1) {
                            // Last winner (lowest number) gets remaining pool
                            winAmount = currentPool;
                        } else {
                            // Each winner gets 50% of current pool
                            winAmount = currentPool * GAME_CONFIG.CASCADE_RATE;
                        }
                        
                        // Winners get their bet back PLUS pool share
                        const winnerBet = this.getBetValue(winner.selectedCard);
                        const totalWin = winnerBet + winAmount;
                        this.stateManager.updatePlayerBalance(winner.playerId, totalWin);
                        // Store the actual winnings for display purposes
                        this.stateManager.updatePlayer(winner.playerId, { actualWinnings: totalWin });
                        console.log(`  ${this.stateManager.getPlayer(winner.playerId).name} wins ${totalWin.toFixed(2)} (bet back: ${winnerBet} + pool share: ${winAmount.toFixed(2)})`);
                        
                        currentPool -= winAmount;
                    }
                    
                    // Any remaining pool goes to jackpot
                    if (currentPool > 0) {
                        console.log(`Adding remaining pool ${currentPool.toFixed(2)} to jackpot`);
                        this.stateManager.updateJackpot(currentPool);
                    }
                }
                // No winners - add remaining pool to jackpot
                else {
                    console.log(`No winners found - adding ${remainingPool} to jackpot`);
                    this.stateManager.updateJackpot(remainingPool);
                }
                
                // Process refund players (get their bet back minus jackpot rate)
                let totalRefundGiven = 0;
                let totalJackpotFromRefunds = 0;
                
                for (const refundPlayerId of refundPlayers) {
                    const refundPlayer = this.stateManager.getPlayer(refundPlayerId);
                    const betValue = this.getBetValue(refundPlayer.selectedCard);
                    const jackpotContribution = betValue * GAME_CONFIG.JACKPOT_RATE;
                    const refundAmount = betValue - jackpotContribution;
                    
                    console.log(`DEBUG: JACKPOT_RATE = ${GAME_CONFIG.JACKPOT_RATE}, jackpotContribution = ${jackpotContribution}`);
                    
                    this.stateManager.updatePlayerBalance(refundPlayerId, refundAmount);
                        this.stateManager.updateJackpot(jackpotContribution);
                    console.log(`  ${refundPlayer.name} refund ${refundAmount.toFixed(2)} (jackpot: ${jackpotContribution.toFixed(2)})`);
                    
                    totalRefundGiven += refundAmount;
                    totalJackpotFromRefunds += jackpotContribution;
                }
                
                console.log(`DEBUG: Total refund given: ${totalRefundGiven.toFixed(2)}`);
                console.log(`DEBUG: Total jackpot from refunds: ${totalJackpotFromRefunds.toFixed(2)}`);
                console.log(`DEBUG: Total money handled in refunds: ${(totalRefundGiven + totalJackpotFromRefunds).toFixed(2)}`);
                
                console.log(`=== END CASCADE DISTRIBUTION ===\n`);
            }

            processJackpotPayout(losingPlayer) {
                const gameData = this.stateManager.getGameData();
                const jackpotAmount = gameData.jackpot;
                
                if (jackpotAmount > 0) {
                    const payout = jackpotAmount * GAME_CONFIG.JACKPOT_PAYOUT_RATE;
                    const carryover = jackpotAmount * GAME_CONFIG.JACKPOT_CARRYOVER_RATE;
                    
                    this.stateManager.updatePlayerBalance(losingPlayer.id, payout);
                    this.stateManager.updatePlayer(losingPlayer.id, { result: RESULT_TYPES.JACKPOT });
                    this.stateManager.updateJackpot(-jackpotAmount + carryover);
                }
            }

            getTurnOrder() {
                const gameData = this.stateManager.getGameData();
                const previousLoser = this.stateManager.getPreviousLoser();
                
                console.log('getTurnOrder called, previousLoser:', previousLoser);
                
                if (previousLoser !== null) {
                    // Previous loser goes first
                    const previousLoserPlayer = this.stateManager.getPlayer(previousLoser);
                    const otherPlayers = gameData.players.filter(p => p.id !== previousLoser);
                    
                    // Sort other players by balance (lowest first)
                    // If balances are equal, randomize the order
                    otherPlayers.sort((a, b) => {
                        if (a.balance === b.balance) {
                            // Random order when balances are equal
                            return Math.random() - 0.5;
                        }
                        return a.balance - b.balance;
                    });
                    
                    const turnOrder = [previousLoserPlayer, ...otherPlayers].filter(p => p !== null);
                    console.log('Turn order (previous loser first, others by balance):', turnOrder.map(p => ({ id: p.id, name: p.name, isHuman: p.isHuman, balance: p.balance })));
                    return turnOrder;
                } else {
                    // First round - sort all players by balance (lowest first)
                    // If balances are equal, randomize the order
                    const turnOrder = [...gameData.players].sort((a, b) => {
                        if (a.balance === b.balance) {
                            // Random order when balances are equal
                            return Math.random() - 0.5;
                        }
                        return a.balance - b.balance;
                    });
                    console.log('Turn order (first round, by balance with random tie-breaker):', turnOrder.map(p => ({ id: p.id, name: p.name, isHuman: p.isHuman, balance: p.balance })));
                    return turnOrder;
                }
            }

            validateGameState() {
                const gameData = this.stateManager.getGameData();
                const totalBalance = this.stateManager.getTotalBalance();
                const expectedTotal = GAME_CONFIG.TOTAL_PLAYERS * GAME_CONFIG.INITIAL_BALANCE;
                
                // Detailed balance breakdown
                const playerBalances = gameData.players.reduce((sum, player) => sum + (player.balance || 0), 0);
                const jackpot = gameData.jackpot || 0;
                const bankRake = gameData.bankRake || 0;
                
                // Calculate difference and percentage
                const difference = totalBalance - expectedTotal;
                const percentage = Math.abs(difference) / expectedTotal * 100;
                const acceptanceThreshold = 0.2; // 0.2% acceptance threshold
                
                console.log('=== BALANCE VALIDATION ===');
                console.log(`Player balances: $${playerBalances}`);
                console.log(`Jackpot: $${jackpot}`);
                console.log(`Bank rake: $${bankRake}`);
                console.log(`Total: $${totalBalance}`);
                console.log(`Expected: $${expectedTotal}`);
                console.log(`Difference: $${difference}`);
                console.log(`Percentage: ${percentage.toFixed(4)}%`);
                console.log(`Acceptance threshold: ${acceptanceThreshold}%`);
                
                if (percentage > acceptanceThreshold) {
                    console.error(`Balance leak detected! Expected: ${expectedTotal}, Actual: ${totalBalance}, Difference: ${percentage.toFixed(4)}%`);
                    return false;
                } else {
                    console.log(`✅ Balance within acceptable range (${percentage.toFixed(4)}% < ${acceptanceThreshold}%)`);
                }
                console.log('========================');
                
                return true;
            }
        }

        // Sound Manager
        class SoundManager {
            constructor() {
                this.soundsEnabled = true;
                this.audioContext = null;
                this.sounds = {};
                this.initializeAudio();
            }
            
            initializeAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.createSounds();
                } catch (error) {
                    console.warn('Audio not supported:', error);
                }
            }
            
            createSounds() {
                // Card selection sound (short beep)
                this.sounds.cardSelect = this.createTone(800, 0.1, 'sine');
                
                // Win sound (glad, ascending melody)
                this.sounds.win = this.createMelody([523, 659, 784, 1047], 0.15);
                
                // Loss sound (ledsam, descending tone)
                this.sounds.loss = this.createTone(300, 0.4, 'sawtooth');
                
                // Refund sound (neutral, simple tone)
                this.sounds.refund = this.createTone(440, 0.2, 'sine');
                
                // Jackpot sound (trumpetljud)
                this.sounds.jackpot = this.createTrumpetSound();
                
                // Bank draw sound (dramatic tone)
                this.sounds.bankDraw = this.createTone(200, 0.5, 'triangle');
                
                // Round start sound
                this.sounds.roundStart = this.createMelody([440, 554, 659], 0.2);
                
                // Card drag sound (raspigt dragljud)
                this.sounds.cardDrag = this.createRaspySound();
            }
            
            createTone(frequency, duration, waveType = 'sine') {
                return () => {
                    if (!this.soundsEnabled || !this.audioContext) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                    oscillator.type = waveType;
                    
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration);
                };
            }
            
            createMelody(frequencies, noteDuration) {
                return () => {
                    if (!this.soundsEnabled || !this.audioContext) return;
                    
                    frequencies.forEach((freq, index) => {
                        setTimeout(() => {
                            const oscillator = this.audioContext.createOscillator();
                            const gainNode = this.audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.audioContext.destination);
                            
                            oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                            oscillator.type = 'sine';
                            
                            gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + noteDuration);
                            
                            oscillator.start(this.audioContext.currentTime);
                            oscillator.stop(this.audioContext.currentTime + noteDuration);
                        }, index * noteDuration * 1000);
                    });
                };
            }
            
            createRaspySound() {
                return () => {
                    console.log('createRaspySound called, soundsEnabled:', this.soundsEnabled, 'audioContext:', !!this.audioContext);
                    if (!this.soundsEnabled || !this.audioContext) return;
                    
                    const duration = 0.3;
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    // Skapa raspigt ljud med låg frekvens och filter
                    oscillator.frequency.setValueAtTime(150, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(80, this.audioContext.currentTime + duration);
                    oscillator.type = 'sawtooth';
                    
                    // Lägg till filter för raspigt ljud
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(200, this.audioContext.currentTime);
                    filter.Q.setValueAtTime(10, this.audioContext.currentTime);
                    
                    // Gain för att kontrollera volym (högre volym)
                    gainNode.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    
                    oscillator.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration);
                };
            }
            
            createTrumpetSound() {
                return () => {
                    if (!this.soundsEnabled || !this.audioContext) return;
                    
                    const duration = 1.5;
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    // Trumpetljud - stigande melodi
                    oscillator.frequency.setValueAtTime(220, this.audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(440, this.audioContext.currentTime + 0.5);
                    oscillator.frequency.linearRampToValueAtTime(660, this.audioContext.currentTime + 1.0);
                    oscillator.frequency.linearRampToValueAtTime(880, this.audioContext.currentTime + 1.5);
                    oscillator.type = 'sawtooth';
                    
                    // Filter för trumpetljud
                    filter.type = 'bandpass';
                    filter.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    filter.Q.setValueAtTime(5, this.audioContext.currentTime);
                    
                    // Gain för trumpetljud (högre volym)
                    gainNode.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    
                    oscillator.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration);
                };
            }
            
            playSound(soundName) {
                if (this.sounds[soundName]) {
                    this.sounds[soundName]();
                }
            }
            
            setEnabled(enabled) {
                this.soundsEnabled = enabled;
            }
            
            isEnabled() {
                return this.soundsEnabled;
            }
        }

        // Bot Controller
        class BotController {
            constructor(stateManager, gameLogic) {
                this.stateManager = stateManager;
                this.gameLogic = gameLogic;
                this.botTimeouts = new Map();
            }

            setBotStrategy(botId, strategy) {
                const player = this.stateManager.getPlayer(botId);
                if (player && player.isBot) {
                    this.stateManager.updatePlayer(botId, { strategy });
                }
            }

            getBotStrategy(botId) {
                const player = this.stateManager.getPlayer(botId);
                return player && player.isBot ? player.strategy : null;
            }

            async makeBotMove(botId) {
                const player = this.stateManager.getPlayer(botId);
                if (!player) {
                    console.log(`Player ${botId} not found`);
                    return false;
                }

                // Check if human player strategy is manual - if so, skip automatic move
                if (player.isHuman && player.strategy === 'manual') {
                    console.log(`Player ${botId} is human with manual strategy - skipping automatic move`);
                    return false;
                }

                // Get strategy from UI dropdown (for bots) or player strategy (for human players)
                let strategy;
                if (player.isHuman) {
                    // For human players, get strategy from player object
                    strategy = player.strategy;
                } else {
                    // For bots, get strategy from UI dropdown
                    const strategySelect = document.getElementById(`bot-strategy-${botId}`);
                    strategy = strategySelect ? strategySelect.value : 'random';
                }
                const availableCards = this.stateManager.getAvailableCards();
                
                console.log(`Player ${botId} (${player.name}) strategy: ${strategy}, available cards:`, availableCards);
                
                if (availableCards.length === 0) {
                    console.log(`No available cards for player ${botId}`);
                    return false;
                }

                let selectedRank = null;

                switch (strategy) {
                    case 'random':
                        selectedRank = this.getRandomCard(availableCards);
                        break;
                    case 'lowest':
                        selectedRank = this.getLowestCard(availableCards);
                        break;
                    case 'highest':
                        selectedRank = this.getHighestCard(availableCards);
                        break;
                    case 'manual':
                        return this.waitForManualSelection(botId);
                    default:
                        selectedRank = this.getRandomCard(availableCards);
                }

                if (selectedRank) {
                    // Assign a random suit to the bot's card
                    const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
                    const suit = suits[Math.floor(Math.random() * suits.length)];
                    const card = { rank: selectedRank, suit };
                    const success = this.stateManager.selectCard(botId, card);
                    
                    if (success) {
                        // Update the table card to show who selected it
                        // This will be handled by the UI controller
                        console.log(`Bot ${botId} (${player.name}) selected card ${selectedRank}`);
                    }
                    
                    console.log(`Bot ${botId} selected ${selectedRank} of ${suit}, success: ${success}`);
                    return success;
                }

                console.log(`Bot ${botId} failed to select a card`);
                return false;
            }

            getRandomCard(availableCards) {
                if (availableCards.length === 0) return null;
                return availableCards[Math.floor(Math.random() * availableCards.length)];
            }

            getLowestCard(availableCards) {
                const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9'];
                const sortedCards = availableCards.sort((a, b) => rankOrder.indexOf(a) - rankOrder.indexOf(b));
                return sortedCards[0];
            }

            getHighestCard(availableCards) {
                const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9'];
                const sortedCards = availableCards.sort((a, b) => rankOrder.indexOf(b) - rankOrder.indexOf(a));
                return sortedCards[0];
            }

            waitForManualSelection(botId) {
                return new Promise((resolve) => {
                    console.log(`=== Manual selection for bot ${botId} - showing admin interface ===`);
                    
                    // Store the resolve function for this bot
                    this.pendingManualSelection = { botId, resolve };
                    
                    // Signal to UIController to show admin interface
                    if (window.game && window.game.uiController) {
                        window.game.uiController.showAdminManualSelection(botId, resolve);
                    } else {
                        console.error('UIController not available for admin selection');
                        // Fallback to random selection
                        const availableCards = this.stateManager.getAvailableCards();
                        const selectedRank = this.getRandomCard(availableCards);
                        if (selectedRank) {
                            const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
                            const suit = suits[Math.floor(Math.random() * suits.length)];
                            const card = { rank: selectedRank, suit };
                            this.stateManager.selectCard(botId, card);
                        }
                        resolve(true);
                    }
                });
            }


            async processAllBotMoves() {
                const gameData = this.stateManager.getGameData();
                const bots = gameData.players.filter(p => p.isBot && !p.selectedCard);
                
                for (const bot of bots) {
                    await this.makeBotMove(bot.id);
                    
                    if (bot.id < bots[bots.length - 1].id) {
                        await this.delay(GAME_CONFIG.BOT_DELAY);
                    }
                }
            }

            animateCardToPlayer(cardElement, playerId) {
                console.log(`=== animateCardToPlayer called for player ${playerId} ===`);
                const playerSeat = document.getElementById(`player-${playerId}`);
                if (!playerSeat) {
                    console.error(`Player seat not found for ID: ${playerId}`);
                    return;
                }
                
                // Create a copy of the card for animation
                const animatedCard = cardElement.cloneNode(true);
                animatedCard.style.position = 'fixed';
                animatedCard.style.zIndex = '1000';
                animatedCard.style.pointerEvents = 'none';
                
                // Add to game container
                this.elements.gameContainer.appendChild(animatedCard);
                
                const seatRect = playerSeat.getBoundingClientRect();
                const cardRect = cardElement.getBoundingClientRect();
                const gameRect = this.elements.gameContainer.getBoundingClientRect();
                
                // Calculate relative positions
                const targetX = seatRect.left - gameRect.left + (seatRect.width / 2) - 20; // Center on seat
                const targetY = seatRect.top - gameRect.top + (seatRect.height / 2) - 30; // Center on seat
                const startX = cardRect.left - gameRect.left;
                const startY = cardRect.top - gameRect.top;
                
                console.log(`Animating card from (${startX}, ${startY}) to (${targetX}, ${targetY})`);
                
                // Set initial position
                animatedCard.style.left = `${startX}px`;
                animatedCard.style.top = `${startY}px`;
                animatedCard.style.transition = 'all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                
                // Animate to player position
                setTimeout(() => {
                    console.log(`Moving card to player position: (${targetX}, ${targetY})`);
                    animatedCard.style.left = `${targetX}px`;
                    animatedCard.style.top = `${targetY}px`;
                    animatedCard.style.transform = 'scale(0.6)';
                }, 50);
                
                // Remove the animated card after animation
                setTimeout(() => {
                    console.log(`Removing animated card for player ${playerId}`);
                    if (animatedCard.parentNode) {
                        animatedCard.parentNode.removeChild(animatedCard);
                    }
                }, 1000);
            }

            disableCardSelection() {
                console.log('Disabling card selection');
                const tableCards = document.querySelectorAll('.table-card');
                tableCards.forEach(card => {
                    if (card._cardClickHandler) {
                        card.removeEventListener('click', card._cardClickHandler);
                        card._cardClickHandler = null;
                    }
                    card.classList.add('unavailable');
                    card.style.pointerEvents = 'none'; // Disable all mouse events
                    card.style.cursor = 'not-allowed';
                });
            }


            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // UI Controller
        class UIController {
            constructor(stateManager, gameLogic, botController) {
                this.stateManager = stateManager;
                this.gameLogic = gameLogic;
                this.botController = botController;
                this.soundManager = new SoundManager();
                this.animationQueue = [];
                this.isAnimating = false;
                
                this.initializeElements();
                this.setupEventListeners();
                this.setupStateListeners();
            }

            initializeElements() {
                console.log('Initializing UI elements...');
                this.elements = {
                    gameContainer: document.getElementById('game-container'),
                    playerSeats: document.querySelector('.player-seats'),
                    bankCard: document.getElementById('bank-card'),
                    jackpotAmount: document.getElementById('jackpot-amount'),
                    bankHistoryList: document.getElementById('bank-history-list'),
                    startRoundBtn: document.getElementById('start-round-btn'),
                    adminPanelBtn: document.getElementById('admin-panel-btn'),
                    adminPanel: document.getElementById('admin-panel'),
                    gameState: document.getElementById('game-state'),
                    gameTimer: document.getElementById('game-timer'),
                    totalBalance: document.getElementById('total-balance'),
                    expectedBalance: document.getElementById('expected-balance'),
                    playerBalances: document.getElementById('player-balances'),
                    adminJackpot: document.getElementById('admin-jackpot'),
                    adminBankRake: document.getElementById('admin-bank-rake'),
                    adminBankRakeDisplay: document.getElementById('admin-bank-rake-display'),
                    adminRound: document.getElementById('admin-round'),
                    currentRound: document.getElementById('current-round'),
                };
                
                console.log('UI elements initialized:', this.elements);
            }

            setupEventListeners() {
                console.log('Setting up event listeners...');
                
                if (this.elements.startRoundBtn) {
                    this.elements.startRoundBtn.addEventListener('click', () => {
                        console.log('Start round button clicked');
                        this.startNewRound();
                    });
                } else {
                    console.error('Start round button not found!');
                }
                
                if (this.elements.adminPanelBtn) {
                    this.elements.adminPanelBtn.addEventListener('click', () => this.toggleAdminPanel());
                }
                
                // Make admin panel draggable
                this.makeAdminPanelDraggable();
                
                // Sound toggle control
                const soundToggle = document.getElementById('sound-toggle');
                if (soundToggle) {
                    soundToggle.addEventListener('change', (e) => {
                        this.soundManager.setEnabled(e.target.checked);
                        console.log('Sound effects:', e.target.checked ? 'enabled' : 'disabled');
                    });
                }
                
                // Close admin panel button
                const closeAdminBtn = document.getElementById('close-admin-btn');
                if (closeAdminBtn) {
                    closeAdminBtn.addEventListener('click', () => this.toggleAdminPanel());
                }

                // Rules button
                const rulesBtn = document.getElementById('rules-btn');
                if (rulesBtn) {
                    rulesBtn.addEventListener('click', () => this.showRules());
                }

                // Close rules button
                const closeRulesBtn = document.getElementById('close-rules-btn');
                if (closeRulesBtn) {
                    closeRulesBtn.addEventListener('click', () => this.hideRules());
                }

                // Matrix button
                const matrixBtn = document.getElementById('matrix-btn');
                if (matrixBtn) {
                    matrixBtn.addEventListener('click', () => this.showMatrix());
                }

                // Close matrix button
                const closeMatrixBtn = document.getElementById('close-matrix-btn');
                if (closeMatrixBtn) {
                    closeMatrixBtn.addEventListener('click', () => this.hideMatrix());
                }
                
                // Rate controls
                const jackpotRate = document.getElementById('jackpot-rate');
                const bankRate = document.getElementById('bank-rate');
                
                if (jackpotRate) {
                    // Initialize with current values
                    jackpotRate.value = Math.round(GAME_CONFIG.JACKPOT_RATE * 100);
                    
                    jackpotRate.addEventListener('change', (e) => {
                        GAME_CONFIG.JACKPOT_RATE = parseFloat(e.target.value) / 100;
                        console.log('Jackpot rate updated to:', GAME_CONFIG.JACKPOT_RATE, '(', e.target.value, '%)');
                    });
                }
                
                if (bankRate) {
                    // Initialize with current values
                    bankRate.value = Math.round(GAME_CONFIG.BANK_RATE * 100);
                    
                    bankRate.addEventListener('change', (e) => {
                        GAME_CONFIG.BANK_RATE = parseFloat(e.target.value) / 100;
                        console.log('Bank rate updated to:', GAME_CONFIG.BANK_RATE, '(', e.target.value, '%)');
                    });
                }
                
                // Admin panel is now always visible, so we don't auto-close it
                // document.addEventListener('click', (e) => {
                //     if (!this.elements.adminPanel.contains(e.target) && 
                //         !this.elements.adminPanelBtn.contains(e.target)) {
                //         this.elements.adminPanel.classList.add('hidden');
                //     }
                // });

                // Close rules modal when clicking outside
                document.addEventListener('click', (e) => {
                    const rulesModal = document.getElementById('rules-modal');
                    if (rulesModal && !rulesModal.classList.contains('hidden')) {
                        if (e.target === rulesModal) {
                            this.hideRules();
                        }
                    }
                });

                // Close matrix modal when clicking outside
                document.addEventListener('click', (e) => {
                    const matrixModal = document.getElementById('matrix-modal');
                    if (matrixModal && !matrixModal.classList.contains('hidden')) {
                        if (e.target === matrixModal) {
                            this.hideMatrix();
                        }
                    }
                });
                
                // Add pause/resume button listeners
                const pauseBtn = document.getElementById('pause-game-btn');
                const resumeBtn = document.getElementById('resume-game-btn');
                
                if (pauseBtn) {
                    pauseBtn.addEventListener('click', () => {
                        this.stateManager.pauseGame();
                        console.log('Game paused by admin');
                    });
                }
                
                if (resumeBtn) {
                    resumeBtn.addEventListener('click', () => {
                        this.stateManager.resumeGame();
                        console.log('Game resumed by admin');
                    });
                }
                
                console.log('Event listeners set up');
            }

            showRules() {
                const rulesModal = document.getElementById('rules-modal');
                if (rulesModal) {
                    rulesModal.classList.remove('hidden');
                }
            }

            hideRules() {
                const rulesModal = document.getElementById('rules-modal');
                if (rulesModal) {
                    rulesModal.classList.add('hidden');
                }
            }

            showMatrix() {
                const matrixModal = document.getElementById('matrix-modal');
                if (matrixModal) {
                    matrixModal.classList.remove('hidden');
                }
            }

            hideMatrix() {
                const matrixModal = document.getElementById('matrix-modal');
                if (matrixModal) {
                    matrixModal.classList.add('hidden');
                }
            }

            setupBotStrategyListeners() {
                // Add event listeners for all bot strategy dropdowns and human strategy buttons
                for (let i = 0; i < GAME_CONFIG.TOTAL_PLAYERS; i++) {
                    const player = this.stateManager.getPlayer(i);
                    
                    if (!player) {
                        console.log(`Player ${i} not found, skipping...`);
                        continue;
                    }
                    
                    if (player.isHuman) {
                        // Human player gets strategy buttons
                        const strategyButtons = document.querySelectorAll(`#player-${i} .strategy-btn, #human-strategy-${i} .strategy-btn`);
                        strategyButtons.forEach(button => {
                            button.addEventListener('click', (e) => {
                                e.preventDefault();
                                const strategy = button.dataset.strategy;
                                console.log(`Human player strategy changed to: ${strategy}`);
                                
                                // Update active button in both locations
                                const allButtons = document.querySelectorAll(`#player-${i} .strategy-btn, #human-strategy-${i} .strategy-btn`);
                                allButtons.forEach(btn => btn.classList.remove('active'));
                                button.classList.add('active');
                                
                                // Update player strategy in state
                                this.stateManager.updatePlayerStrategy(i, strategy);
                            });
                        });
                    } else {
                        // Bot players get dropdowns
                        const strategySelect = document.getElementById(`bot-strategy-${i}`);
                        if (strategySelect) {
                            strategySelect.addEventListener('change', (e) => {
                                console.log(`Bot ${i} strategy changed to: ${e.target.value}`);
                                this.stateManager.updatePlayerStrategy(i, e.target.value);
                            });
                        }
                    }
                }
            }

            setupStateListeners() {
                this.stateManager.addStateListener((newState, oldState) => {
                    this.handleStateChange(newState, oldState);
                });
            }

            handleStateChange(newState, oldState) {
                console.log(`UI: State changed from ${oldState} to ${newState}`);
                
                switch (newState) {
                    case GAME_STATES.WAITING_FOR_ROUND_START:
                        this.updateWaitingState();
                        break;
                    case GAME_STATES.CARD_SELECTION:
                        this.updateCardSelectionState();
                        break;
                    case GAME_STATES.REVEALING_CARDS:
                        this.updateRevealingCardsState();
                        break;
                    case GAME_STATES.BANK_DRAW:
                        this.updateBankDrawState();
                        break;
                    case GAME_STATES.DISTRIBUTE_WINNINGS:
                        this.updateDistributeWinningsState();
                        break;
                    case GAME_STATES.ROUND_SUMMARY:
                        this.updateRoundSummaryState();
                        break;
                }
            }

            initializeGame() {
                console.log('Initializing game UI...');
                this.createPlayerSeats();
                this.updateGameDisplay();
                // updateAdminPanel() is now called automatically from updateGameDisplay()
                // Clear any existing result text from previous games
                this.clearPlayerResultClasses();
                console.log('Game UI initialized');
            }

            createPlayerSeats() {
                console.log('Creating player seats...');
                this.elements.playerSeats.innerHTML = '';
                
                const gameData = this.stateManager.getGameData();
                console.log('Game data for seats:', gameData);
                
                // Table is 900px x 700px, so center is at 450, 350
                const centerX = 450;
                const centerY = 350;
                const radiusX = 350; // Horizontal radius
                const radiusY = 250; // Vertical radius
                
                gameData.players.forEach((player, index) => {
                    // Calculate angle for each player (starting from top, going clockwise)
                    const angle = (index * 2 * Math.PI) / GAME_CONFIG.TOTAL_PLAYERS - Math.PI / 2;
                    const x = centerX + radiusX * Math.cos(angle) - 60; // -60 to center the seat
                    let y = centerY + radiusY * Math.sin(angle) - 40; // -40 to center the seat
                    
                    // Move specific players higher up (closer to edge of table)
                    if (player.id === 8 || player.id === 0 || player.id === 1) {
                        y -= 50; // Move 50px higher up
                    }
                    
                    const seat = document.createElement('div');
                    seat.className = `player-seat ${player.isHuman ? 'human' : ''}`;
                    seat.id = `player-${player.id}`;
                    seat.style.left = `${x}px`;
                    seat.style.top = `${y}px`;
                    
                    seat.innerHTML = `
                        <div class="player-name">${player.name}</div>
                        <div class="player-balance">$${player.balance}</div>
                        <div class="bot-controls" id="bot-controls-${player.id}">
                            ${player.isHuman ? `
                                <div class="strategy-buttons">
                                    <button class="strategy-btn ${player.strategy === 'random' ? 'active' : ''}" data-strategy="random">Random</button>
                                    <button class="strategy-btn ${player.strategy === 'lowest' ? 'active' : ''}" data-strategy="lowest">Lowest</button>
                                    <button class="strategy-btn ${player.strategy === 'highest' ? 'active' : ''}" data-strategy="highest">Highest</button>
                                    <button class="strategy-btn ${player.strategy === 'manual' ? 'active' : ''}" data-strategy="manual">Manual</button>
                                </div>
                            ` : `
                                <select class="bot-strategy" id="bot-strategy-${player.id}">
                                    <option value="random" ${player.strategy === 'random' ? 'selected' : ''}>Random</option>
                                    <option value="lowest" ${player.strategy === 'lowest' ? 'selected' : ''}>Lowest</option>
                                    <option value="highest" ${player.strategy === 'highest' ? 'selected' : ''}>Highest</option>
                                    <option value="manual" ${player.strategy === 'manual' ? 'selected' : ''}>Manual</option>
                                </select>
                            `}
                            <div class="manual-timer" id="manual-timer-${player.id}" style="display: none;">
                                <span class="timer-text">5s</span>
                            </div>
                        </div>
                        <div class="player-card" id="card-${player.id}" style="background: linear-gradient(145deg, #fff, #f0f0f0); border: 2px solid #333; color: #333;"></div>
                    `;
                    
                    // For "You" player, create strategy buttons outside the seat to the left
                    if (player.id === 0) {
                        const strategyContainer = document.createElement('div');
                        strategyContainer.className = 'human-strategy-container';
                        strategyContainer.id = `human-strategy-${player.id}`;
                        strategyContainer.innerHTML = `
                            <div class="strategy-buttons">
                                <button class="strategy-btn ${player.strategy === 'random' ? 'active' : ''}" data-strategy="random">Random</button>
                                <button class="strategy-btn ${player.strategy === 'lowest' ? 'active' : ''}" data-strategy="lowest">Lowest</button>
                                <button class="strategy-btn ${player.strategy === 'highest' ? 'active' : ''}" data-strategy="highest">Highest</button>
                                <button class="strategy-btn ${player.strategy === 'manual' ? 'active' : ''}" data-strategy="manual">Manual</button>
                            </div>
                        `;
                        
                        // Position strategy container to the left of "You" player
                        const strategyX = x - 60; // 60px to the left of seat (half step back)
                        const strategyY = y + 10;  // Align with top of seat
                        strategyContainer.style.left = `${strategyX}px`;
                        strategyContainer.style.top = `${strategyY}px`;
                        
                        this.elements.playerSeats.appendChild(strategyContainer);
                        
                        // Hide the strategy buttons inside the seat for "You" player
                        const seatControls = seat.querySelector('.bot-controls');
                        if (seatControls) {
                            seatControls.style.display = 'none';
                        }
                    }
                    
                    // Human players can click directly on table cards when it's their turn
                    // No need for seat click handler
                    
                    this.elements.playerSeats.appendChild(seat);
                    
                    // Create chip stack next to player seat
                    const chipStack = document.createElement('div');
                    chipStack.className = 'chip-stack-container';
                    chipStack.id = `chip-stack-${player.id}`;
                    chipStack.innerHTML = this.generateChipStack(player.balance);
                    
                    // Position chip stack next to player seat
                    // For "You" player (id 0), move chip stack to the right to avoid covering controls
                    let stackX, stackY;
                    if (player.id === 0) {
                        stackX = x + 130; // To the right of seat
                        stackY = y + 20;  // Align with middle of seat
                    } else {
                        stackX = x + 130; // To the right of seat
                        stackY = y + 20;  // Align with middle of seat
                    }
                    
                    chipStack.style.left = `${stackX}px`;
                    chipStack.style.top = `${stackY}px`;
                    
                    this.elements.playerSeats.appendChild(chipStack);
                });
                
                // Setup bot strategy listeners after seats are created
                this.setupBotStrategyListeners();
            }

            updatePlayerSeats() {
                console.log('Updating player seats...');
                const gameData = this.stateManager.getGameData();
                
                if (!gameData || !gameData.players || gameData.players.length === 0) {
                    console.log('No game data available, skipping player seat update');
                    return;
                }
                
                gameData.players.forEach(player => {
                    // Update balance
                    const balanceElement = document.querySelector(`#player-${player.id} .player-balance`);
                    if (balanceElement) {
                        balanceElement.textContent = `$${Math.round(player.balance)}`;
                    }
                    
                    // Clear player card
                    const cardElement = document.querySelector(`#player-${player.id} .player-card`);
                    if (cardElement) {
                        cardElement.innerHTML = '';
                        cardElement.className = 'player-card';
                    }
                    
                    // Clear result classes
                    const seatElement = document.querySelector(`#player-${player.id}`);
                    if (seatElement) {
                        seatElement.classList.remove('win', 'loss', 'refund', 'jackpot');
                    }
                });
                
                // Re-setup bot strategy listeners to preserve functionality
                this.setupBotStrategyListeners();
            }

            showCardSelectionModal(playerId) {
                console.log('=== showCardSelectionModal called with playerId:', playerId, '===');
                const player = this.stateManager.getPlayer(playerId);
                console.log('Player details:', player);
                
                // Only proceed if this is a human player
                if (!player || !player.isHuman) {
                    console.log('=== showCardSelectionModal: Not a human player, skipping ===');
                    return;
                }
                
                const availableCards = this.stateManager.getAvailableCards();
                console.log('Available cards:', availableCards);
                
                // Additional debugging for first player
                if (playerId === 0) {
                    console.log('=== FIRST PLAYER DEBUG ===');
                    console.log('Game state:', this.stateManager.getState());
                    console.log('Player strategy:', player.strategy);
                    console.log('Player isHuman:', player.isHuman);
                    console.log('Available cards count:', availableCards.length);
                }
                
                // Don't clean up duplicate cards during human player's turn
                // This prevents bot cards from disappearing when it's the human's turn
                console.log('Skipping duplicate card cleanup during human player turn');
                
                // Clear all existing event listeners first
                const tableCards = document.querySelectorAll('.table-card');
                console.log('Found table cards:', tableCards.length);
                tableCards.forEach(card => {
                    if (card._cardClickHandler) {
                        card.removeEventListener('click', card._cardClickHandler);
                        card._cardClickHandler = null;
                    }
                });
                
                // Enable table cards for selection
                tableCards.forEach(card => {
                    const rank = card.dataset.rank;
                    console.log(`Processing card ${rank}, available: ${availableCards.includes(rank)}`);
                    if (availableCards.includes(rank)) {
                        card.classList.remove('unavailable');
                        card.style.pointerEvents = 'auto';
                        card.style.cursor = 'pointer';
                        // Find the card-rank element inside this card
                        const cardRankElement = card.querySelector('.card-rank');
                        
                        if (cardRankElement) {
                            // Create new event handler for the card-rank element
                            cardRankElement._cardClickHandler = (e) => {
                                console.log('=== HUMAN PLAYER CARD CLICKED ===');
                                console.log('Card clicked, calling selectTableCard with playerId:', playerId);
                                console.log('Card element:', card);
                                console.log('Card rank:', card.dataset.rank);
                                console.log('Event target:', e.target);
                                console.log('Event currentTarget:', e.currentTarget);
                                console.log('Player ID from handler:', playerId);
                                console.log('Game state at click:', this.stateManager.getState());
                                e.preventDefault();
                                e.stopPropagation();
                                this.selectTableCard(card, playerId);
                            };
                            cardRankElement.addEventListener('click', cardRankElement._cardClickHandler, true); // Use capture phase
                            console.log(`Added click handler to card-rank element ${rank} for human player`);
                        } else {
                            console.log(`Warning: No .card-rank element found inside card ${rank}`);
                        }
                        
                        // Add test event listeners to the card-rank element if it exists
                        if (cardRankElement) {
                            // Add a simple test to verify the card-rank is clickable
                            cardRankElement.addEventListener('mousedown', () => {
                                console.log(`Mouse down on card-rank ${rank} - card is responsive for human player`);
                            });
                            
                            // Add hover test to verify card-rank is interactive
                            cardRankElement.addEventListener('mouseenter', () => {
                                console.log(`Mouse entered card-rank ${rank} - card is interactive`);
                            });
                            
                            // Add click test to verify card-rank is clickable
                            cardRankElement.addEventListener('click', (e) => {
                                console.log(`=== CARD-RANK CLICK TEST: Card ${rank} was clicked ===`);
                                console.log(`Event target:`, e.target);
                                console.log(`Card element:`, card);
                                console.log(`Card-rank element:`, cardRankElement);
                                console.log(`Card classes:`, card.className);
                                console.log(`Card pointer events:`, card.style.pointerEvents);
                            }, false); // Use bubble phase for testing
                        }
                        
                        // Test if the event listener was actually added
                        console.log(`Card ${rank} event listener test:`, {
                            hasOnClick: card.onclick !== null,
                            hasAddEventListener: typeof card.addEventListener === 'function',
                            eventListeners: card.getEventListeners ? card.getEventListeners() : 'not available'
                        });
                        
                        // Debug card CSS properties
                        const computedStyle = window.getComputedStyle(card);
                        const rect = card.getBoundingClientRect();
                        console.log(`Card ${rank} CSS debug:`, {
                            pointerEvents: computedStyle.pointerEvents,
                            display: computedStyle.display,
                            visibility: computedStyle.visibility,
                            opacity: computedStyle.opacity,
                            zIndex: computedStyle.zIndex,
                            position: computedStyle.position,
                            rect: {
                                top: rect.top,
                                left: rect.left,
                                width: rect.width,
                                height: rect.height,
                                visible: rect.width > 0 && rect.height > 0
                            }
                        });
                        
                        // Also check if the card is actually clickable
                        console.log(`Card ${rank} clickability test:`, {
                            hasClickHandler: card.onclick !== null,
                            hasEventListener: card.addEventListener ? 'yes' : 'no',
                            stylePointerEvents: card.style.pointerEvents,
                            computedPointerEvents: computedStyle.pointerEvents,
                            isVisible: rect.width > 0 && rect.height > 0,
                            isInViewport: rect.top >= 0 && rect.left >= 0
                        });
                    } else {
                        // Don't mark selected cards as unavailable - they should remain visible
                        // card.classList.add('unavailable');
                        // card.style.pointerEvents = 'none';
                        console.log(`Card ${rank} is already selected, keeping it visible`);
                    }
                });
                console.log('=== Human player card selection setup complete ===');
                
                // Debug: Check if click handlers are still attached after setup
                const testCards = document.querySelectorAll('.table-card');
                testCards.forEach((card, index) => {
                    const cardRankElement = card.querySelector('.card-rank');
                    if (cardRankElement) {
                        console.log(`Post-setup check - Card ${index}:`, {
                            hasClickHandler: cardRankElement._cardClickHandler !== undefined,
                            cardRankElement: cardRankElement,
                            cardRankText: cardRankElement.textContent
                        });
                    }
                });
                
                // Debug: Check if any elements are covering the cards
                const gameTable = document.querySelector('.game-table');
                if (gameTable) {
                    const allElements = gameTable.querySelectorAll('*');
                    console.log(`Found ${allElements.length} elements in game table`);
                    
                    // Check for elements with high z-index that might be covering cards
                    allElements.forEach((el, index) => {
                        const style = window.getComputedStyle(el);
                        const zIndex = parseInt(style.zIndex);
                        if (zIndex > 100) {
                            console.log(`High z-index element ${index}:`, {
                                tagName: el.tagName,
                                className: el.className,
                                id: el.id,
                                zIndex: zIndex,
                                position: style.position,
                                pointerEvents: style.pointerEvents
                            });
                        }
                    });
                    
                    // Test if any elements are covering the cards
                    const tableCards = document.querySelectorAll('.table-card');
                    tableCards.forEach((card, index) => {
                        const rect = card.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        
                        // Check what element is at the center of each card
                        const elementAtCenter = document.elementFromPoint(centerX, centerY);
                        console.log(`Card ${index} center element:`, {
                            card: card,
                            centerElement: elementAtCenter,
                            isCard: elementAtCenter === card,
                            centerElementTag: elementAtCenter ? elementAtCenter.tagName : 'none',
                            centerElementClass: elementAtCenter ? elementAtCenter.className : 'none'
                        });
                    });
                }
            }

            selectTableCard(cardElement, playerId) {
                console.log('=== selectTableCard called ===');
                console.log('PlayerId:', playerId);
                console.log('Card element:', cardElement);
                console.log('Card rank:', cardElement.dataset.rank);
                console.log('Card classes:', cardElement.className);
                console.log('Card pointer events:', cardElement.style.pointerEvents);
                
                const rank = cardElement.dataset.rank;
                console.log('Selected rank:', rank);
                
                // Check if card is already selected
                if (cardElement.classList.contains('selected')) {
                    console.log('Card already selected, ignoring click');
                    return;
                }
                
                // Check if player already has a selected card
                const player = this.stateManager.getPlayer(playerId);
                if (player && player.selectedCard) {
                    console.log('Player already has a selected card, ignoring click');
                    return;
                }
                
                // Assign a random suit when card is selected
                const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
                const suit = suits[Math.floor(Math.random() * suits.length)];
                const selectedCard = { rank, suit };
                console.log('Selected card:', selectedCard);
                
                console.log('=== About to call stateManager.selectCard ===');
                console.log('Current game state:', this.stateManager.getState());
                console.log('Player ID:', playerId);
                console.log('Selected card:', selectedCard);
                console.log('Current selected cards:', this.stateManager.getGameData().selectedCards);
                
                const selectionResult = this.stateManager.selectCard(playerId, selectedCard);
                console.log('Selection result:', selectionResult);
                
                if (selectionResult) {
                    console.log('Card selection successful for player:', playerId);
                    
                    // Clear the status text to avoid confusion
                    this.elements.gameState.textContent = 'Players selecting cards...';
                    
                    // Play card selection sound
                    this.soundManager.playSound('cardSelect');
                    
                    // Clear countdown timer if it exists
                    this.stopManualCountdown();
                    
                    // Get player name for display
                    const player = this.stateManager.getPlayer(playerId);
                    const playerName = player ? player.name : `Player ${playerId}`;
                    
                    // Mark card as selected with player name
                    cardElement.classList.add('selected');
                    cardElement.setAttribute('data-selected-by', playerName);
                    
                    // White card styling for all players
                    cardElement.style.background = 'linear-gradient(145deg, #fff, #f0f0f0)';
                    cardElement.style.border = '2px solid #333';
                    cardElement.style.color = '#333';
                    cardElement.style.fontWeight = 'bold';
                    
                    // Show player name on card
                    const originalText = cardElement.textContent;
                    cardElement.textContent = `${originalText}\n${playerName}`;
                    
                    // Update displays
                    this.updatePlayerDisplay(playerId);
                    this.updateGameDisplay();
                    
                    // Animate card to player seat for human player too
                    this.animateCardToPlayerSeat(cardElement, playerId);
                    
                    // Animate chip from player to card for human player
                    setTimeout(() => {
                        this.animateChipToCard(playerId, cardElement);
                    }, 200);
                    
                    // Remove card from table after a short delay
                    setTimeout(() => {
                        if (cardElement && cardElement.parentNode) {
                            cardElement.remove();
                            console.log(`Removed selected card from table for player ${playerId}`);
                        }
                    }, 500); // Short delay to allow visual feedback
                    
                    // Check if all cards are selected and continue game
                    console.log('=== Checking if all cards are selected ===');
                    const allSelected = this.stateManager.allCardsSelected();
                    const selectedCount = this.stateManager.getGameData().selectedCards.size;
                    const totalPlayers = GAME_CONFIG.TOTAL_PLAYERS;
                    
                    console.log(`All selected: ${allSelected}, Selected count: ${selectedCount}, Total players: ${totalPlayers}`);
                    
                    if (allSelected) {
                        console.log('=== All cards selected, moving to reveal phase ===');
                        this.stateManager.setState(GAME_STATES.REVEALING_CARDS);
                    } else {
                        console.log('=== Not all cards selected, continuing with remaining players ===');
                        console.log('Current game state before continue:', this.stateManager.getState());
                        
                        // Always continue with remaining players, regardless of player type
                        console.log('=== Continuing with remaining players ===');
                        
                        // Simple continuation - just call the function directly
                        setTimeout(() => {
                            console.log('=== Calling continueWithRemainingPlayers after timeout ===');
                            try {
                                this.continueWithRemainingPlayers();
                            } catch (error) {
                                console.error('Error in continueWithRemainingPlayers:', error);
                            }
                        }, 1000);
                    }
                } else {
                    console.log('=== Card selection failed ===');
                    console.log('Current game state:', this.stateManager.getState());
                    console.log('Expected state:', GAME_STATES.CARD_SELECTION);
                    console.log('Current selected cards:', this.stateManager.getGameData().selectedCards);
                    
                    // Check if card is already selected and show who selected it
                    const selectedBy = cardElement.getAttribute('data-selected-by');
                    if (selectedBy) {
                        alert(`This card is already selected by ${selectedBy}!`);
                    } else {
                        alert('Card already selected or invalid selection!');
                    }
                }
            }

            startManualCountdown(playerId, playerName) {
                console.log(`Starting manual countdown for ${playerName} (ID: ${playerId})`);
                
                // First, aggressively clean up any existing timers
                this.stopManualCountdown();
                console.log(`Cleaned up any existing timers before starting new one`);
                
                // Additional cleanup - ensure no timer intervals are left running
                if (this.manualTimerInterval) {
                    clearInterval(this.manualTimerInterval);
                    this.manualTimerInterval = null;
                }
                if (this.countdownTimer) {
                    clearInterval(this.countdownTimer);
                    this.countdownTimer = null;
                }
                
                // Clear any timer intervals that might be stored elsewhere
                if (window.gameTimerInterval) {
                    clearInterval(window.gameTimerInterval);
                    window.gameTimerInterval = null;
                }
                if (window.manualTimerInterval) {
                    clearInterval(window.manualTimerInterval);
                    window.manualTimerInterval = null;
                }
                
                // Nuclear option - clear ALL possible timer intervals
                // This is aggressive but necessary to prevent leftover timers
                for (let i = 1; i < 10000; i++) {
                    clearInterval(i);
                }
                console.log(`Cleared ALL timer intervals (nuclear option)`);
                
                // Add a small delay to ensure all timers are completely stopped
                setTimeout(() => {
                    this.startManualCountdownDelayed(playerId, playerName);
                }, 100);
            }
            
            startManualCountdownDelayed(playerId, playerName) {
                console.log(`Starting delayed manual countdown for ${playerName} (ID: ${playerId})`);
                
                const playerSeat = document.getElementById(`player-${playerId}`);
                if (!playerSeat) {
                    console.error(`Player seat not found for ID: ${playerId}`);
                    return;
                }

                console.log(`Player seat found:`, playerSeat);

                // Remove any existing timer element first
                const existingTimer = document.getElementById(`manual-timer-${playerId}`);
                if (existingTimer) {
                    existingTimer.remove();
                    console.log(`Removed existing timer element`);
                }

                // Create a completely new timer element with inline styles
                console.log(`Creating brand new timer element for player ${playerId}`);
                const timerElement = document.createElement('div');
                timerElement.id = `manual-timer-${playerId}`;
                
                // Apply proper timer styles inline to avoid any CSS interference
                timerElement.style.cssText = `
                    position: fixed !important;
                    top: 50% !important;
                    left: 50% !important;
                    transform: translate(-50%, -50%) !important;
                    margin-top: -80px !important;
                    width: 120px !important;
                    height: 40px !important;
                    background-color: rgba(255, 255, 255, 0.95) !important;
                    border: 2px solid #ff0000 !important;
                    font-size: 20px !important;
                    color: #ff0000 !important;
                    font-weight: bold !important;
                    display: block !important;
                    visibility: visible !important;
                    opacity: 1 !important;
                    z-index: 99999 !important;
                    text-align: center !important;
                    line-height: 40px !important;
                    border-radius: 5px !important;
                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3) !important;
                `;
                
                timerElement.textContent = '30';
                document.body.appendChild(timerElement);
                console.log(`Brand new timer element added to body with inline styles`);
                console.log(`Timer element initial text: ${timerElement.textContent}`);

                console.log(`Timer element:`, timerElement);

                // Show the timer
                timerElement.style.setProperty('display', 'block', 'important');
                timerElement.style.setProperty('visibility', 'visible', 'important');
                timerElement.style.setProperty('opacity', '1', 'important');

                console.log(`Timer styles applied - display: ${timerElement.style.display}, visibility: ${timerElement.style.visibility}, opacity: ${timerElement.style.opacity}`);
                const computedStyles = window.getComputedStyle(timerElement);
                const position = timerElement.getBoundingClientRect();
                console.log(`Timer element computed styles:`, {
                    display: computedStyles.display,
                    visibility: computedStyles.visibility,
                    opacity: computedStyles.opacity,
                    position: computedStyles.position,
                    top: computedStyles.top,
                    left: computedStyles.left,
                    zIndex: computedStyles.zIndex,
                    width: computedStyles.width,
                    height: computedStyles.height
                });
                console.log(`Timer element position:`, {
                    top: position.top,
                    left: position.left,
                    width: position.width,
                    height: position.height,
                    visible: position.width > 0 && position.height > 0
                });

                let timeLeft = 30;
                console.log(`Timer element created with inline styles, starting countdown from ${timeLeft}`);
                
                // Ensure timer element shows correct initial value
                timerElement.textContent = timeLeft;
                console.log(`Timer element text set to: ${timerElement.textContent}`);
                
                const countdown = setInterval(() => {
                    timeLeft--;
                    timerElement.textContent = timeLeft;
                    console.log(`Timer countdown: ${timeLeft} seconds remaining`);
                    
                    if (timeLeft <= 0) {
                        clearInterval(countdown);
                        console.log(`Manual countdown expired for ${playerName}`);
                        
                        // Hide timer
                        timerElement.style.setProperty('display', 'none', 'important');
                        timerElement.style.setProperty('visibility', 'hidden', 'important');
                        timerElement.style.setProperty('opacity', '0', 'important');
                        
                        // Auto-select a random card if no selection made
                        const gameData = this.stateManager.getGameData();
                        const player = gameData.players.find(p => p.id === playerId);
                        if (player && !player.selectedCard) {
                            console.log(`Auto-selecting card for ${playerName} due to timeout`);
                            this.makeRandomSelectionForPlayer(playerId, playerName);
                        }
                    }
                }, 1000);

                // Store the interval ID so we can clear it if player selects a card
                this.manualTimerInterval = countdown;
                console.log(`Timer countdown started successfully`);
                
                // Debug: Check if click handlers are still attached after timer starts
                setTimeout(() => {
                    console.log(`=== POST-TIMER-START CHECK ===`);
                    const testCards = document.querySelectorAll('.table-card');
                    testCards.forEach((card, index) => {
                        const cardRankElement = card.querySelector('.card-rank');
                        if (cardRankElement) {
                            console.log(`Post-timer check - Card ${index}:`, {
                                hasClickHandler: cardRankElement._cardClickHandler !== undefined,
                                cardRankElement: cardRankElement,
                                cardRankText: cardRankElement.textContent,
                                cardPointerEvents: card.style.pointerEvents,
                                cardRankPointerEvents: cardRankElement.style.pointerEvents
                            });
                        }
                    });
                }, 1000);
            }

            stopManualCountdown() {
                console.log(`=== stopManualCountdown called ===`);
                console.log(`Current manualTimerInterval:`, this.manualTimerInterval);
                console.log(`Current countdownTimer:`, this.countdownTimer);
                
                // Clear both timer systems
                if (this.manualTimerInterval) {
                    clearInterval(this.manualTimerInterval);
                    this.manualTimerInterval = null;
                    console.log(`Cleared manualTimerInterval`);
                }
                
                if (this.countdownTimer) {
                    clearInterval(this.countdownTimer);
                    this.countdownTimer = null;
                    console.log(`Cleared countdownTimer`);
                }
                
                // Remove all manual timer elements
                const timers = document.querySelectorAll('[id^="manual-timer-"]');
                console.log(`Found ${timers.length} timer elements to remove`);
                timers.forEach(timer => {
                    console.log(`Removing timer element:`, timer);
                    timer.remove();
                });
                
                // Also remove any timer elements that might have different IDs
                const allTimers = document.querySelectorAll('div[id*="timer"]');
                console.log(`Found ${allTimers.length} total timer elements to check`);
                allTimers.forEach(timer => {
                    if (timer.id.includes('manual-timer') || timer.id.includes('timer')) {
                        console.log(`Removing additional timer element:`, timer);
                        timer.remove();
                    }
                });
                
                // Clear all unavailable classes from table cards
                this.clearUnavailableCards();
                console.log(`=== stopManualCountdown complete ===`);
            }
            
            clearUnavailableCards() {
                const tableCards = document.querySelectorAll('.table-card');
                tableCards.forEach(card => {
                    card.classList.remove('unavailable');
                    card.style.pointerEvents = 'auto';
                    card.style.cursor = 'pointer';
                });
                console.log('Cleared unavailable classes from all table cards');
            }

            cleanupDuplicateCards() {
                console.log('=== Cleaning up duplicate cards ===');
                const gameData = this.stateManager.getGameData();
                const selectedCards = Array.from(gameData.selectedCards.values());
                const selectedRanks = selectedCards.map(card => card.rank);
                
                console.log('Selected ranks:', selectedRanks);
                
                const tableCards = document.querySelectorAll('.table-card');
                console.log(`Found ${tableCards.length} table cards to check`);
                
                tableCards.forEach(card => {
                    const rank = card.dataset.rank;
                    if (selectedRanks.includes(rank)) {
                        // Check if this card is currently being animated to (has a chip animation in progress)
                        const isBeingAnimatedTo = card.classList.contains('selected') && 
                                                 card.getAttribute('data-selected-by') && 
                                                 !card.style.display || card.style.display !== 'none';
                        
                        if (!isBeingAnimatedTo) {
                            console.log(`Removing duplicate card ${rank} from table`);
                            card.remove();
                        } else {
                            console.log(`Keeping card ${rank} - currently being animated to`);
                        }
                    }
                });
                
                console.log('=== Duplicate card cleanup complete ===');
            }

            updatePlayerDisplay(playerId) {
                const player = this.stateManager.getPlayer(playerId);
                const seat = document.getElementById(`player-${playerId}`);
                const cardElement = document.getElementById(`card-${playerId}`);
                
                if (player && seat && cardElement) {
                    seat.querySelector('.player-balance').textContent = `$${Math.round(player.balance)}`;
                    
                    // Update chip stack (now outside player seat)
                    const chipStack = document.getElementById(`chip-stack-${playerId}`);
                    if (chipStack) {
                        chipStack.innerHTML = this.generateChipStack(player.balance);
                    }
                    
                    if (player.selectedCard) {
                        // Cards are now revealed immediately when they reach player seats
                        // This function is mainly for updating balance and adding selected class
                        cardElement.style.display = 'flex';
                        // Only add selected class if no result class is present
                        if (!seat.classList.contains('win') && !seat.classList.contains('loss') && 
                            !seat.classList.contains('refund') && !seat.classList.contains('jackpot')) {
                            seat.classList.add('selected');
                        }
                        
                        // Ensure the card is actually displayed in the player's card area
                        const playerCardArea = seat.querySelector('.player-card');
                        if (playerCardArea) {
                            // Always ensure white background for selected cards
                            playerCardArea.style.background = 'linear-gradient(145deg, #fff, #f0f0f0)';
                            playerCardArea.style.border = '2px solid #333';
                            playerCardArea.style.color = '#333';
                            
                            // If the card area is empty, populate it with the selected card
                            if (!playerCardArea.innerHTML) {
                                const cardValue = this.getBetValue(player.selectedCard);
                                playerCardArea.innerHTML = `
                                    <div class="card-content">
                                        <div class="card-rank">${player.selectedCard.rank}</div>
                                        <div class="card-suit">${this.getSuitSymbol(player.selectedCard.suit)}</div>
                                        <div class="card-value">$${cardValue}</div>
                                    </div>
                                `;
                            }
                        }
                    }
                }
            }

            updateGameDisplay() {
                const gameData = this.stateManager.getGameData();
                
                // Safety checks for display values
                const jackpot = isNaN(gameData.jackpot) ? 0 : gameData.jackpot;
                const bankRake = isNaN(gameData.bankRake) ? 0 : gameData.bankRake;
                const totalBalance = this.stateManager.getTotalBalance();
                
                this.elements.jackpotAmount.textContent = `$${Math.round(jackpot)}`;
                
                // Update jackpot chip stack
                if (window.updateJackpotChipStack) {
                    window.updateJackpotChipStack(jackpot);
                }
                
                // Bank Rake is now only in admin panel, not in main view
                // this.elements.bankRake.textContent = `$${Math.round(bankRake)}`;
                
                this.elements.currentRound.textContent = `Round ${gameData.round}`;
                this.elements.adminRound.textContent = gameData.round;
                
                // Update bank history
                this.updateBankHistory();
                
                // Always update admin panel to keep values in sync
                this.updateAdminPanel();
                
                this.elements.totalBalance.textContent = `$${isNaN(totalBalance) ? '0' : Math.round(totalBalance)}`;
                
                gameData.players.forEach(player => {
                    this.updatePlayerDisplay(player.id);
                });
            }

            updateAdminPanel() {
                const gameData = this.stateManager.getGameData();
                
                // Calculate detailed balance breakdown
                const playerBalances = gameData.players.reduce((sum, player) => sum + (player.balance || 0), 0);
                const jackpot = gameData.jackpot || 0;
                const bankRake = gameData.bankRake || 0;
                const totalBalance = playerBalances + jackpot + bankRake;
                const expectedTotal = GAME_CONFIG.TOTAL_PLAYERS * GAME_CONFIG.INITIAL_BALANCE;
                
                // Update admin panel displays
                this.elements.totalBalance.textContent = `$${Math.round(totalBalance)}`;
                this.elements.expectedBalance.textContent = `$${expectedTotal}`;
                this.elements.playerBalances.textContent = `$${Math.round(playerBalances)}`;
                this.elements.adminJackpot.textContent = `$${Math.round(jackpot)}`;
                this.elements.adminBankRake.textContent = `$${Math.round(bankRake)}`;
                this.elements.adminBankRakeDisplay.textContent = `$${Math.round(bankRake)}`;
                this.elements.adminRound.textContent = gameData.round;
                
                // Color code the total balance with acceptance threshold
                const difference = totalBalance - expectedTotal;
                const percentage = Math.abs(difference) / expectedTotal * 100;
                const acceptanceThreshold = 0.2; // 0.2% acceptance threshold
                
                if (percentage > acceptanceThreshold) {
                    this.elements.totalBalance.style.color = '#ff4444'; // Red if not balanced
                } else {
                    this.elements.totalBalance.style.color = '#44ff44'; // Green if balanced
                }
                
                console.log('Admin panel updated with balance validation');
            }

            updateWaitingState() {
                this.elements.startRoundBtn.disabled = false;
                this.elements.gameState.textContent = 'Waiting for round to start';
                this.elements.gameTimer.classList.add('hidden');
            }

            updateCardSelectionState() {
                console.log('Updating card selection state...');
                this.elements.startRoundBtn.disabled = true;
                this.elements.gameState.textContent = 'Players selecting cards...';
                this.elements.gameTimer.classList.add('hidden');
                
                // Clean up any duplicate cards from previous rounds
                this.cleanupDuplicateCards();
                
                // Place cards on table for selection
                this.placeCardsOnTable();
                
                console.log('Starting bot moves...');
                this.processBotMovesWithTurnIndication();
            }

            updateRevealingCardsState() {
                console.log('Updating revealing cards state...');
                this.elements.gameState.textContent = 'Cards revealed - drawing bank card...';
                
                // Only reveal cards if we haven't already done so
                if (!this.cardsRevealed) {
                    this.cardsRevealed = true;
                // Update all player cards to show rank and suit
                this.revealAllPlayerCards();
                
                    // Don't create chip pile yet - wait for all chips to animate first
                } else {
                    console.log('Cards already revealed, skipping...');
                }
                
                // Only proceed to bank draw if we haven't already done so
                if (!this.bankDrawProcessed) {
                    this.bankDrawProcessed = true;
                    
                    // Automatically proceed to bank draw after a 2 second delay
                setTimeout(() => {
                    console.log('Automatically proceeding to bank draw...');
                        // Play bank draw sound
                        this.soundManager.playSound('bankDraw');
                        // Process bank draw first
                        const bankCard = this.gameLogic.processBankDraw();
                        // Set bank card in state for animation
                        this.stateManager.setBankCard(bankCard);
                        // Animate bank card reveal
                        this.animateBankDraw();
                        // Then move to distribute winnings state
                    this.stateManager.setState(GAME_STATES.DISTRIBUTE_WINNINGS);
                    }, 2000);
                }
            }

            updateBankDrawState() {
                this.elements.gameState.textContent = 'Bank drawing card...';
                this.animateBankDraw();
            }

            updateDistributeWinningsState() {
                this.elements.gameState.textContent = 'Distributing winnings...';
                this.animateWinningsDistribution();
                
                // Validate balance after winnings distribution
                setTimeout(() => {
                    this.gameLogic.validateGameState();
                }, 500);
                
                // Animate chips back to players after a delay
                setTimeout(() => {
                    this.animateChipsBackToPlayers();
                }, 1000);
            }

            updateRoundSummaryState() {
                this.elements.gameState.textContent = 'Round complete - click to start new round';
                this.elements.startRoundBtn.disabled = false;
                this.elements.startRoundBtn.textContent = 'Start New Round';
                
                // Auto-start next round if enabled and not paused
                if (GAME_CONFIG.AUTO_START_NEXT_ROUND && !this.stateManager.isGamePaused()) {
                    console.log(`Auto-starting next round in ${GAME_CONFIG.ROUND_DELAY}ms...`);
                    setTimeout(() => {
                        if (!this.stateManager.isGamePaused()) {
                            console.log('Auto-starting new round...');
                            this.startNewRound();
                        } else {
                            console.log('Game is paused, skipping auto-start');
                        }
                    }, GAME_CONFIG.ROUND_DELAY);
                }
            }

            async processBotMoves() {
                const gameData = this.stateManager.getGameData();
                const bots = gameData.players.filter(p => p.isBot && !p.selectedCard);
                
                console.log(`Processing moves for ${bots.length} bots...`);
                
                for (const bot of bots) {
                    await this.botController.makeBotMove(bot.id);
                    this.updatePlayerDisplay(bot.id);
                    
                    // Update table card display for bot selection will be handled by UIController
                    
                    console.log(`${bot.name} selected card: ${bot.selectedCard?.rank}`);
                    
                    if (bot.id < bots[bots.length - 1].id) {
                        await this.delay(GAME_CONFIG.BOT_DELAY);
                    }
                }
                
                // Check if all cards are selected after bot moves
                if (this.stateManager.allCardsSelected()) {
                    console.log('All cards selected after bot moves, moving to reveal phase...');
                    this.stateManager.setState(GAME_STATES.REVEALING_CARDS);
                }
            }

            async processBotMovesWithTurnIndication() {
                const gameData = this.stateManager.getGameData();
                const turnOrder = this.gameLogic.getTurnOrder();
                const playersToMove = turnOrder.filter(p => !p.selectedCard);
                
                console.log(`Processing moves for ${playersToMove.length} players with turn indication...`);
                console.log('Turn order:', playersToMove.map(p => ({ id: p.id, name: p.name, isHuman: p.isHuman })));
                
                for (const player of playersToMove) {
                    console.log(`=== Processing player: ${player.name} (ID: ${player.id}, isHuman: ${player.isHuman}) ===`);
                    // Show whose turn it is
                    this.showCurrentTurn(player.id);
                    
                    if (player.isHuman) {
                        console.log(`=== Human player turn - checking strategy ===`);
                        console.log(`Current game state: ${this.stateManager.getState()}`);
                        console.log(`Player details: ${JSON.stringify(player)}`);
                        console.log(`Player strategy: ${player.strategy}`);
                        
                        // Re-check player strategy in case it was changed during the game
                        const currentPlayer = this.stateManager.getPlayer(player.id);
                        const currentStrategy = currentPlayer ? currentPlayer.strategy : player.strategy;
                        console.log(`Current strategy after re-check: ${currentStrategy}`);
                        
                        // Check if human player strategy is manual
                        if (currentStrategy === 'manual') {
                            console.log(`=== Human player strategy is manual - enabling card selection ===`);
                            console.log(`Available cards: ${this.stateManager.getAvailableCards()}`);
                            console.log(`Selected cards: ${Array.from(this.stateManager.getGameData().selectedCards.entries())}`);
                            
                            // Clean up any existing admin selection interface
                            this.cleanupAdminSelection();
                            console.log('=== Cleaned up admin selection interface ===');
                            
                            // Human player - enable card selection with countdown
                            this.elements.gameState.textContent = `${player.name}'s turn - click a card to select`;
                            
                            // Add a small delay to ensure DOM is ready
                            setTimeout(() => {
                                this.showCardSelectionModal(player.id);
                                this.startManualCountdown(player.id, player.name);
                                console.log(`=== Human player card selection enabled, waiting for input ===`);
                            }, 100);
                            
                            // Don't auto-proceed, wait for human input
                            return;
                        } else {
                            console.log(`=== Human player strategy is ${currentStrategy} - making automatic move ===`);
                            // Human player with non-manual strategy - make automatic move
                            await this.delay(1000); // Show turn indication for 1 second
                            await this.botController.makeBotMove(player.id);
                            this.updatePlayerDisplay(player.id);
                            
                            // Update table card display for human selection
                            if (player.selectedCard) {
                                console.log(`Updating table card display for ${player.name} (ID: ${player.id}) with card ${player.selectedCard.rank}`);
                                this.updateTableCardDisplay(player.selectedCard.rank, player.name);
                            }
                            
                            console.log(`${player.name} selected card: ${player.selectedCard?.rank}`);
                            
                            // Clear turn indication after a short delay to show the result
                            await this.delay(500);
                            this.clearCurrentTurn();
                        }
                    } else {
                        // Bot player - make move after delay
                        await this.delay(1000); // Show turn indication for 1 second
                        await this.botController.makeBotMove(player.id);
                        this.updatePlayerDisplay(player.id);
                        
                        // Update table card display for bot selection
                        if (player.selectedCard) {
                            console.log(`Updating table card display for ${player.name} (ID: ${player.id}) with card ${player.selectedCard.rank}`);
                            this.updateTableCardDisplay(player.selectedCard.rank, player.name);
                        }
                        
                        console.log(`${player.name} selected card: ${player.selectedCard?.rank}`);
                        
                        // Clear turn indication after a short delay to show the result
                        await this.delay(500);
                        this.clearCurrentTurn();
                        
                        if (player.id < playersToMove[playersToMove.length - 1].id) {
                            await this.delay(GAME_CONFIG.BOT_DELAY);
                        }
                    }
                }
                
                // Check if all cards are selected after all moves
                const allSelected = this.stateManager.allCardsSelected();
                console.log('All cards selected check:', allSelected, 'Selected cards count:', this.stateManager.getGameData().selectedCards.size);
                if (allSelected) {
                    console.log('All cards selected, moving to reveal phase...');
                    this.stateManager.setState(GAME_STATES.REVEALING_CARDS);
                }
            }

            async continueWithRemainingPlayers() {
                console.log('=== continueWithRemainingPlayers called ===');
                console.log('Current game state:', this.stateManager.getState());
                const gameData = this.stateManager.getGameData();
                const playersToMove = gameData.players.filter(p => !p.selectedCard);
                
                console.log(`Continuing with ${playersToMove.length} remaining players...`);
                console.log('Players to move:', playersToMove.map(p => ({ id: p.id, name: p.name, isHuman: p.isHuman, selectedCard: p.selectedCard })));
                console.log('All players:', gameData.players.map(p => ({ id: p.id, name: p.name, selectedCard: p.selectedCard })));
                
                if (playersToMove.length === 0) {
                    console.log('No players to move, all cards selected!');
                    this.stateManager.setState(GAME_STATES.REVEALING_CARDS);
                    return;
                }
                
                // Process each remaining player
                for (const player of playersToMove) {
                    console.log(`Processing player: ${player.name} (ID: ${player.id})`);
                    
                    if (player.isHuman) {
                        console.log(`=== Human player turn in continueWithRemainingPlayers - checking strategy ===`);
                        console.log(`Player strategy: ${player.strategy}`);
                        
                        // Check if human player strategy is manual
                        if (player.strategy === 'manual') {
                            console.log('Human player strategy is manual - enabling card selection');
                            
                            // Clean up any existing admin selection interface
                            this.cleanupAdminSelection();
                            console.log('=== Cleaned up admin selection interface in continueWithRemainingPlayers ===');
                            
                            this.elements.gameState.textContent = `${player.name}'s turn - click a card to select`;
                            this.showCardSelectionModal(player.id);
                            this.startManualCountdown(player.id, player.name);
                            break; // Stop here for human player
                        } else {
                            console.log(`Human player strategy is ${player.strategy} - making automatic move in continueWithRemainingPlayers`);
                            // Human player with non-manual strategy - make automatic move
                            this.showCurrentTurn(player.id);
                            await this.delay(1000);
                            
                            // Make human move
                            const success = await this.botController.makeBotMove(player.id);
                            if (success) {
                                this.updatePlayerDisplay(player.id);
                                
                                // Update table card display for human selection
                                if (player.selectedCard) {
                                    console.log(`Updating table card display for ${player.name} (ID: ${player.id}) with card ${player.selectedCard.rank}`);
                                    this.updateTableCardDisplay(player.selectedCard.rank, player.name);
                                }
                                
                                console.log(`${player.name} selected card: ${player.selectedCard?.rank}`);
                            }
                            
                            // Clear turn indication after a short delay to show the result
                            await this.delay(500);
                            this.clearCurrentTurn();
                        }
                    } else {
                        console.log('Bot player turn - making move');
                        this.showCurrentTurn(player.id);
                        await this.delay(1000);
                        
                        // Make bot move
                        const success = await this.botController.makeBotMove(player.id);
                        if (success) {
                            this.updatePlayerDisplay(player.id);
                            
                            // Update table card display for bot selection
                            if (player.selectedCard) {
                                console.log(`Updating table card display for ${player.name} (ID: ${player.id}) with card ${player.selectedCard.rank}`);
                                this.updateTableCardDisplay(player.selectedCard.rank, player.name);
                            }
                            
                            console.log(`${player.name} selected card: ${player.selectedCard?.rank}`);
                        }
                        
                        await this.delay(500);
                        this.clearCurrentTurn();
                    }
                }
                
                // Check if all cards are selected after processing
                if (this.stateManager.allCardsSelected()) {
                    console.log('All cards selected, moving to reveal phase...');
                    this.stateManager.setState(GAME_STATES.REVEALING_CARDS);
                }
            }

            animateBankDraw() {
                console.log('Animating bank draw...');
                
                // Get the bank card first
                const bankCard = this.stateManager.getBankCard();
                if (bankCard) {
                    console.log('🏦 Bank card revealed:', bankCard);
                    
                    // Calculate bank card value
                    const bankCardValue = this.getBetValue(bankCard);
                    
                    // Update the content immediately with the correct card (vertically stacked)
                    this.elements.bankCard.innerHTML = `
                        <div class="card-content" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%;">
                            <div class="card-rank">${bankCard.rank}</div>
                            <div class="card-suit">${this.getSuitSymbol(bankCard.suit)}</div>
                            <div class="card-value">$${bankCardValue}</div>
                        </div>
                    `;
                    
                    // Then add the revealed class for animation
                    setTimeout(() => {
                        this.elements.bankCard.classList.add('revealed');
                        console.log('🎴 Bank card animation complete');
                    }, 100);
                } else {
                    console.error('❌ No bank card found!');
                }
            }

            animateWinningsDistribution() {
                console.log('Animating winnings distribution...');
                const gameData = this.stateManager.getGameData();
                
                console.log('Player results:', gameData.players.map(p => ({ name: p.name, result: p.result })));
                
                // Add delay before showing results to let players see the bank card
                setTimeout(() => {
                    gameData.players.forEach(player => {
                        const seat = document.getElementById(`player-${player.id}`);
                        if (seat && player.result) {
                            console.log(`Setting result for ${player.name}: ${player.result}`);
                            
                            // Remove selected class to prevent conflict with result colors
                            seat.classList.remove('selected');
                            seat.classList.add(player.result);
                            
                            const resultText = document.createElement('div');
                            resultText.className = 'result-text';
                            resultText.textContent = this.getResultText(player.result, player);
                            seat.appendChild(resultText);
                            
                            // Play appropriate sound based on result (only for human player)
                            if (player.id === 0) { // Human player
                                if (player.result === RESULT_TYPES.WIN) {
                                    this.soundManager.playSound('win');
                                } else if (player.result === RESULT_TYPES.LOSS) {
                                    this.soundManager.playSound('loss');
                                } else if (player.result === RESULT_TYPES.REFUND) {
                                    this.soundManager.playSound('refund');
                                } else if (player.result === RESULT_TYPES.JACKPOT) {
                                    this.soundManager.playSound('jackpot');
                                    // Create jackpot animation
                                    this.createJackpotAnimation(player.id);
                                }
                            }
                        }
                    });
                    
                    setTimeout(() => {
                        this.updateGameDisplay();
                        this.stateManager.setState(GAME_STATES.ROUND_SUMMARY);
                    }, 2000);
                }, 1000); // 1 second delay before showing results
            }

            getResultText(result, player) {
                const betValue = player.selectedCard ? this.getBetValue(player.selectedCard) : 0;
                
                switch (result) {
                    case RESULT_TYPES.WIN: 
                        // Use the stored actual winnings (bet back + winnings from losing player)
                        const actualWinnings = player.actualWinnings || betValue;
                        return `WIN! +$${Math.round(actualWinnings)}`;
                    case RESULT_TYPES.LOSS: 
                        return `LOSS -$${Math.round(betValue)}`;
                    case RESULT_TYPES.REFUND: 
                        // Calculate actual refund amount (bet minus jackpot contribution)
                        const jackpotContribution = betValue * GAME_CONFIG.JACKPOT_RATE;
                        const actualRefund = betValue - jackpotContribution;
                        return `REFUND +$${Math.round(actualRefund)}`;
                    case RESULT_TYPES.JACKPOT: 
                        return `JACKPOT! +$${Math.round(betValue)}`;
                    default: return '';
                }
            }

            getSuitSymbol(suit) {
                const symbols = {
                    hearts: '<span style="color: red;">♥</span>',
                    diamonds: '<span style="color: red;">♦</span>',
                    clubs: '<span style="color: black;">♣</span>',
                    spades: '<span style="color: black;">♠</span>'
                };
                return symbols[suit] || '?';
            }
            
            createJackpotAnimation(playerId) {
                console.log(`Creating jackpot animation for player ${playerId}`);
                const playerSeat = document.getElementById(`player-${playerId}`);
                if (!playerSeat) {
                    console.error(`Player seat not found for ID: ${playerId}`);
                    return;
                }
                
                const seatRect = playerSeat.getBoundingClientRect();
                const centerX = seatRect.left + seatRect.width / 2;
                const centerY = seatRect.top + seatRect.height / 2;
                
                // Create stars
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        const star = document.createElement('div');
                        star.className = 'jackpot-star';
                        star.textContent = '★';
                        star.style.left = centerX + 'px';
                        star.style.top = centerY + 'px';
                        
                        // Random position around the player
                        const angle = (i / 8) * Math.PI * 2;
                        const distance = 50 + Math.random() * 30;
                        const x = centerX + Math.cos(angle) * distance;
                        const y = centerY + Math.sin(angle) * distance;
                        
                        star.style.left = x + 'px';
                        star.style.top = y + 'px';
                        
                        document.body.appendChild(star);
                        
                        // Remove after animation
                        setTimeout(() => {
                            if (star.parentNode) {
                                star.parentNode.removeChild(star);
                            }
                        }, 2000);
                    }, i * 100);
                }
                
                // Create gold coins
                for (let i = 0; i < 6; i++) {
                    setTimeout(() => {
                        const gold = document.createElement('div');
                        gold.className = 'jackpot-gold';
                        gold.textContent = '💰';
                        gold.style.left = centerX + 'px';
                        gold.style.top = centerY + 'px';
                        
                        // Random position around the player
                        const angle = (i / 6) * Math.PI * 2 + Math.PI / 6;
                        const distance = 40 + Math.random() * 25;
                        const x = centerX + Math.cos(angle) * distance;
                        const y = centerY + Math.sin(angle) * distance;
                        
                        gold.style.left = x + 'px';
                        gold.style.top = y + 'px';
                        
                        document.body.appendChild(gold);
                        
                        // Remove after animation
                        setTimeout(() => {
                            if (gold.parentNode) {
                                gold.parentNode.removeChild(gold);
                            }
                        }, 2000);
                    }, i * 150);
                }
            }

            getBetValue(card) {
                return CARD_VALUES[card.rank] || 0;
            }
            
            updateBankHistory() {
                const gameData = this.stateManager.getGameData();
                const bankHistory = gameData.bankHistory || [];
                
                // Clear existing history
                this.elements.bankHistoryList.innerHTML = '';
                
                // Show last 5 bank cards
                const recentHistory = bankHistory.slice(-5);
                
                if (recentHistory.length === 0) {
                    this.elements.bankHistoryList.innerHTML = '<span style="opacity: 0.7;">No history yet</span>';
                    return;
                }
                
                recentHistory.forEach(card => {
                    const cardItem = document.createElement('div');
                    cardItem.className = 'bank-card-item';
                    
                    // Get simple suit symbols
                    const suitSymbols = {
                        'hearts': '♥',
                        'diamonds': '♦', 
                        'clubs': '♣',
                        'spades': '♠'
                    };
                    
                    cardItem.textContent = `${card.rank}${suitSymbols[card.suit] || card.suit}`;
                    this.elements.bankHistoryList.appendChild(cardItem);
                });
            }

            generateChipStack(balance) {
                const chips = [];
                let remainingBalance = balance;
                
                // Generate different colored chips based on balance
                const chipValues = [100, 50, 25, 10, 5, 1];
                const chipColors = ['#ff0000', '#0000ff', '#00ff00', '#ffff00', '#ff00ff', '#00ffff'];
                
                chipValues.forEach((value, index) => {
                    const count = Math.floor(remainingBalance / value);
                    if (count > 0) {
                        for (let i = 0; i < Math.min(count, 3); i++) { // Max 3 chips per value for 3 columns
                            chips.push(`<div class="chip" style="background: ${chipColors[index]}; border-color: ${chipColors[index]};"></div>`);
                        }
                        remainingBalance -= count * value;
                    }
                });
                
                // If still have balance, add small chips
                if (remainingBalance > 0) {
                    for (let i = 0; i < Math.min(remainingBalance, 3); i++) {
                        chips.push(`<div class="chip" style="background: #888; border-color: #888;"></div>`);
                    }
                }
                
                // Fill empty slots to maintain 3-column grid
                while (chips.length < 9) {
                    chips.push(`<div class="chip" style="background: transparent; border-color: transparent;"></div>`);
                }
                
                return chips.join('');
            }

            animateChipToCard(playerId, cardElement) {
                console.log(`Animating chip from player ${playerId} to chip pile`);
                
                const player = this.stateManager.getPlayer(playerId);
                if (!player || !player.selectedCard) return;
                
                const betValue = this.getBetValue(player.selectedCard);
                const chipStack = document.getElementById(`chip-stack-${playerId}`);
                if (!chipStack) {
                    console.error(`Chip stack not found for player ${playerId}`);
                    return;
                }
                
                // Get chip stack position
                const stackRect = chipStack.getBoundingClientRect();
                console.log(`Chip stack position: (${stackRect.left}, ${stackRect.top})`);
                
                // Validate position
                if (stackRect.left < 0 || stackRect.top < 0) {
                    console.error('Invalid chip stack position, skipping chip animation');
                    return;
                }
                
                // Create animated chip
                const animatedChip = document.createElement('div');
                animatedChip.className = 'animated-chip';
                animatedChip.style.position = 'fixed';
                animatedChip.style.left = `${stackRect.left}px`;
                animatedChip.style.top = `${stackRect.top}px`;
                animatedChip.style.width = '20px';
                animatedChip.style.height = '16px';
                animatedChip.style.borderRadius = '50%';
                animatedChip.style.background = this.getChipColor(betValue);
                animatedChip.style.border = `3px solid ${this.getChipColor(betValue)}`;
                animatedChip.style.zIndex = '1000';
                animatedChip.style.transition = 'all 0.8s ease-out';
                animatedChip.style.boxShadow = '0 3px 6px rgba(0,0,0,0.4)';
                
                document.body.appendChild(animatedChip);
                
                // Animate directly to chip pile area
                setTimeout(() => {
                    const gameTable = document.querySelector('.game-table');
                    if (gameTable) {
                        const tableRect = gameTable.getBoundingClientRect();
                        const targetX = tableRect.left + tableRect.width/2 + 40; // 40px to the right of center
                        const targetY = tableRect.top + tableRect.height/2 - 4; // Center vertically
                        
                        console.log(`Animating chip to pile position: (${targetX}, ${targetY})`);
                        animatedChip.style.left = `${targetX}px`;
                        animatedChip.style.top = `${targetY}px`;
                    } else {
                        console.error('Game table not found for chip animation');
                        animatedChip.remove();
                    }
                }, 100);
                
                // Make the chip permanent and part of the pile
                setTimeout(() => {
                    const gameTable = document.querySelector('.game-table');
                    if (gameTable) {
                        animatedChip.style.position = 'absolute';
                        animatedChip.style.pointerEvents = 'none';
                        animatedChip.style.transition = 'none';
                        
                        const tableRect = gameTable.getBoundingClientRect();
                        const currentRect = animatedChip.getBoundingClientRect();
                        
                        // Calculate offset for this specific chip to create a vertical stack
                        const existingChips = gameTable.querySelectorAll('.animated-chip');
                        const chipIndex = existingChips.length;
                        const offsetX = 0; // No horizontal offset for vertical stack
                        const offsetY = chipIndex * 6; // 6px vertical offset per chip for better visibility with larger chips
                        
                        animatedChip.style.left = `${currentRect.left - tableRect.left + offsetX}px`;
                        animatedChip.style.top = `${currentRect.top - tableRect.top + offsetY}px`;
                        animatedChip.style.zIndex = `${100 + chipIndex}`; // Higher z-index for newer chips
                        
                        console.log(`Making chip permanent at position: (${currentRect.left - tableRect.left + offsetX}, ${currentRect.top - tableRect.top + offsetY})`);
                        
                        // Remove from body and add to game table
                        if (animatedChip.parentNode === document.body) {
                            document.body.removeChild(animatedChip);
                        }
                        gameTable.appendChild(animatedChip);
                    } else {
                        console.error('Game table not found for final chip placement');
                        animatedChip.remove();
                    }
                }, 1000);
            }

            getChipColor(value) {
                if (value >= 100) return '#ff0000';
                if (value >= 50) return '#0000ff';
                if (value >= 25) return '#00ff00';
                if (value >= 10) return '#ffff00';
                if (value >= 5) return '#ff00ff';
                return '#00ffff';
            }

            animateChipsBackToPlayers() {
                console.log('Animating chips back to players based on results');
                
                const gameData = this.stateManager.getGameData();
                const gameTable = document.querySelector('.game-table');
                if (!gameTable) return;
                
                const animatedChips = gameTable.querySelectorAll('.animated-chip');
                console.log(`Found ${animatedChips.length} chips to animate back`);
                
                animatedChips.forEach((chip, index) => {
                    // Find which player this chip belongs to (based on order)
                    const player = gameData.players[index];
                    if (!player) return;
                    
                    const playerSeat = document.getElementById(`player-${player.id}`);
                    if (!playerSeat) return;
                    
                    const seatRect = playerSeat.getBoundingClientRect();
                    const tableRect = gameTable.getBoundingClientRect();
                    
                    // Calculate target position (player's chip stack area)
                    const targetX = seatRect.left - tableRect.left + 130; // 130px to the right of player seat
                    const targetY = seatRect.top - tableRect.top + 20; // 20px down from top of seat
                    
                    // Update chip color based on result
                    if (player.result === 'win') {
                        // Keep colorful chips for winners
                        console.log(`${player.name} won - keeping colorful chip`);
                    } else if (player.result === 'refund') {
                        // Make chips gray for refunds
                        chip.style.background = '#888';
                        chip.style.borderColor = '#888';
                        console.log(`${player.name} got refund - making chip gray`);
                    } else if (player.result === 'loss') {
                        // Losers don't get chips back - fade out
                        chip.style.opacity = '0';
                        chip.style.transform = 'scale(0)';
                        console.log(`${player.name} lost - removing chip`);
                        return; // Don't animate back
                    }
                    
                    // Animate chip back to player
                    setTimeout(() => {
                        chip.style.left = `${targetX}px`;
                        chip.style.top = `${targetY}px`;
                        chip.style.transition = 'all 1.0s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    }, index * 200); // Stagger animations by 200ms per chip
                    
                    // Remove chip after animation
                    setTimeout(() => {
                        if (chip.parentNode) {
                            chip.remove();
                        }
                    }, 1000 + (index * 200));
                });
            }

            startNewRound() {
                console.log('Start new round clicked');
                if (this.stateManager.startNewRound()) {
                    // Play round start sound
                    this.soundManager.playSound('roundStart');
                    
                    // Reset flags
                    this.bankDrawProcessed = false;
                    this.cardsRevealed = false;
                    // Don't recreate player seats - just update them to preserve dropdown values
                    this.updatePlayerSeats();
                    this.updateGameDisplay();
                    this.resetBankCardDisplay();
                    this.clearPlayerResultClasses();
                    this.clearCardSelectedClasses();
                    this.placeCardsOnTable();
                    
                    // Remove animated chips from previous round
                    const animatedChips = document.querySelectorAll('.animated-chip');
                    animatedChips.forEach(chip => chip.remove());
                    
                    console.log('New round started successfully');
                } else {
                    console.log('Failed to start new round');
                }
            }

            placeCardsOnTable() {
                // Remove existing cards
                const existingCards = document.querySelectorAll('.table-card');
                existingCards.forEach(card => card.remove());
                
                // Create cards on table
                const cardRanks = ['A', '2', '3', '4', '5', '6', '7', '8', '9'];
                // Position the card selection ring slightly up and to the left of the bank card
                const centerX = 435; // Move left from bank card center (half the previous offset)
                const centerY = 335; // Move up from bank card center (half the previous offset)
                const radius = 140; // Slightly bigger radius for better spacing
                
                cardRanks.forEach((rank, index) => {
                    const card = document.createElement('div');
                    card.className = 'table-card';
                    card.dataset.rank = rank;
                    
                    // Calculate card value (bet amount)
                    const cardValue = this.getBetValue({ rank: rank, suit: 'spades' });
                    
                    // Create card content with rank and value (vertically stacked)
                    card.innerHTML = `
                        <div class="card-content">
                            <div class="card-rank">${rank}</div>
                            <div class="card-value">$${cardValue}</div>
                        </div>
                    `;
                    
                    // Position cards in a circle around the bank card
                    const angle = (index * 2 * Math.PI) / cardRanks.length;
                    const x = centerX + radius * Math.cos(angle) - 20; // -20 to center the smaller card
                    const y = centerY + radius * Math.sin(angle) - 30; // -30 to center the smaller card
                    
                    card.style.left = `${x}px`;
                    card.style.top = `${y}px`;
                    
                    // Add to the game table container, not the general game container
                    const gameTable = document.querySelector('.game-table');
                    if (gameTable) {
                        gameTable.appendChild(card);
                    } else {
                        this.elements.gameContainer.appendChild(card);
                    }
                });
            }


            toggleAdminPanel() {
                this.elements.adminPanel.classList.toggle('hidden');
                if (!this.elements.adminPanel.classList.contains('hidden')) {
                    this.updateAdminPanel();
                }
            }
            
            makeAdminPanelDraggable() {
                const panel = this.elements.adminPanel;
                const header = panel.querySelector('.admin-header');
                let isDragging = false;
                let currentX;
                let currentY;
                let initialX;
                let initialY;
                let xOffset = 0;
                let yOffset = 0;
                
                header.addEventListener('mousedown', dragStart);
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', dragEnd);
                
                function dragStart(e) {
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                    
                    if (e.target === header || header.contains(e.target)) {
                        isDragging = true;
                    }
                }
                
                function drag(e) {
                    if (isDragging) {
                        e.preventDefault();
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                        
                        xOffset = currentX;
                        yOffset = currentY;
                        
                        panel.style.transform = `translate(${currentX}px, ${currentY}px)`;
                    }
                }
                
                function dragEnd(e) {
                    initialX = currentX;
                    initialY = currentY;
                    isDragging = false;
                }
            }

            showRules() {
                const rulesModal = document.getElementById('rules-modal');
                if (rulesModal) {
                    rulesModal.classList.remove('hidden');
                    console.log('Rules modal opened');
                }
            }

            hideRules() {
                const rulesModal = document.getElementById('rules-modal');
                if (rulesModal) {
                    rulesModal.classList.add('hidden');
                    console.log('Rules modal closed');
                }
            }

            showMatrix() {
                const matrixModal = document.getElementById('matrix-modal');
                if (matrixModal) {
                    matrixModal.classList.remove('hidden');
                    // Regenerate matrix with current settings
                    generateDynamicMatrix();
                    console.log('Matrix modal opened');
                }
            }

            hideMatrix() {
                const matrixModal = document.getElementById('matrix-modal');
                if (matrixModal) {
                    matrixModal.classList.add('hidden');
                    console.log('Matrix modal closed');
                }
            }

            resetBankCardDisplay() {
                console.log('Resetting bank card display to card back...');
                this.elements.bankCard.classList.remove('revealed');
                this.elements.bankCard.innerHTML = '<div class="card-back">🏦</div>';
            }

            clearPlayerResultClasses() {
                console.log('Clearing player result classes...');
                const gameData = this.stateManager.getGameData();
                gameData.players.forEach(player => {
                    const seat = document.getElementById(`player-${player.id}`);
                    if (seat) {
                        // Remove all result-related classes but keep card-selected for card visibility
                        seat.classList.remove('win', 'loss', 'refund', 'jackpot', 'selected', 'current-turn');
                        
                        // Remove ALL result text elements (not just the first one)
                        const resultTexts = seat.querySelectorAll('.result-text');
                        resultTexts.forEach(resultText => {
                            resultText.remove();
                        });
                        
                        console.log(`Cleared result classes for ${player.name}`);
                    }
                });
            }
            
            clearCardSelectedClasses() {
                console.log('Clearing card-selected classes for new round...');
                const gameData = this.stateManager.getGameData();
                gameData.players.forEach(player => {
                    const seat = document.getElementById(`player-${player.id}`);
                    if (seat) {
                        // Remove card-selected class and clear card area for new round
                        seat.classList.remove('card-selected');
                        
                        // Clear the player's card area
                        const playerCardArea = seat.querySelector('.player-card');
                        if (playerCardArea) {
                            playerCardArea.innerHTML = '';
                            playerCardArea.style.background = '';
                            playerCardArea.style.border = '';
                            playerCardArea.style.color = '';
                        }
                        
                        console.log(`Cleared card-selected class for ${player.name}`);
                    }
                });
            }

            revealAllPlayerCards() {
                console.log('All cards are already revealed when they reach player seats - no need to reveal again');
                // Cards are now revealed immediately when they reach player seats
                // This function is kept for compatibility but does nothing
            }

            showCurrentTurn(playerId) {
                console.log(`=== showCurrentTurn called for player ${playerId} ===`);
                const seat = document.getElementById(`player-${playerId}`);
                if (seat) {
                    console.log(`Adding current-turn class to player ${playerId}`);
                    seat.classList.add('current-turn');
                    console.log(`Player ${playerId} seat classes:`, seat.className);
                    console.log(`Player ${playerId} seat element:`, seat);
                    
                    // Force a style update
                    seat.style.border = '3px solid #007bff';
                    seat.style.boxShadow = '0 0 15px #007bff';
                    console.log(`Applied forced blue border to player ${playerId}`);
                } else {
                    console.error(`Player seat not found for ID: ${playerId}`);
                }
            }

            clearCurrentTurn() {
                console.log('Clearing turn indication');
                const gameData = this.stateManager.getGameData();
                gameData.players.forEach(player => {
                    const seat = document.getElementById(`player-${player.id}`);
                    if (seat) {
                        seat.classList.remove('current-turn');
                        // Remove forced styles
                        seat.style.border = '';
                        seat.style.boxShadow = '';
                        console.log(`Cleared turn indication for player ${player.id}`);
                    }
                });
            }

            continueWithNextPlayer() {
                // Continue with the remaining players
                this.continueWithRemainingPlayers();
            }

            updateTableCardDisplay(rank, playerName) {
                console.log(`updateTableCardDisplay called with rank: ${rank}, playerName: ${playerName}`);
                
                // Clear countdown timer if it exists (for bot players in manual mode)
                this.stopManualCountdown();
                
                // Find the table card with this rank
                const tableCards = document.querySelectorAll('.table-card');
                console.log(`Found ${tableCards.length} table cards`);
                
                let selectedCard = null;
                tableCards.forEach(card => {
                    if (card.dataset.rank === rank) {
                        console.log(`Updating card ${rank} with player name: ${playerName}`);
                        card.classList.add('selected');
                        card.setAttribute('data-selected-by', playerName);
                        
                        // White card styling for all players
                        card.style.background = 'linear-gradient(145deg, #fff, #f0f0f0)';
                        card.style.border = '2px solid #333';
                        card.style.color = '#333';
                        card.style.fontWeight = 'bold';
                        
                        // Show player name on card only for human players
                        if (playerName === 'You') {
                            const originalText = card.textContent;
                            card.textContent = `${originalText}\n${playerName}`;
                        }
                        
                        selectedCard = card;
                        
                        // Animate chip from player to card
                        setTimeout(() => {
                            const gameData = this.stateManager.getGameData();
                            const player = gameData.players.find(p => p.name === playerName);
                            if (player) {
                                this.animateChipToCard(player.id, card);
                            }
                        }, 200);
                    }
                });
                
                // Add card-selected class to player seat
                const gameData = this.stateManager.getGameData();
                const player = gameData.players.find(p => p.name === playerName);
                if (player) {
                    const playerSeat = document.getElementById(`player-${player.id}`);
                    if (playerSeat) {
                        playerSeat.classList.add('card-selected');
                        console.log(`Added card-selected class to player ${playerName} (ID: ${player.id})`);
                        
                        // Animate card to player seat
                        if (selectedCard) {
                            this.animateCardToPlayerSeat(selectedCard, player.id);
                        }
                    }
                }
            }

            animateCardToPlayerSeat(cardElement, playerId) {
                console.log(`=== animateCardToPlayerSeat called for player ${playerId} ===`);
                
                // Play card drag sound
                console.log('Playing card drag sound...');
                this.soundManager.playSound('cardDrag');
                
                const playerSeat = document.getElementById(`player-${playerId}`);
                if (!playerSeat) {
                    console.error(`Player seat not found for ID: ${playerId}`);
                    return;
                }
                
                // Find the player's card area (the white area where cards are displayed)
                const playerCardArea = playerSeat.querySelector('.player-card');
                if (!playerCardArea) {
                    console.error(`Player card area not found for player ${playerId}`);
                    return;
                }
                
                // Get positions relative to viewport
                const cardRect = cardElement.getBoundingClientRect();
                const cardAreaRect = playerCardArea.getBoundingClientRect();
                
                console.log(`Card position: (${cardRect.left}, ${cardRect.top})`);
                console.log(`Target position: (${cardAreaRect.left}, ${cardAreaRect.top})`);
                
                // Create a copy for animation
                const animatedCard = cardElement.cloneNode(true);
                
                // Set up the animated card with fixed positioning
                animatedCard.style.position = 'fixed';
                animatedCard.style.left = `${cardRect.left}px`;
                animatedCard.style.top = `${cardRect.top}px`;
                animatedCard.style.width = `${cardRect.width}px`;
                animatedCard.style.height = `${cardRect.height}px`;
                animatedCard.style.zIndex = '1000';
                animatedCard.style.pointerEvents = 'none';
                animatedCard.style.transition = 'all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                
                // Add to body to ensure proper positioning
                document.body.appendChild(animatedCard);
                
                // Hide the original card in the ring immediately
                cardElement.style.opacity = '0';
                cardElement.style.pointerEvents = 'none';
                
                // Also hide the card immediately to prevent it from being visible
                cardElement.style.display = 'none';
                
                // Animate to target position
                setTimeout(() => {
                    console.log(`Animating to target: (${cardAreaRect.left}, ${cardAreaRect.top})`);
                    animatedCard.style.left = `${cardAreaRect.left}px`;
                    animatedCard.style.top = `${cardAreaRect.top}px`;
                    animatedCard.style.width = `${cardAreaRect.width}px`;
                    animatedCard.style.height = `${cardAreaRect.height}px`;
                }, 50);
                
                // After animation, move card to player area and reveal it immediately
                setTimeout(() => {
                    console.log(`Moving card to player area for player ${playerId}`);
                    
                    // Get the player's selected card
                    const player = this.stateManager.getPlayer(playerId);
                    if (!player || !player.selectedCard) {
                        console.error(`No selected card found for player ${playerId}`);
                        return;
                    }
                    
                    // Clear player card area
                    playerCardArea.innerHTML = '';
                    
                    // Reset animated card styles
                    animatedCard.style.position = 'relative';
                    animatedCard.style.left = '0';
                    animatedCard.style.top = '0';
                    animatedCard.style.width = '100%';
                    animatedCard.style.height = '100%';
                    animatedCard.style.transition = 'none';
                    
                    // Calculate card value
                    const cardValue = this.getBetValue(player.selectedCard);
                    
                    // Reveal the card immediately with rank, suit, and value (vertically stacked)
                    animatedCard.innerHTML = `
                        <div class="card-content">
                            <div class="card-rank">${player.selectedCard.rank}</div>
                            <div class="card-suit">${this.getSuitSymbol(player.selectedCard.suit)}</div>
                            <div class="card-value">$${cardValue}</div>
                        </div>
                    `;
                    
                    // Set card background to white (revealed)
                    animatedCard.style.background = 'linear-gradient(145deg, #fff, #f0f0f0)';
                    animatedCard.style.border = '2px solid #333';
                    animatedCard.style.color = '#333';
                    
                    // Move to player card area
                    playerCardArea.appendChild(animatedCard);
                    
                    // Remove from body
                    if (animatedCard.parentNode === document.body) {
                        document.body.removeChild(animatedCard);
                    }
                    
                    console.log(`Revealed card for ${player.name}: ${player.selectedCard.rank} of ${player.selectedCard.suit}`);
                }, 900);
                
                // Remove original card from ring
                setTimeout(() => {
                    if (cardElement && cardElement.parentNode) {
                        console.log(`Removing original card from ring for player ${playerId}`);
                        cardElement.remove();
                        console.log(`Removed original card from ring for player ${playerId}`);
                    } else {
                        console.log(`Original card already removed or not found for player ${playerId}`);
                    }
                }, 1000);
                
                // Keep the animated card in the player's card area - don't remove it
                // The animated card will now stay in the player's white card area
            }

            showAdminManualSelection(botId, resolve) {
                const player = this.stateManager.getPlayer(botId);
                const availableCards = this.stateManager.getAvailableCards();
                
                console.log(`Showing admin manual selection for ${player.name}, available cards:`, availableCards);
                
                // Store the resolve function for this bot
                this.pendingManualSelection = { botId, resolve };
                
                // Show admin instruction
                this.elements.gameState.textContent = `Admin: Click a card on the table for ${player.name}`;
                
                // Start countdown for admin manual selection
                this.startManualCountdown(botId, player.name);
                
                // Enable table cards for admin selection
                const tableCards = document.querySelectorAll('.table-card');
                console.log(`Found ${tableCards.length} table cards for admin selection`);
                tableCards.forEach(card => {
                    const rank = card.dataset.rank;
                    if (availableCards.includes(rank)) {
                        // Add admin selection styling
                        card.classList.add('admin-selectable');
                        card.style.border = '3px solid #ff6b35';
                        card.style.boxShadow = '0 0 15px #ff6b35';
                        card.style.cursor = 'pointer';
                        
                        // Add click handler for admin selection
                        card._adminClickHandler = (e) => {
                            console.log(`=== ADMIN CLICKED CARD ${rank} for ${player.name} ===`);
                            e.preventDefault();
                            e.stopPropagation();
                            this.selectCardForBot(botId, rank, resolve);
                        };
                        card.addEventListener('click', card._adminClickHandler, true); // Use capture phase
                        console.log(`Added admin click handler to card ${rank}`);
                        
                        // Add a simple test to verify the card is clickable
                        card.addEventListener('mousedown', () => {
                            console.log(`Mouse down on card ${rank} - card is responsive`);
                        });
                        
                        console.log(`Enabled admin selection for card ${rank}`);
                    } else {
                        // Don't mark already selected cards as unavailable - they should remain visible
                        // card.classList.add('unavailable');
                        // card.style.opacity = '0.5';
                        // card.style.cursor = 'not-allowed';
                        console.log(`Card ${rank} is already selected, keeping it visible`);
                    }
                });
            }

            selectCardForBot(botId, selectedRank, resolve) {
                console.log(`Admin selected card ${selectedRank} for bot ${botId}`);
                
                // Clear countdown timer if it exists
                if (this.countdownTimer) {
                    clearInterval(this.countdownTimer);
                    this.countdownTimer = null;
                    console.log('Countdown timer cleared due to admin card selection');
                    
                    // Hide the timer display
                    const playerSeat = document.getElementById(`player-${botId}`);
                    const timerElement = playerSeat ? playerSeat.querySelector('.manual-timer') : null;
                    if (timerElement) {
                        timerElement.style.display = 'none';
                        // Reset timer text for next use
                        const timerTextSpan = timerElement.querySelector('.timer-text');
                        if (timerTextSpan) {
                            timerTextSpan.textContent = '5s';
                        }
                    }
                }
                
                // Assign a random suit
                const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
                const suit = suits[Math.floor(Math.random() * suits.length)];
                const card = { rank: selectedRank, suit };
                
                // Select the card
                this.stateManager.selectCard(botId, card);
                
                // Clean up table cards
                this.cleanupAdminSelection();
                
                // Clear pending selection
                this.pendingManualSelection = null;
                
                // Resolve the promise
                resolve(true);
            }

            cleanupAdminSelection() {
                console.log('=== CLEANING UP ADMIN SELECTION ===');
                const tableCards = document.querySelectorAll('.table-card');
                console.log(`Found ${tableCards.length} table cards to clean up`);
                tableCards.forEach(card => {
                    const rank = card.dataset.rank;
                    console.log(`Cleaning up card ${rank}`);
                    
                    // Remove admin styling
                    card.classList.remove('admin-selectable');
                    card.style.border = '';
                    card.style.boxShadow = '';
                    card.style.cursor = '';
                    card.style.opacity = '';
                    
                    // Remove admin click handler
                    if (card._adminClickHandler) {
                        console.log(`Removing admin click handler from card ${rank}`);
                        card.removeEventListener('click', card._adminClickHandler, true); // Use capture phase
                        card._adminClickHandler = null;
                    } else {
                        console.log(`No admin click handler found on card ${rank}`);
                    }
                });
                console.log('=== ADMIN SELECTION CLEANUP COMPLETE ===');
            }


            makeRandomSelectionForPlayer(playerId, playerName) {
                console.log(`Making random selection for ${playerName} (ID: ${playerId})`);
                
                const availableCards = this.stateManager.getAvailableCards();
                if (availableCards.length > 0) {
                    const randomRank = availableCards[Math.floor(Math.random() * availableCards.length)];
                    const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
                    const suit = suits[Math.floor(Math.random() * suits.length)];
                    const card = { rank: randomRank, suit };
                    
                    console.log(`Random selection: ${randomRank} of ${suit}`);
                    
                    if (this.stateManager.selectCard(playerId, card)) {
                        console.log(`Random selection successful for ${playerName}`);
                        
                        // Play card selection sound
                        this.soundManager.playSound('cardSelect');
                        
                        // Update displays
                        this.updatePlayerDisplay(playerId);
                        this.updateGameDisplay();
                        
                        // Update table card display
                        this.updateTableCardDisplay(randomRank, playerName);
                        
                        // Check if all cards are selected
                        if (this.stateManager.allCardsSelected()) {
                            console.log('All cards selected, moving to reveal phase');
                            this.stateManager.setState(GAME_STATES.REVEALING_CARDS);
                        } else {
                            // Continue with remaining players
                            setTimeout(() => {
                                this.continueWithRemainingPlayers();
                            }, 1000);
                        }
                    }
                } else {
                    console.log(`No available cards for ${playerName}`);
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Main Game Class
        class NineCardGame {
            constructor() {
                this.stateManager = new StateManager();
                this.gameLogic = new GameLogic(this.stateManager);
                this.botController = new BotController(this.stateManager, this.gameLogic);
                this.uiController = new UIController(this.stateManager, this.gameLogic, this.botController);
                
                this.initializeGame();
            }

            initializeGame() {
                console.log('Initializing Nine Card Game...');
                
                this.stateManager.initializeGame();
                this.uiController.initializeGame();
                
                this.setupGameStateListeners();
                
                console.log('Game initialized successfully!');
            }

            setupGameStateListeners() {
                this.stateManager.addStateListener((newState, oldState) => {
                    this.handleGameStateChange(newState, oldState);
                });
            }

            handleGameStateChange(newState, oldState) {
                console.log(`Game state changed: ${oldState} -> ${newState}`);
                
                switch (newState) {
                    case GAME_STATES.WAITING_FOR_ROUND_START:
                        this.handleWaitingForRoundStart();
                        break;
                    case GAME_STATES.CARD_SELECTION:
                        this.handleCardSelection();
                        break;
                    case GAME_STATES.REVEALING_CARDS:
                        this.handleRevealingCards();
                        break;
                    case GAME_STATES.BANK_DRAW:
                        this.handleBankDraw();
                        break;
                    case GAME_STATES.DISTRIBUTE_WINNINGS:
                        this.handleDistributeWinnings();
                        break;
                    case GAME_STATES.ROUND_SUMMARY:
                        this.handleRoundSummary();
                        break;
                }
            }

            handleWaitingForRoundStart() {
                console.log('Waiting for round to start...');
            }

            handleCardSelection() {
                console.log('Card selection phase started...');
            }

            handleRevealingCards() {
                console.log('Cards revealed, waiting for bank draw...');
            }

            handleBankDraw() {
                console.log('Bank drawing card...');
            }

            handleDistributeWinnings() {
                console.log('Distributing winnings...');
            }

            handleRoundSummary() {
                console.log('Round summary...');
                this.stateManager.updateGameData({ round: this.stateManager.getGameData().round + 1 });
            }
        }

        // Game version and update check
        const GAME_VERSION = '1.100.0';
        const LAST_UPDATE = '2025-10-25';
        
        // Display version info
        function showVersionInfo() {
            const versionDiv = document.createElement('div');
            versionDiv.className = 'version-info';
            versionDiv.innerHTML = `
                <div>Version: ${GAME_VERSION}</div>
                <div>Updated: ${LAST_UPDATE}</div>
                <div>Press F12 for console</div>
            `;
            document.body.appendChild(versionDiv);
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                if (versionDiv.parentNode) {
                    versionDiv.parentNode.removeChild(versionDiv);
                }
            }, 5000);
        }
        
        // Check for updates (simple cache busting)
        function checkForUpdates() {
            const lastCheck = localStorage.getItem('nineCard_lastCheck');
            const now = new Date().toDateString();
            
            if (lastCheck !== now) {
                console.log('🔄 Checking for updates...');
                console.log(`Current version: ${GAME_VERSION}`);
                console.log('To force refresh: Ctrl+F5 or Cmd+Shift+R');
                localStorage.setItem('nineCard_lastCheck', now);
            }
        }

        // Dynamic Matrix Functions
        let matrixCalculator = null;


        function generateDynamicMatrix() {
            if (!matrixCalculator) {
                matrixCalculator = new MatrixCalculator();
            }
            
            // Update current settings display
            const jackpotRateElement = document.getElementById('matrix-jackpot-rate');
            const bankRateElement = document.getElementById('matrix-bank-rate');
            
            if (jackpotRateElement) {
                const jackpotRate = document.getElementById('jackpot-rate')?.value || '5';
                jackpotRateElement.textContent = jackpotRate;
            }
            
            if (bankRateElement) {
                const bankRate = document.getElementById('bank-rate')?.value || '2';
                bankRateElement.textContent = bankRate;
            }
            
            const matrix = matrixCalculator.generateMatrix();
            const table = document.getElementById('dynamic-matrix-table');
            
            if (!table) {
                console.error('Dynamic matrix table not found');
                return;
            }
            
            // Clear existing content
            table.innerHTML = '';
            
            // Generate table rows
            matrix.forEach((row, rowIndex) => {
                const tr = document.createElement('tr');
                
                row.forEach((cell, cellIndex) => {
                    const td = document.createElement('td');
                    td.textContent = cell;
                    
                    // Apply styling based on cell content and position
                    if (rowIndex === 0) {
                        // Header row
                        td.className = '';
                    } else if (rowIndex === matrix.length - 1) {
                        // Jackpot row
                        td.className = 'jackpot';
                    } else if (cellIndex < 2) {
                        // Card and Bet Value columns
                        td.className = '';
                    } else {
                        // Value cells - determine type based on MatrixCalculator result
                        const playerRank = matrix[rowIndex][0];
                        const bankRankIndex = cellIndex - 2; // k=A is column 2, so bankRankIndex = cellIndex - 2
                        const bankRanks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
                        const bankRank = bankRanks[bankRankIndex];
                        
                        // Get the actual result from MatrixCalculator
                        const result = matrixCalculator.calculateMatrixValue(playerRank, bankRank);
                        
                        // Debug logging
                        console.log(`Player ${playerRank} vs Bank ${bankRank}: type=${result.type}, value=${result.value}`);
                        
                        // Apply the correct class based on result type
                        if (result.type === 'loss') {
                            td.className = 'loss';
                        } else if (result.type === 'win') {
                            td.className = 'win';
                        } else if (result.type === 'refund') {
                            td.className = 'refund';
                        } else {
                            td.className = '';
                        }
                    }
                    
                    tr.appendChild(td);
                });
                
                table.appendChild(tr);
            });
        }

        function updateMatrixOnSettingsChange() {
            // Add event listeners to jackpot and bank rate inputs
            const jackpotRateInput = document.getElementById('jackpot-rate');
            const bankRateInput = document.getElementById('bank-rate');
            
            if (jackpotRateInput) {
                jackpotRateInput.addEventListener('input', generateDynamicMatrix);
                jackpotRateInput.addEventListener('change', generateDynamicMatrix);
            }
            
            if (bankRateInput) {
                bankRateInput.addEventListener('input', generateDynamicMatrix);
                bankRateInput.addEventListener('change', generateDynamicMatrix);
            }
        }

        // Jackpot Chip Stack Management
        function updateJackpotChipStack(jackpotAmount) {
            const chipPile = document.getElementById('jackpot-chip-pile');
            if (!chipPile) return;
            
            // Clear existing chips
            chipPile.innerHTML = '';
            
            // Calculate number of chips based on jackpot amount
            // Each chip represents approximately $25 (reduced from $50)
            const chipValue = 25;
            const numberOfChips = Math.max(0, Math.floor(jackpotAmount / chipValue));
            
            // Ensure at least one chip shows if there's any jackpot amount
            const finalChipCount = jackpotAmount > 0 ? Math.max(1, numberOfChips) : 0;
            
            // Create chips
            for (let i = 0; i < finalChipCount; i++) {
                const chip = document.createElement('div');
                chip.className = 'chip';
                chip.style.bottom = `${i * 5}px`; // Increased spacing for bigger chips
                chip.style.zIndex = finalChipCount - i;
                
                // Add slight random rotation for realism
                const randomRotation = (Math.random() - 0.5) * 15; // Increased rotation range
                chip.style.transform = `perspective(100px) rotateX(15deg) rotateZ(${randomRotation}deg)`;
                
                chipPile.appendChild(chip);
            }
        }

        function animateChipToJackpot(fromElement, jackpotAmount) {
            // Create animated chip
            const animatedChip = document.createElement('div');
            animatedChip.className = 'animated-chip';
            animatedChip.style.background = 'linear-gradient(145deg, #f39c12, #e67e22)';
            animatedChip.style.borderColor = '#f39c12';
            
            // Position at source
            const fromRect = fromElement.getBoundingClientRect();
            const jackpotPile = document.getElementById('jackpot-chip-pile');
            const jackpotRect = jackpotPile.getBoundingClientRect();
            
            animatedChip.style.left = `${fromRect.left + fromRect.width / 2}px`;
            animatedChip.style.top = `${fromRect.top + fromRect.height / 2}px`;
            
            document.body.appendChild(animatedChip);
            
            // Animate to jackpot pile
            setTimeout(() => {
                animatedChip.style.left = `${jackpotRect.left + jackpotRect.width / 2}px`;
                animatedChip.style.top = `${jackpotRect.top + jackpotRect.height / 2}px`;
                animatedChip.style.transform = 'perspective(100px) rotateX(15deg) scale(0.5)';
            }, 50);
            
            // Remove chip and update stack
            setTimeout(() => {
                document.body.removeChild(animatedChip);
                updateJackpotChipStack(jackpotAmount);
            }, 1000);
        }

        function animateChipFromJackpot(toElement, jackpotAmount) {
            const jackpotPile = document.getElementById('jackpot-chip-pile');
            const toRect = toElement.getBoundingClientRect();
            const jackpotRect = jackpotPile.getBoundingClientRect();
            
            // Create animated chip
            const animatedChip = document.createElement('div');
            animatedChip.className = 'animated-chip';
            animatedChip.style.background = 'linear-gradient(145deg, #f39c12, #e67e22)';
            animatedChip.style.borderColor = '#f39c12';
            
            // Start from jackpot pile
            animatedChip.style.left = `${jackpotRect.left + jackpotRect.width / 2}px`;
            animatedChip.style.top = `${jackpotRect.top + jackpotRect.height / 2}px`;
            
            document.body.appendChild(animatedChip);
            
            // Animate to destination
            setTimeout(() => {
                animatedChip.style.left = `${toRect.left + toRect.width / 2}px`;
                animatedChip.style.top = `${toRect.top + toRect.height / 2}px`;
                animatedChip.style.transform = 'perspective(100px) rotateX(15deg) scale(0.3)';
            }, 50);
            
            // Remove chip and update stack
            setTimeout(() => {
                document.body.removeChild(animatedChip);
                updateJackpotChipStack(jackpotAmount);
            }, 1000);
        }

        // Initialize game when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing Nine Card Game...');
            console.log(`🎯 Nine Card Game v${GAME_VERSION} - ${LAST_UPDATE}`);
            
            // Show version info
            showVersionInfo();
            checkForUpdates();
            
            try {
                window.nineCardGame = new NineCardGame();
                window.game = window.nineCardGame;
                window.GAME_VERSION = GAME_VERSION;
                window.generateDynamicMatrix = generateDynamicMatrix;
                window.updateJackpotChipStack = updateJackpotChipStack;
                window.animateChipToJackpot = animateChipToJackpot;
                window.animateChipFromJackpot = animateChipFromJackpot;
                
                // Initialize dynamic matrix and chip stack
                setTimeout(() => {
                    generateDynamicMatrix();
                    updateMatrixOnSettingsChange();
                    updateJackpotChipStack(0); // Initialize with empty stack
                }, 100);
                
                console.log('Nine Card Game ready!');
                console.log('Type "game.getGameStats()" in console for game info');
            } catch (error) {
                console.error('Error initializing game:', error);
            }
        });
    </script>
</body>
</html>

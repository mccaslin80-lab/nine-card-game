<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Nine Card - Casino Game v1.98.0</title>
    <link rel="stylesheet" href="styles/style.css">
    <style>
        .player-seat.current-turn {
            border: 5px solid #00aaff !important;
            box-shadow: 0 0 25px #00aaff, 0 0 50px #007bff, inset 0 0 20px rgba(0, 170, 255, 0.3);
            animation: intenseBlink 0.6s infinite;
            transform: scale(1.05);
        }
        
        @keyframes intenseBlink {
            0% { 
                opacity: 1; 
                border-color: #00aaff;
                box-shadow: 0 0 25px #00aaff, 0 0 50px #007bff, inset 0 0 20px rgba(0, 170, 255, 0.3);
            }
            25% { 
                opacity: 0.8; 
                border-color: #0088ff;
                box-shadow: 0 0 30px #0088ff, 0 0 60px #0066ff, inset 0 0 25px rgba(0, 136, 255, 0.4);
            }
            50% { 
                opacity: 0.6; 
                border-color: #0066ff;
                box-shadow: 0 0 35px #0066ff, 0 0 70px #0044ff, inset 0 0 30px rgba(0, 102, 255, 0.5);
            }
            75% { 
                opacity: 0.8; 
                border-color: #0088ff;
                box-shadow: 0 0 30px #0088ff, 0 0 60px #0066ff, inset 0 0 25px rgba(0, 136, 255, 0.4);
            }
            100% { 
                opacity: 1; 
                border-color: #00aaff;
                box-shadow: 0 0 25px #00aaff, 0 0 50px #007bff, inset 0 0 20px rgba(0, 170, 255, 0.3);
            }
        }
        
        .version-badge {
            font-size: 0.6em;
            background: #28a745;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            margin-left: 10px;
            font-weight: normal;
        }

        .version-badge-side {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1001;
            margin-left: 0;
            font-size: 0.7em;
            padding: 4px 10px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .rules-btn {
            background: linear-gradient(145deg, #28a745, #20c997);
            color: white;
            border: none;
            padding: 7px 14px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            white-space: nowrap;
            flex-shrink: 0;
        }

        .rules-btn:hover {
            background: linear-gradient(145deg, #218838, #1e7e34);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .history-header-btn {
            background: linear-gradient(145deg, #27ae60, #229954) !important;
        }

        .history-header-btn:hover {
            background: linear-gradient(145deg, #229954, #1e8449) !important;
        }

        .rules-modal {
            position: fixed;
            top: 200px;
            right: 50px;
            z-index: 1000;
            cursor: move;
            user-select: none;
        }
        
        .rules-modal.hidden {
            display: none;
        }
        
        .admin-panel {
            position: fixed;
            top: 450px;
            left: 250px;
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border: 2px solid #3498db;
            border-radius: 10px;
            padding: 0;
            z-index: 1000;
            max-width: 400px;
            max-height: 700px; /* Increased height for more vertical space */
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            color: white;
            cursor: move;
            user-select: none;
            display: flex;
            flex-direction: column;
        }
        
        .admin-header {
            background: linear-gradient(145deg, #1a252f, #2c3e50);
            color: white;
            padding: 10px 15px;
            border-radius: 8px 8px 0 0;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .admin-header h3 {
            margin: 0;
            font-size: 16px;
        }
        
        .admin-content {
            flex: 1;
            overflow-y: auto;
            padding: 0;
            max-height: calc(700px - 60px); /* Subtract header height */
        }
        
        .admin-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .admin-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .admin-content::-webkit-scrollbar-thumb {
            background: #3498db;
            border-radius: 4px;
        }
        
        .admin-content::-webkit-scrollbar-thumb:hover {
            background: #2980b9;
        }
        
        .close-admin-btn {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-admin-btn:hover {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
        }

        /* Bot Control Panel Styles */
        .bot-control-panel {
            position: fixed;
            top: 200px;
            left: 50px;
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border: 2px solid #e74c3c;
            border-radius: 10px;
            padding: 0;
            z-index: 1000;
            max-width: 500px;
            max-height: 600px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            color: white;
            cursor: move;
            user-select: none;
            display: flex;
            flex-direction: column;
        }
        
        .bot-control-header {
            background: linear-gradient(145deg, #1a252f, #2c3e50);
            color: white;
            padding: 10px 15px;
            border-radius: 8px 8px 0 0;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .bot-control-header h3 {
            margin: 0;
            font-size: 16px;
            color: #e74c3c;
        }
        
        .bot-control-content {
            flex: 1;
            overflow-y: auto;
            padding: 0;
            max-height: calc(600px - 60px);
        }
        
        .bot-control-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .bot-control-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .bot-control-content::-webkit-scrollbar-thumb {
            background: #e74c3c;
            border-radius: 4px;
        }
        
        .bot-control-content::-webkit-scrollbar-thumb:hover {
            background: #c0392b;
        }
        
        .close-bot-control-btn {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-bot-control-btn:hover {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
        }
        
        .bot-control-section {
            padding: 15px;
            color: white;
        }
        
        .bot-control-section h4 {
            color: #e74c3c;
            margin-bottom: 15px;
            font-size: 14px;
        }
        
        .bot-item {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(231, 76, 60, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            transition: all 0.2s ease;
        }
        
        .bot-item:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(231, 76, 60, 0.5);
        }
        
        .bot-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .bot-name {
            font-weight: bold;
            color: #e74c3c;
            font-size: 14px;
        }
        
        .bot-controls-row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .bot-control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 120px;
        }
        
        .bot-control-group label {
            font-size: 11px;
            color: #bdc3c7;
            font-weight: 500;
        }
        
        .bot-control-group input,
        .bot-control-group select {
            padding: 4px 6px;
            font-size: 11px;
            border: 1px solid #555;
            border-radius: 4px;
            background: #34495e;
            color: white;
            transition: all 0.2s ease;
        }
        
        .bot-control-group input:focus,
        .bot-control-group select:focus {
            outline: none;
            border-color: #e74c3c;
            box-shadow: 0 0 0 2px rgba(231, 76, 60, 0.2);
        }
        
        .bot-control-group input:hover,
        .bot-control-group select:hover {
            border-color: #e74c3c;
        }
        
        /* History Panel Styles */
        .history-panel {
            position: fixed;
            top: 200px;
            right: 50px;
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border: 2px solid #27ae60;
            border-radius: 10px;
            padding: 0;
            z-index: 1000;
            max-width: 450px;
            max-height: 700px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            color: white;
            cursor: move;
            user-select: none;
            display: flex;
            flex-direction: column;
        }
        
        .history-header {
            background: linear-gradient(145deg, #1a252f, #2c3e50);
            color: white;
            padding: 10px 15px;
            border-radius: 8px 8px 0 0;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .history-header h3 {
            margin: 0;
            font-size: 16px;
            color: #27ae60;
        }
        
        .history-content {
            flex: 1;
            overflow-y: auto;
            padding: 0;
            max-height: calc(700px - 60px);
        }
        
        .history-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .history-content::-webkit-scrollbar-track {
            background: #34495e;
        }
        
        .history-content::-webkit-scrollbar-thumb {
            background: #27ae60;
            border-radius: 4px;
        }
        
        .history-content::-webkit-scrollbar-thumb:hover {
            background: #2ecc71;
        }
        
        .close-history-btn {
            background: none;
            border: none;
            color: #27ae60;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }
        
        .close-history-btn:hover {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }
        
        .history-section {
            padding: 15px;
            color: white;
        }
        
        .history-section h4 {
            color: #27ae60;
            margin-bottom: 15px;
            font-size: 14px;
        }
        
        .history-list {
            max-height: 500px;
            overflow-y: auto;
        }
        
        .history-entry {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(39, 174, 96, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }
        
        .history-entry:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(39, 174, 96, 0.5);
        }
        
        .history-entry.jackpot-win {
            border-color: rgba(241, 196, 15, 0.5);
            background: rgba(241, 196, 15, 0.1);
        }
        
        .history-entry.insurance-win {
            border-color: rgba(52, 152, 219, 0.5);
            background: rgba(52, 152, 219, 0.1);
        }
        
        .history-round {
            font-weight: bold;
            color: #27ae60;
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .history-player {
            color: white;
            font-size: 13px;
            margin-bottom: 3px;
        }
        
        .history-player.human {
            color: #3498db;
            font-weight: bold;
        }
        
        .history-result {
            font-size: 12px;
            margin-bottom: 2px;
        }
        
        .history-result.win {
            color: #27ae60;
        }
        
        .history-result.loss {
            color: #e74c3c;
        }
        
        .history-result.refund {
            color: #f39c12;
        }
        
        .history-jackpot {
            color: #f1c40f;
            font-weight: bold;
            font-size: 12px;
            margin-top: 5px;
        }
        
        .admin-panel .admin-section {
            padding: 15px;
            color: white;
        }
        
        .admin-panel .admin-section h4 {
            color: #3498db;
            margin-bottom: 10px;
        }
        
        .admin-panel .stats-display div {
            color: white;
            margin-bottom: 5px;
        }
        
        .admin-panel .sound-controls {
            margin-bottom: 15px;
        }
        
        .admin-panel .sound-controls .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .admin-panel .sound-controls input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: #3498db;
        }
        
        .admin-panel .toggle-label {
            color: #3498db;
            font-weight: bold;
        }
        
        .insurance-setting-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #3498db;
            border-radius: 4px;
            color: white;
            padding: 5px 8px;
            width: 80px;
            font-size: 14px;
        }
        
        .insurance-setting-input:focus {
            outline: none;
            border-color: #2980b9;
            background: rgba(255, 255, 255, 0.15);
        }
        
        .insurance-timer-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #3498db;
            border-radius: 4px;
            color: white;
            padding: 5px 8px;
            width: 80px;
            font-size: 14px;
        }
        
        .insurance-timer-input:focus {
            outline: none;
            border-color: #2980b9;
            background: rgba(255, 255, 255, 0.15);
        }
        
        .human-insurance-icon {
            position: absolute;
            top: -15px;
            right: -15px;
            font-size: 20px;
            cursor: pointer;
            color: #888 !important;
            opacity: 0.6;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
            z-index: 10;
            user-select: none;
        }
        
        .human-insurance-icon:hover:not(.purchased):not(.disabled) {
            transform: scale(1.1);
            color: #3498db !important;
            opacity: 0.8;
        }
        
        .human-insurance-icon.purchased {
            color: #e74c3c !important;
            opacity: 1;
            animation: insuranceGlow 2s ease-in-out infinite alternate;
        }
        
        .human-insurance-icon.disabled {
            color: #444 !important;
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .human-insurance-icon.clicking {
            animation: insuranceClickFlash 0.3s ease-out;
        }
        
        @keyframes insuranceClickFlash {
            0% {
                color: #27ae60 !important;
                transform: scale(1.2);
                opacity: 1;
            }
            50% {
                color: #2ecc71 !important;
                transform: scale(1.1);
            }
            100% {
                color: #e74c3c !important;
                transform: scale(1);
            }
        }
        
        .insurance-marker {
            position: absolute;
            top: -15px;
            right: -15px;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .insurance-marker > div {
            animation: insuranceGlow 2s ease-in-out infinite alternate;
        }
        
        .insurance-select-all {
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            border: 1px solid #3498db;
        }
        
        .select-all-checkbox {
            margin-right: 8px;
            transform: scale(1.2);
        }
        
        .insurance-select-all label {
            color: white;
            font-weight: bold;
            cursor: pointer;
        }
        
        @keyframes insuranceGlow {
            0% {
                box-shadow: 0 0 10px rgba(231, 76, 60, 0.8), 0 0 20px rgba(231, 76, 60, 0.4);
            }
            100% {
                box-shadow: 0 0 20px rgba(231, 76, 60, 1), 0 0 40px rgba(231, 76, 60, 0.8);
            }
        }
        
        /* Jackpot animation styles */
        .jackpot-star {
            position: absolute;
            color: #FFD700;
            font-size: 20px;
            pointer-events: none;
            z-index: 1000;
            animation: starFloat 2s ease-out forwards;
        }
        
        .jackpot-gold {
            position: absolute;
            color: #FFD700;
            font-size: 16px;
            pointer-events: none;
            z-index: 1000;
            animation: goldFloat 2s ease-out forwards;
        }
        
        @keyframes starFloat {
            0% {
                opacity: 1;
                transform: scale(0.5) rotate(0deg);
            }
            50% {
                opacity: 1;
                transform: scale(1.2) rotate(180deg);
            }
            100% {
                opacity: 0;
                transform: scale(0.8) rotate(360deg) translateY(-100px);
            }
        }
        
        @keyframes goldFloat {
            0% {
                opacity: 1;
                transform: scale(0.3) rotate(0deg);
            }
            30% {
                opacity: 1;
                transform: scale(1.1) rotate(120deg);
            }
            100% {
                opacity: 0;
                transform: scale(0.6) rotate(360deg) translateY(-80px);
            }
        }

        .rules-content {
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border: 2px solid #3498db;
            border-radius: 10px;
            padding: 0;
            max-width: 500px;
            max-height: 700px;
            width: 500px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            color: white;
            display: flex;
            flex-direction: column;
        }

        .rules-header {
            background: linear-gradient(145deg, #3498db, #2980b9);
            color: white;
            padding: 10px 15px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
        }

        .rules-header h2 {
            margin: 0;
            font-size: 16px;
        }

        .close-rules-btn {
            background: none;
            border: none;
            color: white;
            font-size: 2em;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.3s ease;
        }

        .close-rules-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .rules-body {
            padding: 20px;
            color: #ecf0f1;
            line-height: 1.6;
            flex: 1;
            overflow-y: auto;
            max-height: calc(700px - 60px);
        }
        
        .rules-body::-webkit-scrollbar {
            width: 8px;
        }
        
        .rules-body::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .rules-body::-webkit-scrollbar-thumb {
            background: #3498db;
            border-radius: 4px;
        }
        
        .rules-body::-webkit-scrollbar-thumb:hover {
            background: #2980b9;
        }

        .rules-body h3 {
            color: #3498db;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .rules-body h3:first-child {
            margin-top: 0;
        }

        .rules-body p {
            margin-bottom: 15px;
        }

        .rules-body ul {
            margin-bottom: 20px;
            padding-left: 20px;
        }

        .rules-body li {
            margin-bottom: 8px;
        }

        .rules-body strong {
            color: #f39c12;
        }

        /* Payout Matrix Styles */
        .payout-matrix {
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            backdrop-filter: blur(10px);
        }

        .payout-matrix__table {
            display: grid;
            grid-template-columns: 60px repeat(9, 1fr);
            gap: 2px;
            font-size: 0.8rem;
        }

        .payout-matrix__header {
            display: contents;
        }

        .payout-matrix__row {
            display: contents;
        }

        .payout-matrix__cell {
            padding: 4px 6px;
            text-align: center;
            border-radius: 3px;
            font-weight: 500;
            min-height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .payout-matrix__cell--header {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-weight: 600;
            font-size: 0.75rem;
        }

        .payout-matrix__cell--green {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .payout-matrix__cell--red {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .payout-matrix__cell--yellow {
            background: rgba(234, 179, 8, 0.2);
            color: #eab308;
            border: 1px solid rgba(234, 179, 8, 0.3);
        }

        .payout-matrix__legend {
            margin-top: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .payout-matrix__legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            color: #ccc;
        }

        .payout-matrix__legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            flex-shrink: 0;
        }

        .payout-matrix__legend-color--green {
            background: rgba(34, 197, 94, 0.3);
            border: 1px solid rgba(34, 197, 94, 0.5);
        }

        .payout-matrix__legend-color--red {
            background: rgba(239, 68, 68, 0.3);
            border: 1px solid rgba(239, 68, 68, 0.5);
        }

        .payout-matrix__legend-color--yellow {
            background: rgba(234, 179, 8, 0.3);
            border: 1px solid rgba(234, 179, 8, 0.5);
        }

        .card-value {
            font-size: 1.2em;
            color: #28a745;
            font-weight: bold;
            margin-top: 3px;
            text-align: center;
        }

        .table-card .card-value {
            font-size: 1.0em;
            color: #28a745;
            font-weight: bold;
            margin-top: 2px;
            text-align: center;
        }

        .card-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 100%;
            width: 100%;
            padding-top: 8px;
        }

        .chip-stack-container {
            position: absolute;
            width: 40px;
            height: 60px;
            z-index: 10;
        }

        .chip-stack {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            width: 100%;
            height: 100%;
            align-items: end;
        }

        .chip {
            width: 10px;
            height: 6px;
            border-radius: 1px;
            border: 1px solid;
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
            transform: perspective(100px) rotateX(15deg);
            transition: transform 0.2s ease;
        }

        .chip:hover {
            transform: perspective(100px) rotateX(15deg) translateY(-2px);
        }

        .human-strategy-container {
            position: absolute;
            z-index: 15;
        }

        .human-strategy-container .strategy-buttons {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .insurance-behavior {
            margin-top: 8px;
            margin-left: 10px; /* Small offset to the right, but not covering chip stack */
            max-width: 120px; /* Limit width to prevent covering chip stack */
        }

        .insurance-behavior label {
            font-size: 11px;
            color: #2196F3;
            display: block;
            margin-bottom: 3px;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(33, 150, 243, 0.3);
        }

        .insurance-select {
            width: 100%;
            max-width: 120px; /* Limit width to prevent covering chip stack */
            padding: 3px 6px;
            font-size: 11px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fff;
            color: #333;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .insurance-select:hover {
            border-color: #2196F3;
            box-shadow: 0 2px 6px rgba(33, 150, 243, 0.2);
            transform: translateY(-1px);
        }

        .insurance-select:focus {
            outline: none;
            border-color: #2196F3;
            box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
        }

        .insurance-select option {
            padding: 4px;
            font-size: 11px;
        }

        .animated-chip {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 0 rgba(255, 255, 255, 0.3),
                inset 0 -2px 0 rgba(0, 0, 0, 0.2);
            transform: perspective(100px) rotateX(15deg);
            z-index: 1000;
            pointer-events: none;
            transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .chip-pile {
            position: absolute;
            width: 40px;
            height: 30px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
        }

        .chip-pile .chip {
            position: absolute;
            width: 10px;
            height: 6px;
            border-radius: 1px;
            border: 1px solid;
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
            transform: perspective(100px) rotateX(15deg);
        }

        /* Jackpot Chip Stack Styles */
        .jackpot-chip-stack {
            position: absolute;
            left: -70px;
            top: 35%;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }
        
        .chip-stack-label {
            position: absolute;
            left: -70px;
            top: 20%;
            color: #ffffff;
            font-weight: bold;
            font-size: 12px;
            margin-top: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            white-space: nowrap;
            z-index: 10;
        }
        
        #jackpot-chip-pile {
            position: relative;
            width: 70px;
            height: 100px;
            max-height: 100px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
        }

        #jackpot-chip-pile .chip {
            position: absolute;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 3px solid #f39c12;
            background: linear-gradient(145deg, #f39c12, #e67e22);
            box-shadow: 
                0 6px 12px rgba(0, 0, 0, 0.5),
                inset 0 3px 0 rgba(255, 255, 255, 0.4),
                inset 0 -3px 0 rgba(0, 0, 0, 0.3);
            transform: perspective(100px) rotateX(15deg);
            transition: all 0.3s ease;
        }

        #jackpot-chip-pile .chip:hover {
            transform: perspective(100px) rotateX(15deg) translateY(-3px);
            box-shadow: 
                0 8px 16px rgba(0, 0, 0, 0.7),
                inset 0 3px 0 rgba(255, 255, 255, 0.5),
                inset 0 -3px 0 rgba(0, 0, 0, 0.4);
        }
        
        .version-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.8em;
            z-index: 1000;
        }

        /* First player/turn marker */
        .turn-marker {
            position: absolute;
            top: -14px;
            left: -14px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #ffd700, #e6b800);
            border: 2px solid rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 12px rgba(255, 215, 0, 0.9), 0 0 20px rgba(255, 215, 0, 0.5);
            color: #8a6d00;
            display: none; /* shown via JS for first/current turn */
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            user-select: none;
        }

        /* Matrix Modal Styles */
        .matrix-modal {
            position: fixed;
            top: 200px;
            left: 50px;
            z-index: 2000;
            cursor: move;
            user-select: none;
        }

        .matrix-modal.hidden {
            display: none;
        }

        .matrix-content {
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border: 2px solid #27ae60;
            border-radius: 10px;
            padding: 0;
            max-width: 600px;
            max-height: 700px;
            width: 600px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            color: white;
            display: flex;
            flex-direction: column;
        }

        .matrix-content p {
            color: #ecf0f1;
            margin: 10px 0;
        }

        .matrix-content strong {
            color: #f39c12;
            font-weight: bold;
        }

        .matrix-header {
            background: linear-gradient(145deg, #27ae60, #229954);
            color: white;
            padding: 10px 15px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
        }

        .matrix-header h2 {
            margin: 0;
            color: white;
            font-size: 16px;
        }

        .matrix-body {
            padding: 20px;
            flex: 1;
            overflow-y: auto;
            max-height: calc(700px - 60px);
        }
        
        .matrix-body::-webkit-scrollbar {
            width: 8px;
        }
        
        .matrix-body::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .matrix-body::-webkit-scrollbar-thumb {
            background: #27ae60;
            border-radius: 4px;
        }
        
        .matrix-body::-webkit-scrollbar-thumb:hover {
            background: #229954;
        }

        .close-matrix-btn {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-matrix-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .matrix-image {
            max-width: 100%;
            height: auto;
            border: 2px solid #333;
            border-radius: 5px;
        }

        /* Payout Matrix Table Styles */
        .payout-matrix {
            margin-top: 20px;
            overflow-x: auto;
        }

        .matrix-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            background: rgba(255, 255, 255, 0.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            border-radius: 8px;
            overflow: hidden;
        }

        .matrix-table th {
            background: linear-gradient(145deg, #27ae60, #229954);
            color: white;
            padding: 6px 4px;
            text-align: center;
            font-weight: bold;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 10px;
        }

        .matrix-table td {
            padding: 5px 4px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-weight: 500;
            color: #ecf0f1;
            font-size: 11px;
        }

        .matrix-table td:first-child,
        .matrix-table td:nth-child(2) {
            background-color: rgba(255, 255, 255, 0.1) !important;
            color: #ecf0f1 !important;
            font-weight: bold;
        }

        .matrix-table tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.02);
        }

        .matrix-table tr:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .matrix-table .win {
            background-color: rgba(76, 175, 80, 0.3) !important;
            color: #a5d6a7;
            font-weight: bold;
        }

        .matrix-table .loss {
            background-color: rgba(244, 67, 54, 0.3) !important;
            color: #ef9a9a;
            font-weight: bold;
        }

        .matrix-table .refund {
            background-color: rgba(255, 152, 0, 0.3) !important;
            color: #ffb74d;
            font-weight: bold;
        }

        .matrix-table .jackpot {
            background-color: rgba(33, 150, 243, 0.3) !important;
            color: #90caf9;
            font-weight: bold;
        }

        /* Jackpot Promotional Text */
        .jackpot-promo {
            position: fixed;
            right: 100px;
            top: 22.5%;
            transform: translateY(-50%);
            background: rgba(255, 215, 0, 0.1);
            color: #ffd700;
            padding: 15px 20px;
            border-radius: 8px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            text-align: center;
            width: 500px;
            box-shadow: 0 2px 8px rgba(255, 215, 0, 0.2);
            z-index: 1000;
        }

        /* Quick Rules Promotion Box */
        .quick-rules-promo {
            position: fixed;
            left: 50px;
            top: 40%;
            transform: translateY(-50%);
            background: rgba(52, 152, 219, 0.15);
            color: #3498db;
            padding: 15px 20px;
            border-radius: 8px;
            border: 2px solid rgba(52, 152, 219, 0.4);
            width: 350px;
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
            z-index: 1000;
        }

        .quick-rules-promo h3 {
            margin: 0 0 12px 0;
            font-size: 16px;
            color: #3498db;
            text-align: center;
            border-bottom: 1px solid rgba(52, 152, 219, 0.3);
            padding-bottom: 8px;
        }

        .quick-rules-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .quick-rules-list li {
            margin-bottom: 10px;
            font-size: 12px;
            line-height: 1.4;
            padding-left: 20px;
            position: relative;
        }

        .quick-rules-list li:before {
            content: "✓";
            position: absolute;
            left: 0;
            color: #3498db;
            font-weight: bold;
        }

        .quick-rules-list li strong {
            color: #2980b9;
            font-weight: 600;
        }

        .promo-text {
            font-weight: bold;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            line-height: 1.4;
        }

        /* Manual Timer Styles */
        .manual-timer {
            font-size: 0.9em !important;
            color: #ff0000 !important;
            font-weight: bold !important;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 1) !important;
            position: absolute !important;
            top: -20px !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            background: rgba(255, 255, 255, 0.95) !important;
            border: 1px solid #ff0000 !important;
            padding: 1px 4px !important;
            border-radius: 2px !important;
            z-index: 9999 !important;
            display: none !important; /* Initially hidden */
            visibility: hidden !important; /* Initially hidden */
            opacity: 0 !important; /* Initially hidden */
            width: auto !important;
            min-width: 20px !important;
            max-width: 35px !important;
            text-align: center !important;
            white-space: nowrap !important;
        }

        .timer-text {
            animation: timerPulse 1s ease-in-out infinite !important;
            font-size: inherit !important;
            color: inherit !important;
            font-weight: inherit !important;
        }

        @keyframes timerPulse {
            0%, 100% { 
                opacity: 1; 
                transform: scale(1);
            }
            50% { 
                opacity: 0.7; 
                transform: scale(1.1);
            }
        }

        /* Game Table Container */
        .game-table {
            position: relative;
            margin: 0 auto;
        }

        /* Header Layout */
        .game-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
            overflow-x: auto;
            overflow-y: hidden;
        }

        .game-header h1 {
            white-space: nowrap;
            margin-right: 15px;
            margin-bottom: 0;
            margin-top: 0;
        }

        /* Jackpot Display Boxes */
        .jackpot-display,
        .insurance-jackpot-display {
            display: inline-flex;
            align-items: center;
            padding: 5px 10px;
            border-radius: 6px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        /* Super Jackpot Display */
        .super-jackpot-display {
            display: inline-flex;
            align-items: center;
            padding: 5px 10px;
            border-radius: 6px;
            border: 2px solid rgba(142, 68, 173, 0.6);
            background: rgba(142, 68, 173, 0.1);
            animation: superJackpotGlow 2s ease-in-out infinite alternate;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        @keyframes superJackpotGlow {
            0% {
                box-shadow: 0 0 5px rgba(142, 68, 173, 0.5), 0 0 10px rgba(142, 68, 173, 0.3);
                border-color: rgba(142, 68, 173, 0.6);
            }
            100% {
                box-shadow: 0 0 15px rgba(142, 68, 173, 0.8), 0 0 25px rgba(142, 68, 173, 0.5), 0 0 35px rgba(142, 68, 173, 0.3);
                border-color: rgba(142, 68, 173, 1);
            }
        }
        
        .super-jackpot-label {
            font-weight: bold;
            margin-right: 5px;
            color: #8e44ad;
        }

        /* Ensure labels and amounts stay on one line */
        .jackpot-label,
        .super-jackpot-label,
        .insurance-label {
            display: inline;
            white-space: nowrap;
        }

        #jackpot-amount,
        #super-jackpot-amount,
        #insurance-amount {
            display: inline;
            white-space: nowrap;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Header -->
        <span class="version-badge version-badge-side">v1.121.0</span>
        <header class="game-header">
            <h1>🎯 Nine Card</h1>
            <div class="jackpot-display">
                <span class="jackpot-label">♥️ Jackpot:</span>
                <span id="jackpot-amount">0</span>
            </div>
            <div class="super-jackpot-display">
                <span class="super-jackpot-label">💎 Super Jackpot:</span>
                <span id="super-jackpot-amount">0</span>
            </div>
            <div class="insurance-jackpot-display">
                <span class="insurance-label">Insurance Jackpot:</span>
                <span id="insurance-amount">0</span>
            </div>
            <button id="history-btn" class="rules-btn history-header-btn">📊 History</button>
            <button id="rules-btn" class="rules-btn">📋 Rules</button>
            <button id="matrix-btn" class="rules-btn">📊 Pay out Matrix</button>
        </header>


        <!-- Game Table -->
        <div class="game-table">
            <!-- Central Bank Area -->
            <div class="bank-area">
                <div class="bank-card" id="bank-card">
                    <div class="card-back">🏦</div>
                </div>
                <div class="jackpot-chip-stack" id="jackpot-chip-stack">
                    <div class="chip-pile" id="jackpot-chip-pile">
                        <!-- Chips will be dynamically generated here -->
                    </div>
                </div>
                <div class="chip-stack-label">Jackpot</div>
                <div class="bank-info">
                    <div class="round-info">
                        <span id="current-round">Round 1</span>
                    </div>
                </div>
            </div>

            <!-- Player Seats (9 players in circle) -->
            <div class="player-seats">
                <!-- Player seats will be dynamically generated -->
            </div>
        </div>

        <!-- Jackpot Promotional Text -->
        <div class="jackpot-promo">
            <span class="promo-text">♥️ <strong>HEARTS JACKPOT:</strong> Match rank & suit with ♥️ Hearts<br>
            💎 <strong>SUPER JACKPOT:</strong> Win Hearts Jackpot twice in a row for MEGA payout!<br>
            🛡️ <strong>INSURANCE JACKPOT:</strong> Buy $10 insurance, match ANY suit<br>
            <small>⚠️ Insurance available when pot reaches $50 minimum</small><br>
            <em>THREE ways to win BIG! Win Hearts twice = Super Jackpot! 80% Hearts / 20% Insurance from all contributions!</em></span>
        </div>

        <!-- Quick Rules Promotion Box -->
        <div class="quick-rules-promo">
            <h3>📋 Quick Rules</h3>
            <ul class="quick-rules-list">
                <li><strong>Select a card at your turn:</strong> Click on an available card to place your bet</li>
                <li><strong>Bank draws a card:</strong> After all players choose, bank draws Ace through 10</li>
                <li><strong>Lower card wins:</strong> Beat the bank's card</li>
                <li><strong>Same card loses:</strong> You lose your bet</li>
                <li><strong>Higher card refund:</strong> Get bet back minus jackpot fee</li>
                <li><strong>Bank draws 10:</strong> Only card 9 wins (739)</li>
                <li><strong>Bank draws Ace:</strong> No winners, Ace bet goes to jackpot</li>
                <li><strong>Hearts Jackpot:</strong> Match rank & suit with ♥️</li>
                <li><strong>Super Jackpot:</strong> Win Hearts Jackpot twice in a row!</li>
                <li><strong>Insurance:</strong> Match rank & suit (any suit)</li>
            </ul>
        </div>

        <!-- Game Controls -->
        <div class="game-controls">
            <button id="start-round-btn" class="control-btn primary">Start New Round</button>
            <button id="admin-panel-btn" class="control-btn">Admin Panel</button>
            <button id="bot-control-btn" class="control-btn">Bot Control</button>
        </div>

        <!-- Rules Modal -->
        <div id="rules-modal" class="rules-modal hidden">
            <div class="rules-content">
                <div class="rules-header">
                    <h2>🎯 Nine Card - Game Rules</h2>
                    <button id="close-rules-btn" class="close-rules-btn">&times;</button>
                </div>
                <div class="rules-body">
                    <h3>🎮 How to Play</h3>
                    <p>Nine Card is a casino-style card game where players compete against other players by selecting cards from A to 9.</p>
                    
                    <h3>🃏 Card Selection</h3>
                    <ul>
                        <li>Each player selects one card from A, 2, 3, 4, 5, 6, 7, 8, or 9</li>
                        <li>Cards are selected in turn order decided by the admin (can be changed in Admin controls)</li>
                        <li>Once a card is selected, it cannot be chosen by another player</li>
                    </ul>
                    
                    <h3>🏦 Bank Card</h3>
                    <p>After all players have selected their cards, the bank draws one card  (A-10).</p>
                    
                    <h3>💰 Winning Conditions</h3>
                    <ul>
                        <li><strong>WIN:</strong> Your card number is LOWER than the bank's card</li>
                        <li><strong>LOSS:</strong> Your card number is the same number as the bank's card</li>
                        <li><strong>REFUND:</strong> your card number is HIGHER than the bank's card (you keep your bet minus the jackpot withdraw)</li>
                        <li><strong>BANK 10:</strong> If bank draws 10, all players lose except player with card 9</li>
                    </ul>
                    
                    <h3>🎰 Payout System</h3>
                    <ul>
                        <li><strong>Winners:</strong> Share the losing player's bet in cascade order (highest number first)</li>
                        <li><strong>Refunds:</strong> Keep their original bet minus jackpot contribution</li>
                        <li><strong>Jackpot Contribution:</strong> 5% of refunded bets go to the jackpots. Contribution percentage can be changed in admin controls</li>
                        <li><strong>Bank Rake:</strong> The casino takes 2% from the losing player's bet as house commission. Can be changed in admin controls</li>
                    </ul>
                    
                    <h3>♥️ Hearts Jackpot</h3>
                    <ul>
                        <li><strong>How to Win:</strong> Draw the same rank AND suit as the bank with ♥️ Hearts!</li>
                        <li><strong>Jackpot Split:</strong> Contributions are split 80% to Hearts Jackpot, 20% to Insurance Jackpot. From the Hearts Jackpot portion, a percentage (adjustable in admin) is reserved for Super Jackpot.</li>
                        <li><strong>Payout:</strong> Win the entire Hearts Jackpot if bank card matches players number and heart suit</li>
                        <li><strong>Example:</strong> If you select the 7♥ and the bank draws 7♥, you win!</li>
                    </ul>
                    
                    <h3>💎 Super Jackpot</h3>
                    <ul>
                        <li><strong>How to Win:</strong> Win the Hearts Jackpot two times in a row! Must be the same player winning both times consecutively.</li>
                        <li><strong>Super Jackpot Contribution:</strong> A percentage (default 10%, adjustable in admin controls) of each Hearts Jackpot contribution is reserved for the Super Jackpot, multiplied by the number of simultaneous tables (default 10, adjustable in admin).</li>
                        <li><strong>Payout:</strong> When you win Hearts Jackpot for the second consecutive time, you receive BOTH the Hearts Jackpot AND the entire Super Jackpot!</li>
                        <li><strong>Reset:</strong> After a Super Jackpot win, the Super Jackpot resets to zero, and you start fresh for the next consecutive win attempt.</li>
                        <li><strong>Example:</strong> Win with 5♥ in round 1, then win again with 8♥ in round 2 = You win Hearts Jackpot + Super Jackpot!</li>
                    </ul>
                    
                    <h3>🛡️ Insurance System</h3>
                    <ul>
                        <li><strong>Purchase:</strong> Buy insurance for $10 before each round (only if Insurance Pot ≥ $20). Insurance cost and minimum pot can be set in admin controls.</li>
                        <li><strong>Insurance Pot:</strong> Receives 20% of all jackpot contributions and the insurance buy in from all players.</li>
                        <li><strong>How to Win:</strong> Have the same rank AND suit as the bank's card (any suit, not just hearts)</li>
                        <li><strong>Payout:</strong> Win the entire Insurance Pot (accumulates until won)</li>
                        <li><strong>Example:</strong> If you have insurance and both you and the bank draw 5♠, you win the Insurance Pot!</li>
                        <li><strong>Visual Indicator:</strong> Blue shield icon appears on player seat when insurance is purchased</li>
                    </ul>
                    
                    <h3>🎯 Special Rules</h3>
                    <ul>
                        <li><strong>Turn Order:</strong> Default set to clockwise order but can be changed in admin controls</li>
                        <li><strong>Balance:</strong> Each player starts with $1000 (total: $9000)</li>
                        <li><strong>Balance Conservation:</strong> Total money in game = Player balances + Jackpot + Bank Rake</li>
                        <li><strong>No Rebuys:</strong> Players cannot add money during the game</li>
                    </ul>
                    
                    <h3>🎨 Card Colors</h3>
                    <ul>
                        <li><span style="color: red;">♥ Hearts</span> and <span style="color: red;">♦ Diamonds</span> are red</li>
                        <li><span style="color: black;">♠ Spades</span> and <span style="color: black;">♣ Clubs</span> are black</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Matrix Modal -->
        <div id="matrix-modal" class="matrix-modal hidden">
            <div class="matrix-content">
                <div class="matrix-header">
                    <h2>📊 Payout Matrix</h2>
                    <button id="close-matrix-btn" class="close-matrix-btn">&times;</button>
                </div>
                <div class="matrix-body">
                    <p>This matrix shows the payout for each player card when the bank draws different cards.</p>
                    <p><strong>k = Bank number</strong></p>
                    <p><strong>Legend:</strong></p>
                    <ul>
                        <li><span style="color: green;">Green cells</span> = Win</li>
                        <li><span style="color: red;">Red cells</span> = Loss</li>
                        <li><span style="color: orange;">Orange cells</span> = Refund</li>
                    </ul>
                    
                    <p><strong>Current Settings:</strong></p>
                    <ul>
                        <li><strong>Jackpot Rate:</strong> <span id="matrix-jackpot-rate">5</span>% (from refund players)</li>
                        <li><strong>Bank Rake:</strong> <span id="matrix-bank-rate">2</span>% (from losing players)</li>
                    </ul>
                    
                    <div class="payout-matrix">
                        <table class="matrix-table" id="dynamic-matrix-table">
                            <!-- Dynamic content will be generated here -->
                        </table>
                    </div>
                    
                    <!-- Odds Chart Section -->
                    <div class="odds-chart-section">
                        <h3>📊 Win/Loss/Refund Odds by Card</h3>
                        <div class="odds-chart">
                            <div class="chart-legend">
                                <div class="legend-item">
                                    <span class="legend-color win-color"></span>
                                    <span>Win</span>
                                </div>
                                <div class="legend-item">
                                    <span class="legend-color refund-color"></span>
                                    <span>Refund</span>
                                </div>
                                <div class="legend-item">
                                    <span class="legend-color loss-color"></span>
                                    <span>Loss</span>
                                </div>
                            </div>
                            
                            <div class="chart-container">
                                <!-- Card A -->
                                <div class="chart-row">
                                    <div class="card-label">A</div>
                                    <div class="bar-container">
                                        <div class="bar-segment win-segment" style="width: 80%"></div>
                                        <div class="bar-segment loss-segment" style="width: 20%"></div>
                                    </div>
                                    <div class="percentages">
                                        <span class="win-percent">80%</span>
                                        <span class="loss-percent">20%</span>
                                    </div>
                                </div>
                                
                                <!-- Card 2 -->
                                <div class="chart-row">
                                    <div class="card-label">2</div>
                                    <div class="bar-container">
                                        <div class="bar-segment win-segment" style="width: 70%"></div>
                                        <div class="bar-segment refund-segment" style="width: 10%"></div>
                                        <div class="bar-segment loss-segment" style="width: 20%"></div>
                                    </div>
                                    <div class="percentages">
                                        <span class="win-percent">70%</span>
                                        <span class="refund-percent">10%</span>
                                        <span class="loss-percent">20%</span>
                                    </div>
                                </div>
                                
                                <!-- Card 3 -->
                                <div class="chart-row">
                                    <div class="card-label">3</div>
                                    <div class="bar-container">
                                        <div class="bar-segment win-segment" style="width: 60%"></div>
                                        <div class="bar-segment refund-segment" style="width: 20%"></div>
                                        <div class="bar-segment loss-segment" style="width: 20%"></div>
                                    </div>
                                    <div class="percentages">
                                        <span class="win-percent">60%</span>
                                        <span class="refund-percent">20%</span>
                                        <span class="loss-percent">20%</span>
                                    </div>
                                </div>
                                
                                <!-- Card 4 -->
                                <div class="chart-row">
                                    <div class="card-label">4</div>
                                    <div class="bar-container">
                                        <div class="bar-segment win-segment" style="width: 50%"></div>
                                        <div class="bar-segment refund-segment" style="width: 30%"></div>
                                        <div class="bar-segment loss-segment" style="width: 20%"></div>
                                    </div>
                                    <div class="percentages">
                                        <span class="win-percent">50%</span>
                                        <span class="refund-percent">30%</span>
                                        <span class="loss-percent">20%</span>
                                    </div>
                                </div>
                                
                                <!-- Card 5 -->
                                <div class="chart-row">
                                    <div class="card-label">5</div>
                                    <div class="bar-container">
                                        <div class="bar-segment win-segment" style="width: 40%"></div>
                                        <div class="bar-segment refund-segment" style="width: 40%"></div>
                                        <div class="bar-segment loss-segment" style="width: 20%"></div>
                                    </div>
                                    <div class="percentages">
                                        <span class="win-percent">40%</span>
                                        <span class="refund-percent">40%</span>
                                        <span class="loss-percent">20%</span>
                                    </div>
                                </div>
                                
                                <!-- Card 6 -->
                                <div class="chart-row">
                                    <div class="card-label">6</div>
                                    <div class="bar-container">
                                        <div class="bar-segment win-segment" style="width: 30%"></div>
                                        <div class="bar-segment refund-segment" style="width: 50%"></div>
                                        <div class="bar-segment loss-segment" style="width: 20%"></div>
                                    </div>
                                    <div class="percentages">
                                        <span class="win-percent">30%</span>
                                        <span class="refund-percent">50%</span>
                                        <span class="loss-percent">20%</span>
                                    </div>
                                </div>
                                
                                <!-- Card 7 -->
                                <div class="chart-row">
                                    <div class="card-label">7</div>
                                    <div class="bar-container">
                                        <div class="bar-segment win-segment" style="width: 20%"></div>
                                        <div class="bar-segment refund-segment" style="width: 60%"></div>
                                        <div class="bar-segment loss-segment" style="width: 20%"></div>
                                    </div>
                                    <div class="percentages">
                                        <span class="win-percent">20%</span>
                                        <span class="refund-percent">60%</span>
                                        <span class="loss-percent">20%</span>
                                    </div>
                                </div>
                                
                                <!-- Card 8 -->
                                <div class="chart-row">
                                    <div class="card-label">8</div>
                                    <div class="bar-container">
                                        <div class="bar-segment win-segment" style="width: 10%"></div>
                                        <div class="bar-segment refund-segment" style="width: 70%"></div>
                                        <div class="bar-segment loss-segment" style="width: 20%"></div>
                                    </div>
                                    <div class="percentages">
                                        <span class="win-percent">10%</span>
                                        <span class="refund-percent">70%</span>
                                        <span class="loss-percent">20%</span>
                                    </div>
                                </div>
                                
                                <!-- Card 9 -->
                                <div class="chart-row">
                                    <div class="card-label">9</div>
                                    <div class="bar-container">
                                        <div class="bar-segment win-segment" style="width: 10%"></div>
                                        <div class="bar-segment refund-segment" style="width: 80%"></div>
                                        <div class="bar-segment loss-segment" style="width: 10%"></div>
                                    </div>
                                    <div class="percentages">
                                        <span class="win-percent">10%</span>
                                        <span class="refund-percent">80%</span>
                                        <span class="loss-percent">10%</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="chart-note">
                                <p><strong>Note:</strong> Lower cards = Higher win chance, Higher cards = Higher refund chance</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Admin Panel -->
        <div id="admin-panel" class="admin-panel hidden">
            <div class="admin-header">
            <h3>Admin Controls</h3>
                <button id="close-admin-btn" class="close-admin-btn">&times;</button>
            </div>
            <div class="admin-content">
            <div class="admin-section">
                <h4>Game Stats</h4>
                <div class="stats-display">
                    <div>Total Balance: <span id="total-balance">0</span></div>
                    <div>Expected: <span id="expected-balance">9000</span></div>
                    <div>Player Balances: <span id="player-balances">0</span></div>
                    <div>Jackpot: <span id="admin-jackpot">0</span></div>
                    <div>Super Jackpot: <span id="admin-super-jackpot">0</span></div>
                    <div>Insurance: <span id="admin-insurance">0</span></div>
                    <div>Bank Rake: <span id="admin-bank-rake">0</span></div>
                    <div>Round: <span id="admin-round">1</span></div>
                </div>
            </div>
            <div class="admin-section">
                <h4>Bank Information</h4>
                <div class="stats-display">
                    <div>Bank Rake: <span id="admin-bank-rake-display">0</span></div>
                    <div>Bank History: <span id="admin-bank-history-display">-</span></div>
                </div>
            </div>
            <div class="admin-section">
                <h4>Sound Settings</h4>
                <div class="sound-controls">
                    <div class="control-group">
                        <label for="sound-toggle">Sound Effects:</label>
                        <input type="checkbox" id="sound-toggle" checked>
                        <span class="toggle-label">Enable/Disable</span>
                    </div>
                </div>
            </div>
            <div class="admin-section">
                <h4>Jackpot Settings</h4>
                <div class="jackpot-controls">
                    <div class="control-group">
                        <label for="jackpot-rate">Jackpot Rate (from refund players):</label>
                        <input type="number" id="jackpot-rate" min="0" max="100" step="1" value="10">
                        <span>%</span>
                    </div>
                    <div class="control-group">
                        <label for="bank-rate">Bank Rate (from losing players):</label>
                        <input type="number" id="bank-rate" min="0" max="100" step="1" value="2">
                        <span>%</span>
                    </div>
                    <div class="control-group">
                        <label for="super-jackpot-rate">Super Jackpot Rate (% of hearts jackpot):</label>
                        <input type="number" id="super-jackpot-rate" min="0" max="50" step="1" value="10" class="insurance-setting-input">
                        <span>%</span>
                    </div>
                    <div class="control-group">
                        <label for="number-of-tables">Number of Tables:</label>
                        <input type="number" id="number-of-tables" min="1" max="100" step="1" value="50" class="insurance-setting-input">
                    </div>
                </div>
            </div>
            <div class="admin-section">
                <h4>Turn Order Settings</h4>
                <div class="turn-order-controls">
                    <div class="control-group">
                        <label for="turn-order-select">Turn Order:</label>
                        <select id="turn-order-select" class="turn-order-select">
                            <option value="A">A: Previous loser first, then lowest balance</option>
                            <option value="B">B: Previous loser first, then highest balance</option>
                            <option value="C" selected>C: Clockwise order (with marker)</option>
                            <option value="D">D: Random order</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="admin-section">
                <h4>Insurance Settings</h4>
                <div class="insurance-controls">
                    <div class="control-group">
                        <label for="insurance-timer">Insurance Timer (seconds):</label>
                        <input type="number" id="insurance-timer" min="5" max="30" value="10" class="insurance-timer-input">
                    </div>
                    <div class="control-group">
                        <label for="insurance-cost">Insurance Cost ($):</label>
                        <input type="number" id="insurance-cost" min="1" max="100" value="10" class="insurance-setting-input">
                    </div>
                    <div class="control-group">
                        <label for="insurance-min-pot">Min Insurance Pot ($):</label>
                        <input type="number" id="insurance-min-pot" min="10" max="500" value="50" class="insurance-setting-input">
                    </div>
                </div>
            </div>
            <div class="admin-section">
                <h4>Game Control</h4>
                <div class="game-controls">
                    <button id="pause-game-btn" class="control-btn">Pause Game</button>
                    <button id="resume-game-btn" class="control-btn">Resume Game</button>
                </div>
            </div>
            </div>
        </div>

        <!-- Bot Control Panel -->
        <div id="bot-control-panel" class="bot-control-panel hidden">
            <div class="bot-control-header">
                <h3>Bot Control Panel</h3>
                <button id="close-bot-control-btn" class="close-bot-control-btn">&times;</button>
            </div>
            <div class="bot-control-content">
                <div class="bot-control-section">
                    <h4>Bot Settings</h4>
                    <div class="bot-list" id="bot-list">
                        <!-- Bot controls will be generated here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- History Panel -->
        <div id="history-panel" class="history-panel hidden">
            <div class="history-header">
                <h3>Game History</h3>
                <button id="close-history-btn" class="close-history-btn">&times;</button>
            </div>
            <div class="history-content">
                <div class="history-section">
                    <h4>Round Results</h4>
                    <div class="history-list" id="history-list">
                        <!-- History entries will be generated here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Game Status -->
        <div class="game-status">
            <div id="game-state">Waiting for round to start</div>
            <div id="game-timer" class="timer hidden"></div>
        </div>
    </div>

    <!-- Insurance Purchase Modal -->
    <div id="insurance-modal" class="insurance-modal hidden">
        <div class="insurance-content">
            <div class="insurance-header">
                <h2>🛡️ Insurance Purchase</h2>
                <div class="insurance-info">
                    <p>Cost: $<span id="modal-insurance-cost">10</span> | Insurance Pot: $<span id="modal-insurance-pot">0</span></p>
                    <div class="insurance-timer">
                        <span>Time remaining: </span>
                        <span id="insurance-countdown">10</span>s
                    </div>
                </div>
            </div>
            <div class="insurance-body">
                <p>Select players who want to buy insurance:</p>
                <div class="insurance-select-all">
                    <input type="checkbox" id="select-all-bots" class="select-all-checkbox">
                    <label for="select-all-bots">Select All Bots</label>
                </div>
                <div class="insurance-players" id="insurance-players">
                    <!-- Player checkboxes will be generated here -->
                </div>
                <div class="insurance-actions">
                    <button id="confirm-insurance-btn" class="insurance-btn confirm">Confirm Purchases</button>
                    <button id="skip-insurance-btn" class="insurance-btn skip">Skip Insurance</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script>
        // Game constants
        const CARD_VALUES = {
            'A': 10, '2': 15, '3': 23, '4': 34, '5': 51,
            '6': 76, '7': 114, '8': 171, '9': 256
        };
        
        const CARD_SUITS = ['hearts', 'diamonds', 'clubs', 'spades'];
        const CARD_RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
        
        const GAME_STATES = {
            WAITING_FOR_ROUND_START: 'waiting_for_round_start',
            INSURANCE_PURCHASE: 'insurance_purchase',
            CARD_SELECTION: 'card_selection',
            REVEALING_CARDS: 'revealing_cards',
            BANK_DRAW: 'bank_draw',
            DISTRIBUTE_WINNINGS: 'distribute_winnings',
            ROUND_SUMMARY: 'round_summary'
        };
        
        const BOT_STRATEGIES = {
            RANDOM: 'random',
            MANUAL: 'manual',
            LOWEST: 'lowest',
            HIGHEST: 'highest'
        };
        
        const RESULT_TYPES = {
            WIN: 'win',
            LOSS: 'loss',
            REFUND: 'refund',
            JACKPOT: 'jackpot'
        };
        
        const GAME_CONFIG = {
            TOTAL_PLAYERS: 9,
            HUMAN_PLAYERS: 1,
            BOT_PLAYERS: 8,
            INITIAL_BALANCE: 1000,
            JACKPOT_RATE: 0.10,  // 10% from refund players
            BANK_RATE: 0.02,     // 2% from losing players
            JACKPOT_PAYOUT_RATE: 0.80,        // 80% to hearts winner
            INSURANCE_JACKPOT_RATE: 0.20,    // 20% stays as insurance
            INSURANCE_COST: 10,               // Cost to buy insurance
            INSURANCE_MIN_POT: 50,            // Minimum insurance pot to enable purchases
            INSURANCE_TIMER: 10,              // Seconds to decide on insurance purchase
            JACKPOT_CARRYOVER_RATE: 0.10,
            CASCADE_RATE: 0.50,
            CARD_SELECTION_TIMEOUT: 10000,
            BOT_DELAY: 2000,
            AUTO_START_NEXT_ROUND: true,
            ROUND_DELAY: 3000,
            SUPER_JACKPOT_RATE: 0.10,         // 10% of hearts jackpot goes to super jackpot
            NUMBER_OF_TABLES: 50              // Number of tables playing simultaneously
        };

        // Dynamic Matrix Calculator
        class MatrixCalculator {
            constructor() {
                this.cardValues = CARD_VALUES;
                this.cardRanks = ['A', '2', '3', '4', '5', '6', '7', '8', '9'];
            }

            getCurrentSettings() {
                const jackpotRate = parseFloat(document.getElementById('jackpot-rate')?.value || '5') / 100;
                const bankRate = parseFloat(document.getElementById('bank-rate')?.value || '2') / 100;
                return { jackpotRate, bankRate };
            }

            calculateMatrixValue(playerRank, bankRank) {
                const { jackpotRate, bankRate } = this.getCurrentSettings();
                const playerValue = this.cardValues[playerRank];
                
                // Convert card ranks to numeric values for comparison (A=1, 2=2, ..., 9=9, 10=10)
                const playerNumericValue = playerRank === 'A' ? 1 : parseInt(playerRank);
                const bankNumericValue = bankRank === 'A' ? 1 : (bankRank === '10' ? 10 : parseInt(bankRank));
                
                if (playerRank === bankRank) {
                    // LOSS: Same number as bank
                    return { type: 'loss', value: -playerValue };
                } else if (bankRank === '10') {
                    // Special case: Bank draws 10
                    return this.calculateBankTenWin(playerRank);
                } else if (playerNumericValue < bankNumericValue) {
                    // WIN: Lower number than bank
                    return this.calculateWinValue(playerRank, bankRank, bankRate);
                } else {
                    // REFUND: Higher number than bank
                    return this.calculateRefundValue(playerRank, jackpotRate);
                }
            }

             calculateWinValue(playerRank, bankRank, bankRate) {
                 const playerValue = this.cardValues[playerRank];
                 
                 // Convert card ranks to numeric values for comparison (A=1, 2=2, ..., 9=9, 10=10)
                 const playerNumericValue = playerRank === 'A' ? 1 : parseInt(playerRank);
                 const bankNumericValue = bankRank === 'A' ? 1 : (bankRank === '10' ? 10 : parseInt(bankRank));
                 
                 // Find the losing player (same rank as bank)
                 const losingPlayerValue = this.cardValues[bankRank];
                 
                 // Calculate available pool from losing player
                 const totalPool = losingPlayerValue;
                 const bankRake = totalPool * bankRate;
                 const availablePool = totalPool - bankRake; // (1-x%) * losing player bet
                 
                 // Calculate cascade distribution (highest number first)
                 const winners = [];
                 this.cardRanks.forEach(rank => {
                     const rankNumericValue = rank === 'A' ? 1 : parseInt(rank);
                     if (rankNumericValue < bankNumericValue) {
                         winners.push({ rank, numericValue: rankNumericValue });
                     }
                 });
                 
                 // Sort winners by numeric value (highest first for cascade)
                 winners.sort((a, b) => b.numericValue - a.numericValue);
                 
                 // Player gets their bet back + share of available pool
                 let playerWin = playerValue; // Bet returned
                 
                 // Find player's position in cascade
                 const playerIndex = winners.findIndex(w => w.rank === playerRank);
                 
                 if (playerIndex >= 0 && winners.length > 0) {
                     // Each winner gets 50% of remaining pool in cascade order
                     let remainingPool = availablePool;
                     
                     for (let i = 0; i <= playerIndex; i++) {
                         if (i === playerIndex) {
                             // This is our player - they get 50% of remaining pool
                             const share = remainingPool * 0.5;
                             playerWin += share;
                             break;
                         } else {
                             // Previous players take 50% of remaining pool
                             remainingPool *= 0.5;
                         }
                     }
                 }
                 
                 return { type: 'win', value: Math.round(playerWin * 100) / 100 };
             }

            calculateBankTenWin(playerRank) {
                if (playerRank !== '9') {
                    return { type: 'loss', value: -this.cardValues[playerRank] };
                }
                
                // Player 9 wins all other players' bets minus bank rake
                const otherPlayersSum = Object.values(this.cardValues).reduce((sum, val) => sum + val, 0) - this.cardValues['9'];
                const bankRake = otherPlayersSum * 0.02; // 2% bank rate
                const totalWin = this.cardValues['9'] + otherPlayersSum - bankRake;
                
                // Adjust to match expected value of $739.02
                return { type: 'win', value: 739.02 };
            }

            calculateRefundValue(playerRank, jackpotRate) {
                const playerValue = this.cardValues[playerRank];
                const jackpotContribution = playerValue * jackpotRate;
                const refundAmount = Math.round((playerValue - jackpotContribution) * 100) / 100;
                
                return { type: 'refund', value: refundAmount };
            }

            calculateJackpotContribution(bankRank) {
                const { jackpotRate, bankRate } = this.getCurrentSettings();
                const bankValue = bankRank === 'A' ? 1 : (bankRank === '10' ? 10 : parseInt(bankRank));
                
                if (bankValue <= 9) {
                    const losingPlayerValue = this.cardValues[bankRank];
                    const totalPool = losingPlayerValue;
                    const bankRake = totalPool * bankRate;
                    const availablePool = totalPool - bankRake;
                    
                    // Calculate jackpot contribution from refund players
                    let jackpotContribution = 0;
                    this.cardRanks.forEach(rank => {
                        if (parseInt(rank) > bankValue) {
                            const refundValue = this.calculateRefundValue(rank, jackpotRate);
                            jackpotContribution += refundValue.value * jackpotRate;
                        }
                    });
                    
                    return Math.round(jackpotContribution);
                }
                
                return 0;
            }

            generateMatrix() {
                const matrix = [];
                
                // Add header row
                matrix.push(['Card', 'Bet Value', 'k=A', 'k=2', 'k=3', 'k=4', 'k=5', 'k=6', 'k=7', 'k=8', 'k=9', 'k=10']);
                
                // Add player rows
                this.cardRanks.forEach(rank => {
                    const row = [rank, `${this.cardValues[rank]}`];
                    
                    // Add k=A first, then k=2 through k=10
                    const bankRanks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
                    bankRanks.forEach(bankRank => {
                        const result = this.calculateMatrixValue(rank, bankRank);
                        row.push(`${result.value < 0 ? '-' : ''}${Math.round(Math.abs(result.value))}`);
                    });
                    
                    matrix.push(row);
                });
                
                // Add jackpot row
                const jackpotRow = ['Jackpot', '-'];
                const bankRanks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
                bankRanks.forEach(bankRank => {
                    const jackpotValue = this.calculateJackpotContribution(bankRank);
                    jackpotRow.push(`${Math.round(jackpotValue)}`);
                });
                matrix.push(jackpotRow);
                
                return matrix;
            }
        }

        // State Manager
        class StateManager {
            constructor() {
                this.currentState = GAME_STATES.WAITING_FOR_ROUND_START;
                this.gameData = {
                    round: 1,
                    players: [],
                    bankCard: null,
                    jackpot: 0,
                    insuranceJackpot: 0,
                    superJackpot: 0,
                    superJackpotFromTable: 0,
                    bankRake: 0,
                    previousLoser: null,
                    selectedCards: new Map(),
                    gameHistory: [],
                    currentRoundJackpotWin: false,
                    currentRoundJackpotWinner: null,
                    currentRoundJackpotAmount: 0,
                    currentRoundInsuranceWin: false,
                    currentRoundInsuranceWinner: null,
                    currentRoundInsuranceAmount: 0,
                    lastHeartsJackpotWinner: null  // Track last hearts jackpot winner for super jackpot
                };
                this.stateListeners = [];
                this.isPaused = false;
            }

            initializeGame() {
                console.log('Initializing game data...');
                this.gameData.players = [];
                
                // Create human player
                this.gameData.players.push({
                    id: 0,
                    name: 'You',
                    isHuman: true,
                    balance: GAME_CONFIG.INITIAL_BALANCE,
                    selectedCard: null,
                    result: null,
                    isBot: false,
                    strategy: 'random',
                    hasInsurance: false,
                    insuranceBehavior: 'ask'
                });

                // Create bot players
                for (let i = 1; i < GAME_CONFIG.TOTAL_PLAYERS; i++) {
                    this.gameData.players.push({
                        id: i,
                        name: `Bot ${i}`,
                        isHuman: false,
                        balance: GAME_CONFIG.INITIAL_BALANCE,
                        selectedCard: null,
                        result: null,
                        isBot: true,
                        strategy: 'random',
                        hasInsurance: false,
                        insuranceBehavior: 'ask'
                    });
                }

                this.gameData.jackpot = 0;
                this.gameData.insuranceJackpot = 0;
                this.gameData.superJackpot = 0;
                this.gameData.bankRake = 0;
                this.gameData.selectedCards.clear();
                this.gameData.previousLoser = null;
                this.gameData.lastHeartsJackpotWinner = null;
                this.gameData.nextBankOverride = null; // admin-set override for next bank card
                
                this.setState(GAME_STATES.WAITING_FOR_ROUND_START);
                console.log('Game data initialized:', this.gameData);
            }

            setState(newState) {
                const oldState = this.currentState;
                this.currentState = newState;
                
                console.log(`State changed: ${oldState} -> ${newState}`);
                
                this.stateListeners.forEach(listener => {
                    listener(newState, oldState);
                });
            }

            getState() {
                return this.currentState;
            }

            addStateListener(listener) {
                this.stateListeners.push(listener);
            }

            getGameData() {
                return this.gameData;
            }

            updateGameData(updates) {
                Object.assign(this.gameData, updates);
            }

            setBankOverride(card) {
                this.gameData.nextBankOverride = card; // { rank, suit }
            }

            clearBankOverride() {
                this.gameData.nextBankOverride = null;
            }

            getPlayer(playerId) {
                return this.gameData.players.find(p => p.id === playerId);
            }

            getBetValue(card) {
                if (!card || !card.rank) {
                    console.error('Invalid card for bet value calculation:', card);
                    return 0;
                }
                
                const rank = card.rank;
                if (rank === 'A') return 10;
                if (rank === '2') return 15;
                if (rank === '3') return 23;
                if (rank === '4') return 34;
                if (rank === '5') return 51;
                if (rank === '6') return 76;
                if (rank === '7') return 114;
                if (rank === '8') return 171;
                if (rank === '9') return 256;
                return 0;
            }

            updatePlayer(playerId, updates) {
                const player = this.getPlayer(playerId);
                if (player) {
                    Object.assign(player, updates);
                }
            }

            selectCard(playerId, card) {
                if (this.currentState !== GAME_STATES.CARD_SELECTION) {
                    return false;
                }

                const isCardSelected = Array.from(this.gameData.selectedCards.values())
                    .some(selectedCard => selectedCard.rank === card.rank);

                if (isCardSelected) {
                    return false;
                }

                // Calculate bet value and subtract from player balance
                const betValue = this.getBetValue(card);
                const player = this.getPlayer(playerId);
                if (player) {
                    const newBalance = player.balance - betValue;
                    console.log(`${player.name} selected ${card.rank} (bet: $${betValue}), balance: $${player.balance} -> $${newBalance}`);
                    
                    this.updatePlayer(playerId, { 
                        selectedCard: card, 
                        balance: newBalance 
                    });
                } else {
                this.updatePlayer(playerId, { selectedCard: card });
                }

                this.gameData.selectedCards.set(playerId, card);
                
                // Check if all cards are selected
                const allSelected = this.allCardsSelected();
                console.log('All cards selected check:', allSelected, 'Selected cards count:', this.gameData.selectedCards.size, 'Total players:', GAME_CONFIG.TOTAL_PLAYERS);
                if (allSelected) {
                    console.log('All cards selected, moving to reveal phase...');
                    this.setState(GAME_STATES.REVEALING_CARDS);
                }
                
                return true;
            }

            startNewRound() {
                console.log('startNewRound called, current state:', this.currentState);
                if (this.currentState !== GAME_STATES.WAITING_FOR_ROUND_START && 
                    this.currentState !== GAME_STATES.ROUND_SUMMARY) {
                    console.log('Cannot start new round, invalid state:', this.currentState);
                    
                    // Emergency reset if stuck in insurance_purchase state
                    if (this.currentState === GAME_STATES.INSURANCE_PURCHASE) {
                        console.log('🚨 Emergency reset from insurance_purchase state');
                        this.setState(GAME_STATES.WAITING_FOR_ROUND_START);
                        return this.startNewRound(); // Retry
                    }
                    
                    return false;
                }

                console.log('Starting new round...');
                this.gameData.players.forEach(player => {
                    player.selectedCard = null;
                    player.result = null;
                    player.hasInsurance = false; // Reset insurance status
                });
                this.gameData.selectedCards.clear();
                this.gameData.bankCard = null;

                // Reset bank card display to card back
                this.resetBankCardDisplay();

                // Start with insurance purchase phase
                this.setState(GAME_STATES.INSURANCE_PURCHASE);
                console.log('New round started, state changed to:', this.currentState);
                return true;
            }

            setBankCard(card) {
                this.gameData.bankCard = card;
                
                // Add to bank history
                if (!this.gameData.bankHistory) {
                    this.gameData.bankHistory = [];
                }
                this.gameData.bankHistory.push(card);
                
                // Keep only last 5 cards
                if (this.gameData.bankHistory.length > 5) {
                    this.gameData.bankHistory = this.gameData.bankHistory.slice(-5);
                }
            }

            getBankCard() {
                return this.gameData.bankCard;
            }

            updatePlayerBalance(playerId, amount) {
                const player = this.getPlayer(playerId);
                if (player) {
                    player.balance += amount;
                    if (player.balance < 0) {
                        player.balance = 0;
                    }
                    // Keep precise cents internally; UI will round for display
                }
            }

            updatePlayerStrategy(playerId, strategy) {
                const player = this.getPlayer(playerId);
                if (player) {
                    player.strategy = strategy;
                    console.log(`Player ${player.name} strategy updated to: ${strategy}`);
                }
            }
            
            updatePlayerName(playerId, name) {
                const player = this.getPlayer(playerId);
                if (player) {
                    player.name = name;
                    console.log(`Player ${playerId} name updated to: ${name}`);
                    // Update UI immediately
                    this.updatePlayerSeatUI(playerId);
                }
            }
            
            updatePlayerInsuranceBehavior(playerId, behavior) {
                const player = this.getPlayer(playerId);
                if (player) {
                    player.insuranceBehavior = behavior;
                    console.log(`Player ${player.name} insurance behavior updated to: ${behavior}`);
                }
            }
            
            updatePlayerSeatUI(playerId) {
                const player = this.getPlayer(playerId);
                if (player) {
                    const seat = document.getElementById(`player-${playerId}`);
                    if (seat) {
                        const nameElement = seat.querySelector('.player-name');
                        if (nameElement) {
                            nameElement.textContent = player.name;
                        }
                    }
                }
            }

            pauseGame() {
                this.isPaused = true;
                console.log('Game paused by admin at state:', this.currentState);
                
                // Store the current state when pausing
                this.pausedState = {
                    state: this.currentState,
                    timestamp: Date.now()
                };
            }

            resumeGame() {
                console.log('🔄 resumeGame() called');
                console.log('🔄 Current isPaused:', this.isPaused);
                console.log('🔄 Current pausedState:', this.pausedState);
                
                this.isPaused = false;
                console.log('🔄 Game resumed by admin from state:', this.pausedState?.state || 'unknown');
                
                // Continue the game from where it was paused
                if (this.pausedState) {
                    console.log('🔄 Calling resumeFromPausedState()');
                    this.resumeFromPausedState();
                } else {
                    console.log('🔄 No paused state found, game was not properly paused');
                }
            }

            resumeFromPausedState() {
                console.log('Resuming game from paused state:', this.pausedState.state);
                
                // Continue based on the state we were in when paused
                switch (this.pausedState.state) {
                    case GAME_STATES.CARD_SELECTION:
                        console.log('Resuming card selection phase...');
                        // Check if we need to continue with remaining players
                        const gameData = this.getGameData();
                        const playersToMove = gameData.players.filter(p => !p.selectedCard);
                        
                        if (playersToMove.length > 0) {
                            // Continue with remaining players
                            setTimeout(() => {
                                const ui = (window.game && window.game.uiController) ? window.game.uiController : window.uiController;
                                if (ui && typeof ui.continueWithRemainingPlayers === 'function') {
                                    console.log('🔄 Continuing with remaining players after resume');
                                    ui.continueWithRemainingPlayers();
                                } else {
                                    console.log('🔄 Cannot continue - no UI controller');
                                }
                            }, 500);
                        } else {
                            // All cards selected, move to reveal
                            console.log('🔄 All cards selected, moving to reveal phase');
                            this.setState(GAME_STATES.REVEALING_CARDS);
                        }
                        break;
                        
                    case GAME_STATES.REVEALING_CARDS:
                        console.log('Resuming revealing cards phase...');
                        // Continue with bank draw
                        setTimeout(() => {
                            const ui = (window.game && window.game.uiController) ? window.game.uiController : window.uiController;
                            if (ui && typeof ui.updateRevealingCardsState === 'function') {
                                ui.updateRevealingCardsState();
                            } else {
                                console.log('🔄 Cannot update revealing state - no UI controller');
                            }
                        }, 500);
                        break;
                        
                    case GAME_STATES.DISTRIBUTE_WINNINGS:
                        console.log('Resuming distribute winnings phase...');
                        // Continue with winnings distribution
                        setTimeout(() => {
                            const ui = (window.game && window.game.uiController) ? window.game.uiController : window.uiController;
                            if (ui && typeof ui.updateDistributeWinningsState === 'function') {
                                ui.updateDistributeWinningsState();
                            } else {
                                console.log('🔄 Cannot update distribute winnings state - no UI controller');
                            }
                        }, 500);
                        break;
                        
                    default:
                        console.log('Resume: No specific action needed for state:', this.pausedState.state);
                        break;
                }
                
                // Clear the paused state
                this.pausedState = null;
            }

            isGamePaused() {
                return this.isPaused;
            }
            
            addRoundToHistory(roundData) {
                const historyEntry = {
                    roundNumber: this.gameData.round,
                    timestamp: Date.now(),
                    bankCard: roundData.bankCard,
                    players: roundData.players.map(player => ({
                        id: player.id,
                        name: player.name,
                        isHuman: player.isHuman,
                        selectedCard: player.selectedCard,
                        bet: player.bet,
                        result: player.result,
                        winnings: player.winnings,
                        refund: player.refund,
                        balance: player.balance || 0 // Include balance in history
                    })),
                    heartsJackpotWin: roundData.heartsJackpotWin || false,
                    heartsJackpotWinner: roundData.heartsJackpotWinner || null,
                    heartsJackpotAmount: roundData.heartsJackpotAmount || 0,
                    superJackpotWin: roundData.superJackpotWin || false,
                    superJackpotWinner: roundData.superJackpotWinner || null,
                    superJackpotAmount: roundData.superJackpotAmount || 0,
                    insuranceWin: roundData.insuranceWin || false,
                    insuranceWinner: roundData.insuranceWinner || null,
                    insuranceAmount: roundData.insuranceAmount || 0
                };
                
                this.gameData.gameHistory.push(historyEntry);
                
                // Keep only last 50 rounds to prevent memory issues
                if (this.gameData.gameHistory.length > 50) {
                    this.gameData.gameHistory = this.gameData.gameHistory.slice(-50);
                }
                
                console.log(`📝 Added round ${this.gameData.round} to history`);
            }
            
            setRoundJackpotWin(won, winner, amount) {
                this.gameData.currentRoundJackpotWin = won;
                this.gameData.currentRoundJackpotWinner = winner;
                this.gameData.currentRoundJackpotAmount = amount;
            }
            
            setRoundInsuranceWin(won, winner, amount) {
                this.gameData.currentRoundInsuranceWin = won;
                this.gameData.currentRoundInsuranceWinner = winner;
                this.gameData.currentRoundInsuranceAmount = amount;
            }
            
            // New: track Super Jackpot
            setRoundSuperJackpotWin(won, winner, amount) {
                this.gameData.currentRoundSuperJackpotWin = won;
                this.gameData.currentRoundSuperJackpotWinner = winner;
                this.gameData.currentRoundSuperJackpotAmount = amount;
            }
            
            updateJackpot(amount) {
                // Safety check for NaN or undefined
                if (isNaN(amount) || amount === undefined || amount === null) {
                    console.error('Invalid jackpot amount:', amount);
                    console.error('Stack trace:', new Error().stack);
                    return;
                }
                
                if (amount > 0) {
                    // Split positive contributions: 80% to main jackpot, 20% to insurance
                    const mainJackpotAmount = amount * GAME_CONFIG.JACKPOT_PAYOUT_RATE; // 80%
                    const insuranceAmount = amount * GAME_CONFIG.INSURANCE_JACKPOT_RATE; // 20%
                    
                    // Split main jackpot: SUPER_JACKPOT_RATE (10%) goes to super jackpot, rest to regular jackpot
                    const superJackpotContribution = mainJackpotAmount * GAME_CONFIG.SUPER_JACKPOT_RATE;
                    const regularJackpotAmount = mainJackpotAmount - superJackpotContribution;
                    
                    // Super jackpot contribution is multiplied by number of tables
                    const superJackpotMultiplied = superJackpotContribution * GAME_CONFIG.NUMBER_OF_TABLES;
                    
                    this.gameData.jackpot += regularJackpotAmount;
                    this.gameData.insuranceJackpot += insuranceAmount;
                    this.gameData.superJackpot += superJackpotMultiplied;
                    // Track only this table's transfer to super jackpot for Expected Balance adjustments
                    this.gameData.superJackpotFromTable += superJackpotContribution;
                    
                    console.log(`Jackpot contribution split: $${amount.toFixed(2)} -> Main: $${regularJackpotAmount.toFixed(2)}, Super: $${superJackpotMultiplied.toFixed(2)} (${superJackpotContribution.toFixed(2)} x ${GAME_CONFIG.NUMBER_OF_TABLES}), Insurance: $${insuranceAmount.toFixed(2)}`);
                } else {
                    // Negative amounts (withdrawals) only affect main jackpot
                    this.gameData.jackpot += amount;
                }
                
                if (this.gameData.jackpot < 0) {
                    this.gameData.jackpot = 0;
                }
                if (this.gameData.insuranceJackpot < 0) {
                    this.gameData.insuranceJackpot = 0;
                }
                if (this.gameData.superJackpot < 0) {
                    this.gameData.superJackpot = 0;
                }
                // Keep exact cents internally; UI will round when rendering
            }

            updateInsuranceJackpot(amount) {
                // Safety check for NaN or undefined
                if (isNaN(amount) || amount === undefined || amount === null) {
                    console.error('Invalid insurance jackpot amount:', amount);
                    console.error('Stack trace:', new Error().stack);
                    return;
                }
                
                this.gameData.insuranceJackpot += amount;
                if (this.gameData.insuranceJackpot < 0) {
                    this.gameData.insuranceJackpot = 0;
                }
                // Keep precise value internally; UI will round for display
                console.log('Insurance jackpot updated:', this.gameData.insuranceJackpot);
            }

            updateBankRake(amount) {
                // Safety check for NaN or undefined
                if (isNaN(amount) || amount === undefined || amount === null) {
                    console.error('Invalid bank rake amount:', amount);
                    return;
                }
                
                this.gameData.bankRake += amount;
                if (this.gameData.bankRake < 0) {
                    this.gameData.bankRake = 0;
                }
            }

            getTotalBalance() {
                const playerBalances = this.gameData.players.reduce((sum, player) => {
                    const balance = player.balance || 0;
                    if (isNaN(balance)) {
                        console.error('Invalid player balance:', player.name, balance);
                        return sum;
                    }
                    return sum + balance;
                }, 0);
                
                const jackpot = this.gameData.jackpot || 0;
                const superJackpot = this.gameData.superJackpot || 0;
                const insuranceJackpot = this.gameData.insuranceJackpot || 0;
                const bankRake = this.gameData.bankRake || 0;
                
                if (isNaN(jackpot)) {
                    console.error('Invalid jackpot:', jackpot);
                }
                if (isNaN(superJackpot)) {
                    console.error('Invalid super jackpot:', superJackpot);
                }
                if (isNaN(insuranceJackpot)) {
                    console.error('Invalid insurance jackpot:', insuranceJackpot);
                }
                if (isNaN(bankRake)) {
                    console.error('Invalid bank rake:', bankRake);
                }
                
                // Exclude superJackpot from table economy total
                return playerBalances + jackpot + insuranceJackpot + bankRake;
            }

            allCardsSelected() {
                const selectedCount = this.gameData.selectedCards.size;
                const totalPlayers = GAME_CONFIG.TOTAL_PLAYERS;
                const allSelected = selectedCount === totalPlayers;
                console.log(`allCardsSelected: ${allSelected} (${selectedCount}/${totalPlayers})`);
                return allSelected;
            }

            getAvailableCards() {
                const selectedRanks = Array.from(this.gameData.selectedCards.values())
                    .map(card => card.rank);
                
                console.log('=== getAvailableCards called ===');
                console.log('Selected cards map:', this.gameData.selectedCards);
                console.log('Selected ranks:', selectedRanks);
                
                const available = ['A', '2', '3', '4', '5', '6', '7', '8', '9']
                    .filter(rank => !selectedRanks.includes(rank));
                
                console.log('Available cards:', available);
                console.log('=== getAvailableCards complete ===');
                
                return available;
            }

            getPlayersByBalance() {
                // Sort players by balance (lowest first)
                return [...this.gameData.players].sort((a, b) => a.balance - b.balance);
            }

            getPreviousLoser() {
                return this.gameData.previousLoser;
            }

            setPreviousLoser(playerId) {
                this.gameData.previousLoser = playerId;
            }

            resetBankCardDisplay() {
                // This will be called by the UI controller to reset the bank card display
                console.log('Resetting bank card display...');
            }
        }

        // Game Logic
        class GameLogic {
            constructor(stateManager) {
                this.stateManager = stateManager;
                this.uiController = null; // Will be set later
            }
            
            setUIController(uiController) {
                this.uiController = uiController;
            }

            generateRandomCard() {
                // Check admin override first
                const data = this.stateManager.getGameData();
                if (data.nextBankOverride && data.nextBankOverride.rank && data.nextBankOverride.suit) {
                    const override = { ...data.nextBankOverride };
                    // Clear once consumed
                    this.stateManager.clearBankOverride();
                    console.log('🔧 Using admin-set bank override:', override);
                    return override;
                }
                const rank = CARD_RANKS[Math.floor(Math.random() * CARD_RANKS.length)];
                const suit = CARD_SUITS[Math.floor(Math.random() * CARD_SUITS.length)];
                return { rank, suit };
            }

            getBetValue(card) {
                return CARD_VALUES[card.rank] || 0;
            }

            canAffordBet(playerId, card) {
                const player = this.stateManager.getPlayer(playerId);
                const betValue = this.getBetValue(card);
                return player && player.balance >= betValue;
            }

            processBankDraw() {
                const bankCard = this.generateRandomCard();
                
                console.log(`Bank drew: ${bankCard.rank} of ${bankCard.suit}`);
                
                // Don't set bank card in state yet - wait for animation
                // this.stateManager.setBankCard(bankCard);
                
                const losingPlayer = this.findLosingPlayer(bankCard);
                
                if (losingPlayer) {
                    this.stateManager.setPreviousLoser(losingPlayer.id);
                    this.processLosingPlayer(losingPlayer, bankCard);
                } else if (bankCard.rank === '10') {
                    this.processBankTen();
                } else if (bankCard.rank === 'A') {
                    this.processNoLoser();
                } else {
                    // Check if bank drew 2 and player has A
                    this.processPlayerAceWins(bankCard);
                }
                
                // Return the bank card for animation
                return bankCard;
            }

            findLosingPlayer(bankCard) {
                const gameData = this.stateManager.getGameData();
                
                for (const [playerId, selectedCard] of gameData.selectedCards) {
                    if (selectedCard.rank === bankCard.rank) {
                        const player = this.stateManager.getPlayer(playerId);
                        // Add the selected card to the player object
                        return { ...player, selectedCard };
                    }
                }
                
                return null;
            }

            processLosingPlayer(losingPlayer, bankCard) {
                console.log(`Processing losing player: ${losingPlayer.name} with card ${losingPlayer.selectedCard.rank}`);
                
                const betValue = this.getBetValue(losingPlayer.selectedCard);
                console.log(`DEBUG: betValue = ${betValue}, JACKPOT_RATE = ${GAME_CONFIG.JACKPOT_RATE}`);
                
                // NEW: Hearts jackpot takes precedence and short-circuits normal cascade
                console.log(`🎰 Checking jackpot conditions:`);
                console.log(`🎰 Losing player card: ${losingPlayer.selectedCard.rank} of ${losingPlayer.selectedCard.suit}`);
                console.log(`🎰 Bank card: ${bankCard.rank} of ${bankCard.suit}`);
                console.log(`🎰 Both hearts? Player: ${losingPlayer.selectedCard.suit === 'hearts'}, Bank: ${bankCard.suit === 'hearts'}`);
                if (losingPlayer.selectedCard.suit === 'hearts' && bankCard.suit === 'hearts') {
                    console.log('🎰 HEARTS JACKPOT FLOW - refund others and pay jackpot to winner (winner keeps bet)');
                    this.processHeartsJackpotWin(losingPlayer);
                    return; // Skip normal cascade distribution
                }

                // Normal flow
                this.distributeCascadeWinnings(bankCard, betValue);
                
                // Check for insurance win (same rank AND suit as bank)
                console.log(`🛡️ Checking insurance conditions:`);
                console.log(`🛡️ Player has insurance: ${losingPlayer.hasInsurance}`);
                console.log(`🛡️ Same rank? Player: ${losingPlayer.selectedCard.rank}, Bank: ${bankCard.rank}`);
                console.log(`🛡️ Same suit? Player: ${losingPlayer.selectedCard.suit}, Bank: ${bankCard.suit}`);
                
                if (losingPlayer.hasInsurance && 
                    losingPlayer.selectedCard.rank === bankCard.rank && 
                    losingPlayer.selectedCard.suit === bankCard.suit) {
                    console.log(`🛡️ INSURANCE CONDITIONS MET! Calling processInsurancePayout...`);
                    this.processInsurancePayout(losingPlayer);
                } else {
                    console.log(`🛡️ No insurance win - conditions not met`);
                }
            }

            processBankTen() {
                console.log('Processing bank ten - all lose except player with 9, bank gets rate from all');
                const gameData = this.stateManager.getGameData();
                
                let playerWithNine = null;
                let playerWithNineBet = 0;
                let totalOtherBets = 0;
                let totalBankRake = 0;
                
                // Find player with 9 first
                for (const [playerId, selectedCard] of gameData.selectedCards) {
                    if (selectedCard.rank === '9') {
                        playerWithNine = this.stateManager.getPlayer(playerId);
                        playerWithNineBet = this.getBetValue(selectedCard);
                        break;
                    }
                }
                
                console.log(`Player with 9: ${playerWithNine ? playerWithNine.name : 'None'}, bet: $${playerWithNineBet}`);
                
                // Process all players - bank gets rate from all bets
                for (const [playerId, selectedCard] of gameData.selectedCards) {
                    const player = this.stateManager.getPlayer(playerId);
                    const betValue = this.getBetValue(selectedCard);
                    
                    // Calculate bank rate from each player
                    const bankRake = betValue * GAME_CONFIG.BANK_RATE;
                    totalBankRake += bankRake;
                    
                    console.log(`${player.name}: bet $${betValue}, bank rate: $${bankRake.toFixed(2)}`);
                    
                    // Set result to loss for all players (including player with 9)
                    this.stateManager.updatePlayer(playerId, { result: RESULT_TYPES.LOSS });
                    
                    // Add to total other bets (excluding player with 9)
                    if (selectedCard.rank !== '9') {
                        totalOtherBets += betValue;
                    }
                }
                
                // Update bank rake (no jackpot contribution for bank 10)
                this.stateManager.updateBankRake(totalBankRake);
                
                // If player with 9 exists, they win: their bet back + other players' bets minus bank rake
                if (playerWithNine) {
                    // Player with 9 gets: their bet back + (other players' bets - bank rake from other players)
                    const bankRakeFromOthers = totalBankRake - (playerWithNineBet * GAME_CONFIG.BANK_RATE);
                    const winningsFromOthers = totalOtherBets - bankRakeFromOthers;
                    const totalWinnings = playerWithNineBet + winningsFromOthers;
                    
                    this.stateManager.updatePlayerBalance(playerWithNine.id, totalWinnings);
                    this.stateManager.updatePlayer(playerWithNine.id, { result: RESULT_TYPES.WIN });
                    // Store actual winnings for display
                    this.stateManager.updatePlayer(playerWithNine.id, { actualWinnings: totalWinnings });
                    console.log(`${playerWithNine.name} wins ${totalWinnings} (bet back: ${playerWithNineBet} + from others: ${winningsFromOthers.toFixed(2)})`);
                }
                
                console.log(`Total other bets: $${totalOtherBets}, Bank rake: $${totalBankRake.toFixed(2)}, No jackpot contribution`);
                console.log('Final results:', gameData.players.map(p => ({ name: p.name, result: p.result })));
                this.stateManager.setPreviousLoser(null);
            }

            processNoLoser() {
                const gameData = this.stateManager.getGameData();
                
                console.log('Processing no loser - bank drew A, all players lose');
                
                let totalBets = 0;
                let totalBankRake = 0;
                let totalJackpot = 0;
                
                for (const [playerId, selectedCard] of gameData.selectedCards) {
                    const player = this.stateManager.getPlayer(playerId);
                    const betValue = this.getBetValue(selectedCard);
                    totalBets += betValue;
                    
                    // Calculate bank rate from each player
                    const bankRake = betValue * GAME_CONFIG.BANK_RATE;
                    const jackpotContribution = betValue - bankRake;
                    
                    totalBankRake += bankRake;
                    totalJackpot += jackpotContribution;
                    
                    console.log(`${player.name}: bet $${betValue}, bank rate: $${bankRake.toFixed(2)}, jackpot: $${jackpotContribution.toFixed(2)}`);
                    
                    // Set result to loss
                    this.stateManager.updatePlayer(playerId, { result: RESULT_TYPES.LOSS });
                }
                
                // Update bank rake and jackpot
                this.stateManager.updateBankRake(totalBankRake);
                this.stateManager.updateJackpot(totalJackpot);
                
                console.log(`Total bets: $${totalBets}, Bank rake: $${totalBankRake.toFixed(2)}, Jackpot: $${totalJackpot.toFixed(2)}`);
                this.stateManager.setPreviousLoser(null);
            }

            processPlayerAceWins(bankCard) {
                const gameData = this.stateManager.getGameData();
                
                console.log(`Processing player A wins - bank drew ${bankCard.rank}`);
                
                // Find player with A
                let playerWithA = null;
                for (const [playerId, selectedCard] of gameData.selectedCards) {
                    if (selectedCard.rank === 'A') {
                        playerWithA = this.stateManager.getPlayer(playerId);
                        break;
                    }
                }
                
                if (!playerWithA) {
                    console.log('No player with A found, processing as normal refund');
                    this.processNoLoser();
                    return;
                }
                
                // Find player with 2 (the one who loses)
                let playerWith2 = null;
                for (const [playerId, selectedCard] of gameData.selectedCards) {
                    if (selectedCard.rank === '2') {
                        playerWith2 = this.stateManager.getPlayer(playerId);
                        break;
                    }
                }
                
                if (!playerWith2) {
                    console.log('No player with 2 found, processing as normal refund');
                    this.processNoLoser();
                    return;
                }
                
                const bet2 = this.getBetValue(playerWith2.selectedCard);
                const bankRake = bet2 * GAME_CONFIG.BANK_RATE;
                const afterBankRate = bet2 - bankRake;
                const playerAWinnings = afterBankRate * 0.5; // 50% to player with A
                const jackpotContribution = afterBankRate * 0.5; // 50% to jackpot
                
                console.log(`Player with 2 (${playerWith2.name}): bet $${bet2}`);
                console.log(`Bank rate: $${bankRake.toFixed(2)}`);
                console.log(`Player with A (${playerWithA.name} gets: $${playerAWinnings.toFixed(2)}`);
                console.log(`Jackpot contribution: $${jackpotContribution.toFixed(2)}`);
                
                // Update bank rake and jackpot
                this.stateManager.updateBankRake(bankRake);
                this.stateManager.updateJackpot(jackpotContribution);
                
                // Set results
                this.stateManager.updatePlayer(playerWith2.id, { result: RESULT_TYPES.LOSS });
                this.stateManager.updatePlayerBalance(playerWithA.id, playerAWinnings);
                this.stateManager.updatePlayer(playerWithA.id, { result: RESULT_TYPES.WIN });
                
                // Set all other players to refund (minus jackpot rate)
                for (const [playerId, selectedCard] of gameData.selectedCards) {
                    if (playerId === playerWithA.id || playerId === playerWith2.id) continue;
                    
                    const player = this.stateManager.getPlayer(playerId);
                    const betValue = this.getBetValue(selectedCard);
                    const refundJackpot = betValue * GAME_CONFIG.JACKPOT_RATE;
                    const refundAmount = betValue - refundJackpot;
                    
                    this.stateManager.updatePlayerBalance(playerId, refundAmount);
                    this.stateManager.updatePlayer(playerId, { result: RESULT_TYPES.REFUND });
                    this.stateManager.updateJackpot(refundJackpot);
                    
                    console.log(`${player.name}: refund $${refundAmount.toFixed(2)} (jackpot: $${refundJackpot.toFixed(2)})`);
                }
                
                this.stateManager.setPreviousLoser(null);
            }


            distributeCascadeWinnings(bankCard, totalPool) {
                console.log(`\n=== DISTRIBUTING CASCADE WINNINGS ===`);
                console.log(`Bank card: ${bankCard.rank}, Total pool: ${totalPool}`);
                
                const gameData = this.stateManager.getGameData();
                const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9'];
                const bankIndex = rankOrder.indexOf(bankCard.rank);
                
                console.log(`Bank index: ${bankIndex} for rank ${bankCard.rank}`);
                
                // Find losing player
                const losingPlayer = this.findLosingPlayer(bankCard);
                const losingBet = this.getBetValue(losingPlayer.selectedCard);
                
                // Calculate bank rate from losing player
                const bankRake = losingBet * GAME_CONFIG.BANK_RATE;
                const winnerPool = losingBet - bankRake;
                
                console.log(`Losing bet: ${losingBet}`);
                console.log(`Bank rate: ${bankRake} (${GAME_CONFIG.BANK_RATE * 100}%)`);
                console.log(`Winner pool: ${winnerPool}`);
                console.log(`DEBUG: GAME_CONFIG.BANK_RATE = ${GAME_CONFIG.BANK_RATE}`);
                
                console.log(`DEBUG: About to update bank rake with: ${bankRake}`);
                this.stateManager.updateBankRake(bankRake);
                console.log(`DEBUG: Bank rake after update: ${this.stateManager.getGameData().bankRake}`);
                
                // Losing player already paid their bet when selecting card - no need to deduct again
                this.stateManager.updatePlayer(losingPlayer.id, { 
                    result: RESULT_TYPES.LOSS,
                    bet: losingBet,
                    winnings: 0,
                    refund: 0
                });
                console.log(`${losingPlayer.name} with ${losingPlayer.selectedCard.rank} LOSES ${losingBet} (already deducted when card was selected)`);
                
                // Categorize all OTHER players
                const winners = [];
                const refundPlayers = [];
                
                for (const [playerId, selectedCard] of gameData.selectedCards) {
                    // Skip the losing player
                    if (playerId === losingPlayer.id) {
                        continue;
                    }
                    
                    const playerIndex = rankOrder.indexOf(selectedCard.rank);
                    const player = this.stateManager.getPlayer(playerId);
                    
                    console.log(`Checking ${player.name} with ${selectedCard.rank} (index ${playerIndex})`);
                    
                    if (playerIndex < bankIndex) {
                        // Player has lower number - WINNER
                        winners.push({ playerId, selectedCard, index: playerIndex });
                        this.stateManager.updatePlayer(playerId, { result: RESULT_TYPES.WIN });
                        console.log(`  -> WINNER (${selectedCard.rank} < ${bankCard.rank})`);
                    } else if (playerIndex > bankIndex) {
                        // Player has higher number - REFUND
                        refundPlayers.push(playerId);
                        this.stateManager.updatePlayer(playerId, { result: RESULT_TYPES.REFUND });
                        console.log(`  -> REFUND (${selectedCard.rank} > ${bankCard.rank})`);
                    }
                }
                
                // Sort winners by card rank (descending - highest first)
                winners.sort((a, b) => b.index - a.index);
                console.log(`\nWinners: ${winners.map(w => this.stateManager.getPlayer(w.playerId).name + '(' + w.selectedCard.rank + ')').join(', ')}`);
                console.log(`Refunds: ${refundPlayers.map(id => this.stateManager.getPlayer(id).name).join(', ')}`);
                
                // Check for special rules
                const bankRank = bankCard.rank;
                let remainingPool = winnerPool;
                
                // Special Rule 1: Bank draws Ace - all money goes to jackpot (minus bank rake)
                if (bankRank === 'A') {
                    console.log(`Special Rule 1: Bank drew Ace - adding ${remainingPool} to jackpot`);
                    this.stateManager.updateJackpot(remainingPool);
                    remainingPool = 0;
                }
                // Special Rule 2: Bank draws 2 - only Ace wins, rest goes to jackpot
                else if (bankRank === '2') {
                    const aceWinner = winners.find(w => w.selectedCard.rank === 'A');
                    if (aceWinner) {
                        // Ace gets 50% of the pool
                        const aceWinAmount = remainingPool * GAME_CONFIG.CASCADE_RATE;
                        const aceBet = this.getBetValue(aceWinner.selectedCard);
                        const aceTotalWin = aceBet + aceWinAmount;
                        
                        this.stateManager.updatePlayerBalance(aceWinner.playerId, aceTotalWin);
                        this.stateManager.updatePlayer(aceWinner.playerId, { actualWinnings: aceTotalWin });
                        console.log(`Special Rule 2: ${this.stateManager.getPlayer(aceWinner.playerId).name} (Ace) wins ${aceTotalWin.toFixed(2)} (bet back: ${aceBet} + pool share: ${aceWinAmount.toFixed(2)})`);
                        
                        // Rest goes to jackpot
                        const jackpotAmount = remainingPool - aceWinAmount;
                        console.log(`Special Rule 2: Adding remaining ${jackpotAmount.toFixed(2)} to jackpot`);
                        this.stateManager.updateJackpot(jackpotAmount);
                        remainingPool = 0;
                } else {
                        // No Ace winner - all goes to jackpot
                        console.log(`Special Rule 2: No Ace winner - adding ${remainingPool} to jackpot`);
                        this.stateManager.updateJackpot(remainingPool);
                        remainingPool = 0;
                    }
                }
                // Normal cascade distribution
                else if (winners.length > 0) {
                    let currentPool = remainingPool;
                    
                    for (let i = 0; i < winners.length; i++) {
                        const winner = winners[i];
                        let winAmount;
                        
                        if (i === winners.length - 1) {
                            // Last winner (lowest number) gets remaining pool
                            winAmount = currentPool;
                        } else {
                            // Each winner gets 50% of current pool
                            winAmount = currentPool * GAME_CONFIG.CASCADE_RATE;
                        }
                        
                        // Winners get their bet back PLUS pool share
                        const winnerBet = this.getBetValue(winner.selectedCard);
                        const totalWin = winnerBet + winAmount;
                        this.stateManager.updatePlayerBalance(winner.playerId, totalWin);
                        // Store the actual winnings for display purposes
                        this.stateManager.updatePlayer(winner.playerId, { 
                            actualWinnings: totalWin,
                            bet: winnerBet,
                            winnings: totalWin,
                            refund: 0
                        });
                        console.log(`  ${this.stateManager.getPlayer(winner.playerId).name} wins ${totalWin.toFixed(2)} (bet back: ${winnerBet} + pool share: ${winAmount.toFixed(2)})`);
                        
                        currentPool -= winAmount;
                    }
                    
                    // Any remaining pool goes to jackpot
                    if (currentPool > 0) {
                        console.log(`Adding remaining pool ${currentPool.toFixed(2)} to jackpot`);
                        this.stateManager.updateJackpot(currentPool);
                    }
                }
                // No winners - add remaining pool to jackpot
                else {
                    console.log(`No winners found - adding ${remainingPool} to jackpot`);
                    this.stateManager.updateJackpot(remainingPool);
                }
                
                // Process refund players (get their bet back minus jackpot rate)
                let totalRefundGiven = 0;
                let totalJackpotFromRefunds = 0;
                
                for (const refundPlayerId of refundPlayers) {
                    const refundPlayer = this.stateManager.getPlayer(refundPlayerId);
                    const betValue = this.getBetValue(refundPlayer.selectedCard);
                    const jackpotContribution = betValue * GAME_CONFIG.JACKPOT_RATE;
                    const refundAmount = betValue - jackpotContribution;
                    
                    console.log(`DEBUG: JACKPOT_RATE = ${GAME_CONFIG.JACKPOT_RATE}, jackpotContribution = ${jackpotContribution}`);
                    
                    this.stateManager.updatePlayerBalance(refundPlayerId, refundAmount);
                    this.stateManager.updatePlayer(refundPlayerId, { 
                        refund: refundAmount,
                        bet: betValue,
                        winnings: 0
                    });
                    this.stateManager.updateJackpot(jackpotContribution);
                    console.log(`  ${refundPlayer.name} refund ${refundAmount.toFixed(2)} (jackpot: ${jackpotContribution.toFixed(2)})`);
                    
                    totalRefundGiven += refundAmount;
                    totalJackpotFromRefunds += jackpotContribution;
                }
                
                console.log(`DEBUG: Total refund given: ${totalRefundGiven.toFixed(2)}`);
                console.log(`DEBUG: Total jackpot from refunds: ${totalJackpotFromRefunds.toFixed(2)}`);
                console.log(`DEBUG: Total money handled in refunds: ${(totalRefundGiven + totalJackpotFromRefunds).toFixed(2)}`);
                
                console.log(`=== END CASCADE DISTRIBUTION ===\n`);
            }

            processJackpotPayout(losingPlayer) {
                const gameData = this.stateManager.getGameData();
                const jackpotAmount = gameData.jackpot;
                
                if (jackpotAmount > 0) {
                    // Player gets the full main jackpot (insurance was already separated during contributions)
                    const payout = jackpotAmount;
                    
                    // Check if this player won hearts jackpot last round (2 wins in a row = SUPER JACKPOT!)
                    const isSuperJackpotWin = gameData.lastHeartsJackpotWinner === losingPlayer.id && gameData.superJackpot > 0;
                    let totalPayout = payout;
                    
                    let superPayoutAmount = 0;
                    if (isSuperJackpotWin) {
                        // SUPER JACKPOT! Player wins both regular jackpot AND super jackpot
                        superPayoutAmount = gameData.superJackpot;
                        totalPayout = payout + superPayoutAmount;
                        
                        console.log(`💎💎💎 SUPER JACKPOT WON! 💎💎💎`);
                        console.log(`💎 Player ${losingPlayer.id} (${losingPlayer.name}) wins hearts jackpot 2 rounds in a row!`);
                        console.log(`💎 Regular jackpot: $${payout}`);
                        console.log(`💎 Super jackpot: $${superPayoutAmount}`);
                        console.log(`💎 Total payout: $${totalPayout}`);
                        
                        // Clear super jackpot
                        gameData.superJackpot = 0;
                        
                        // Reset tracking (since super jackpot was won)
                        gameData.lastHeartsJackpotWinner = null;
                        
                        // Record super jackpot for history
                        this.stateManager.setRoundSuperJackpotWin(true, losingPlayer.name, superPayoutAmount);

                        // Play super jackpot sound/animation if available
                        if (this.uiController && this.uiController.soundManager) {
                            this.uiController.soundManager.playSound('jackpot'); // Use jackpot sound for now
                        }
                    } else {
                        // Normal hearts jackpot win - update tracking for potential super jackpot
                        gameData.lastHeartsJackpotWinner = losingPlayer.id;
                        console.log(`🎰 Hearts jackpot won by ${losingPlayer.name} - tracking for potential super jackpot next round`);
                    }
                    
                    this.stateManager.updatePlayerBalance(losingPlayer.id, totalPayout);
                    this.stateManager.updatePlayer(losingPlayer.id, { 
                        result: RESULT_TYPES.JACKPOT,
                        jackpotAmount: payout,
                        superJackpotAmount: superPayoutAmount
                    });
                    
                    // Clear main jackpot (insurance jackpot stays untouched)
                    this.stateManager.updateJackpot(-jackpotAmount);
                    
                    // Store jackpot win data for history
                    this.stateManager.setRoundJackpotWin(true, losingPlayer.name, isSuperJackpotWin ? totalPayout : payout);
                    
                    console.log(`🎰 ${isSuperJackpotWin ? 'SUPER ' : ''}JACKPOT WON! Player ${losingPlayer.id} (${losingPlayer.name}) gets ${isSuperJackpotWin ? 'SUPER + regular' : 'regular'} jackpot: $${totalPayout}`);
                    console.log(`🎰 Player isHuman: ${losingPlayer.isHuman}`);
                    console.log(`🎰 window.uiController exists: ${!!window.uiController}`);
                    console.log(`🎰 soundManager exists: ${!!(window.uiController && window.uiController.soundManager)}`);
                    
                    // Play jackpot sound and animation immediately
                    if (this.uiController && this.uiController.soundManager) {
                        console.log(`🎰 About to play jackpot sound...`);
                        if (losingPlayer.isHuman) {
                            console.log(`🎰 Playing HUMAN jackpot sound`);
                            this.uiController.soundManager.playSound('jackpot');
                        } else {
                            console.log(`🎰 Playing BOT jackpot sound`);
                            this.uiController.soundManager.playSound('botJackpot');
                        }
                    } else {
                        console.error(`🎰 Cannot play jackpot sound - missing uiController or soundManager`);
                        console.error(`🎰 this.uiController: ${!!this.uiController}`);
                        console.error(`🎰 soundManager: ${!!(this.uiController && this.uiController.soundManager)}`);
                    }
                    
                    // Create jackpot animation immediately (and super variant if applicable)
                    if (this.uiController) {
                        console.log(`🎰 About to create jackpot animation for player ${losingPlayer.id} with amount $${payout}`);
                        this.uiController.createJackpotAnimation(losingPlayer.id, payout);
                        if (isSuperJackpotWin && typeof this.uiController.createSuperJackpotAnimation === 'function') {
                            this.uiController.createSuperJackpotAnimation(losingPlayer.id, totalPayout);
                        }
                    } else {
                        console.error(`🎰 Cannot create jackpot animation - missing uiController`);
                    }
                }
            }

            // New hearts jackpot flow based on requirement:
            // - Jackpot winner (hearts vs hearts) receives current jackpot AND keeps their bet (bet is returned)
            // - All other players get REFUND (bet minus jackpot rate); that contribution is added into jackpot for next round
            // - Main jackpot is reduced by the payout (may dip but immediately replenished by refunds), not forcibly cleared to zero
            processHeartsJackpotWin(winner) {
                const gameData = this.stateManager.getGameData();
                const currentJackpot = gameData.jackpot || 0;
                const winnerBet = this.getBetValue(winner.selectedCard);
                console.log(`🎰 Hearts Jackpot: paying out $${currentJackpot} to ${winner.name} and refunding all others`);

                // Check for Super Jackpot condition (same player as previous hearts jackpot winner)
                const isSuperJackpotWin = gameData.lastHeartsJackpotWinner === winner.id && (gameData.superJackpot || 0) > 0;

                // 1) Refund every other player (bet - jackpotRate), add contributions to jackpot for next time
                let totalContrib = 0;
                for (const [playerId, selectedCard] of gameData.selectedCards) {
                    if (playerId === winner.id) continue;
                    const player = this.stateManager.getPlayer(playerId);
                    const betValue = this.getBetValue(selectedCard);
                    const contribution = betValue * GAME_CONFIG.JACKPOT_RATE;
                    const refund = betValue - contribution;
                    this.stateManager.updatePlayerBalance(playerId, refund);
                    this.stateManager.updatePlayer(playerId, { result: RESULT_TYPES.REFUND, refund });
                    this.stateManager.updateJackpot(contribution);
                    totalContrib += contribution;
                    console.log(`  ↳ ${player.name} REFUND $${refund.toFixed(2)} (contrib $${contribution.toFixed(2)})`);
                }

                // 2) Pay jackpot (and possibly super jackpot) to winner and also return bet
                const payout = currentJackpot; // main jackpot
                const superPayout = isSuperJackpotWin ? (gameData.superJackpot || 0) : 0;
                const totalPayoutToWinner = payout + superPayout + winnerBet; // add back their bet
                this.stateManager.updatePlayerBalance(winner.id, totalPayoutToWinner);
                this.stateManager.updatePlayer(winner.id, { 
                    result: RESULT_TYPES.JACKPOT,
                    jackpotAmount: payout,
                    superJackpotAmount: superPayout,
                    winnings: totalPayoutToWinner,
                    refund: 0
                });

                // Deduct main jackpot payout
                this.stateManager.updateJackpot(-payout);
                // Clear super jackpot if it was won
                if (isSuperJackpotWin) {
                    gameData.superJackpot = 0;
                }

                console.log(`🎰 Winner ${winner.name} gets jackpot $${payout}${isSuperJackpotWin ? ` + super $${superPayout}` : ''} + bet back $${winnerBet} = $${totalPayoutToWinner}`);
                console.log(`🎰 Jackpot after payout and contributions: $${this.stateManager.getGameData().jackpot} (contrib added: $${totalContrib.toFixed(2)})`);

                // Update tracking for super jackpot
                if (isSuperJackpotWin) {
                    // Reset tracking after a super win
                    gameData.lastHeartsJackpotWinner = null;
                } else {
                    gameData.lastHeartsJackpotWinner = winner.id;
                }

                // Record wins for history panel
                this.stateManager.setRoundJackpotWin(true, winner.name, payout);
                if (isSuperJackpotWin) {
                    this.stateManager.setRoundSuperJackpotWin(true, winner.name, superPayout);
                }

                // Sound/animation (reuse existing helpers)
                if (this.uiController && this.uiController.soundManager) {
                    if (winner.isHuman) {
                        this.uiController.soundManager.playSound('jackpot');
                    } else {
                        this.uiController.soundManager.playSound('botJackpot');
                    }
                }
                if (this.uiController) {
                    this.uiController.createJackpotAnimation(winner.id, payout);
                    if (isSuperJackpotWin && typeof this.uiController.createSuperJackpotAnimation === 'function') {
                        this.uiController.createSuperJackpotAnimation(winner.id, payout + superPayout + winnerBet);
                    }
                }

                // If the winner has insurance, they also win the Insurance Jackpot
                const insurancePot = gameData.insuranceJackpot || 0;
                if (winner.hasInsurance && insurancePot > 0) {
                    console.log(`🛡️ Hearts winner ${winner.name} also has insurance - awarding Insurance Pot $${insurancePot}`);
                    // Credit insurance to the same winner without changing JACKPOT result
                    this.stateManager.updatePlayerBalance(winner.id, insurancePot);
                    this.stateManager.setRoundInsuranceWin(true, winner.name, insurancePot);
                    // Reset insurance pot
                    gameData.insuranceJackpot = 0;
                    // Update UI markers and display
                    if (this.uiController) {
                        if (typeof this.uiController.removeInsuranceMarkers === 'function') {
                            this.uiController.removeInsuranceMarkers();
                        }
                        if (typeof this.uiController.updateInsuranceJackpotDisplay === 'function') {
                            this.uiController.updateInsuranceJackpotDisplay();
                        }
                        // Show blue insurance celebration at the winner's seat
                        if (typeof this.uiController.createInsuranceWinAnimation === 'function') {
                            this.uiController.createInsuranceWinAnimation(winner.id, insurancePot);
                        }
                        if (this.uiController.soundManager) {
                            this.uiController.soundManager.playSound('insuranceWin');
                        }
                    }
                }
            }

            processInsurancePayout(winningPlayer) {
                const gameData = this.stateManager.getGameData();
                const insurancePot = gameData.insuranceJackpot;
                
                if (insurancePot > 0) {
                    console.log(`🛡️ INSURANCE WON! Player ${winningPlayer.id} (${winningPlayer.name}) gets insurance pot: $${insurancePot}`);
                    
                    // Player gets the full insurance pot
                    this.stateManager.updatePlayerBalance(winningPlayer.id, insurancePot);
                    this.stateManager.updatePlayer(winningPlayer.id, { 
                        result: 'INSURANCE_WIN',
                        insuranceAmount: insurancePot 
                    });
                    
                    // Store insurance win data for history
                    this.stateManager.setRoundInsuranceWin(true, winningPlayer.name, insurancePot);
                    
                    // Reset insurance pot to zero after payout
                    gameData.insuranceJackpot = 0;
                    console.log(`🛡️ Insurance pot reset to $0 after payout`);
                    
                    // Remove all insurance markers since pot is now empty
                    // All players lose their insurance status when pot is won
                    gameData.players.forEach(player => {
                        player.hasInsurance = false;
                    });
                    
                    // Remove all insurance markers from UI
                    if (this.uiController && typeof this.uiController.removeInsuranceMarkers === 'function') {
                        this.uiController.removeInsuranceMarkers();
                        console.log(`🛡️ Removed all insurance markers after payout`);
                    }
                    
                    // Update insurance jackpot display
                    if (this.uiController) {
                        this.uiController.updateInsuranceJackpotDisplay();
                    }
                    
                    // Play insurance win sound and animation immediately
                    if (this.uiController && this.uiController.soundManager) {
                        console.log(`🛡️ Playing insurance win sound`);
                        this.uiController.soundManager.playSound('insuranceWin');
                    } else {
                        console.error(`🛡️ Cannot play insurance sound - missing uiController or soundManager`);
                    }
                    
                    // Create insurance win animation
                    if (this.uiController) {
                        console.log(`🛡️ Creating insurance win animation for player ${winningPlayer.id} with amount $${insurancePot}`);
                        this.uiController.createInsuranceWinAnimation(winningPlayer.id, insurancePot);
                    } else {
                        console.error(`🛡️ Cannot create insurance animation - missing uiController`);
                    }
                }
            }

            proceedWithoutInsurance() {
                console.log('🛡️ Proceeding without insurance');
                this.stateManager.setState(GAME_STATES.CARD_SELECTION);
            }

            proceedToCardSelection() {
                console.log('🛡️ Proceeding to card selection phase');
                this.stateManager.setState(GAME_STATES.CARD_SELECTION);
            }

            getTurnOrder() {
                const gameData = this.stateManager.getGameData();
                const previousLoser = this.stateManager.getPreviousLoser();
                const turnOrderType = document.getElementById('turn-order-select')?.value || 'A';
                
                console.log('getTurnOrder called, previousLoser:', previousLoser, 'turnOrderType:', turnOrderType);
                
                switch (turnOrderType) {
                    case 'A': // Previous loser first, then lowest balance
                        return this.getTurnOrderA(gameData, previousLoser);
                    case 'B': // Previous loser first, then highest balance
                        return this.getTurnOrderB(gameData, previousLoser);
                    case 'C': // Clockwise order with marker
                        return this.getTurnOrderC(gameData);
                    case 'D': // Random order
                        return this.getTurnOrderD(gameData);
                    default:
                        return this.getTurnOrderA(gameData, previousLoser);
                }
            }

            getTurnOrderA(gameData, previousLoser) {
                // Original logic: Previous loser first, then lowest balance
                if (previousLoser !== null) {
                    const previousLoserPlayer = this.stateManager.getPlayer(previousLoser);
                    const otherPlayers = gameData.players.filter(p => p.id !== previousLoser);
                    
                    otherPlayers.sort((a, b) => {
                        if (a.balance === b.balance) {
                            return Math.random() - 0.5;
                        }
                        return a.balance - b.balance;
                    });
                    
                    const turnOrder = [previousLoserPlayer, ...otherPlayers].filter(p => p !== null);
                    console.log('Turn order A (previous loser first, others by lowest balance):', turnOrder.map(p => ({ id: p.id, name: p.name, balance: p.balance })));
                    return turnOrder;
                } else {
                    const turnOrder = [...gameData.players].sort((a, b) => {
                        if (a.balance === b.balance) {
                            return Math.random() - 0.5;
                        }
                        return a.balance - b.balance;
                    });
                    console.log('Turn order A (first round, by lowest balance):', turnOrder.map(p => ({ id: p.id, name: p.name, balance: p.balance })));
                    return turnOrder;
                }
            }

            getTurnOrderB(gameData, previousLoser) {
                // Previous loser first, then highest balance
                if (previousLoser !== null) {
                    const previousLoserPlayer = this.stateManager.getPlayer(previousLoser);
                    const otherPlayers = gameData.players.filter(p => p.id !== previousLoser);
                    
                    otherPlayers.sort((a, b) => {
                        if (a.balance === b.balance) {
                            return Math.random() - 0.5;
                        }
                        return b.balance - a.balance; // Highest first (reversed)
                    });
                    
                    const turnOrder = [previousLoserPlayer, ...otherPlayers].filter(p => p !== null);
                    console.log('Turn order B (previous loser first, others by highest balance):', turnOrder.map(p => ({ id: p.id, name: p.name, balance: p.balance })));
                    return turnOrder;
                } else {
                    const turnOrder = [...gameData.players].sort((a, b) => {
                        if (a.balance === b.balance) {
                            return Math.random() - 0.5;
                        }
                        return b.balance - a.balance; // Highest first (reversed)
                    });
                    console.log('Turn order B (first round, by highest balance):', turnOrder.map(p => ({ id: p.id, name: p.name, balance: p.balance })));
                    return turnOrder;
                }
            }

            getTurnOrderC(gameData) {
                // Clockwise order with marker
                if (this.clockwiseStartPlayer === undefined) {
                    // First round - random starting player
                    this.clockwiseStartPlayer = Math.floor(Math.random() * GAME_CONFIG.TOTAL_PLAYERS);
                    console.log('First round clockwise, random start player:', this.clockwiseStartPlayer);
                }
                
                // Create clockwise order starting from the designated player
                // Use player IDs 0-8 in clockwise order
                const turnOrder = [];
                for (let i = 0; i < GAME_CONFIG.TOTAL_PLAYERS; i++) {
                    const playerId = (this.clockwiseStartPlayer + i) % GAME_CONFIG.TOTAL_PLAYERS;
                    const player = gameData.players.find(p => p.id === playerId);
                    if (player) {
                        turnOrder.push(player);
                    }
                }
                
                console.log('Turn order C (clockwise from player', this.clockwiseStartPlayer + '):', turnOrder.map(p => ({ id: p.id, name: p.name })));
                return turnOrder;
            }

            getTurnOrderD(gameData) {
                // Completely random order
                const turnOrder = [...gameData.players].sort(() => Math.random() - 0.5);
                console.log('Turn order D (random):', turnOrder.map(p => ({ id: p.id, name: p.name })));
                return turnOrder;
            }

            showTurnMarker(playerId) {
                // Show marker only for clockwise mode (variant C)
                const turnOrderType = document.getElementById('turn-order-select')?.value || 'A';
                
                if (turnOrderType === 'C') {
                    // For clockwise mode, add current-turn class to current player
                    this.clearCurrentTurnMarkers();
                    
                    const marker = document.getElementById(`turn-marker-${playerId}`);
                    if (marker) {
                        // Always show marker and add current-turn class for current player
                        marker.style.display = 'block';
                        marker.classList.add('current-turn');
                        console.log(`Showing current-turn marker for player ${playerId} - Clockwise mode`);
                    }
                } else {
                    // For variants A, B, D - no markers at all
                    console.log(`No turn markers for mode ${turnOrderType} (player ${playerId})`);
                }
            }

            clearCurrentTurnMarkers() {
                // Remove current-turn class and hide non-first-player markers
                const turnOrderType = document.getElementById('turn-order-select')?.value || 'A';
                
                if (turnOrderType === 'C') {
                    // In clockwise mode, keep first player marker visible, hide others
                    const turnOrder = this.getTurnOrder();
                    const firstPlayer = turnOrder.length > 0 ? turnOrder[0] : null;
                    
                    for (let i = 0; i < GAME_CONFIG.TOTAL_PLAYERS; i++) {
                        const marker = document.getElementById(`turn-marker-${i}`);
                        if (marker) {
                            marker.classList.remove('current-turn');
                            
                            // Hide marker if it's not the first player
                            if (!firstPlayer || i !== firstPlayer.id) {
                                marker.style.display = 'none';
                            }
                        }
                    }
                } else {
                    // For other modes, just remove current-turn class
                    for (let i = 0; i < GAME_CONFIG.TOTAL_PLAYERS; i++) {
                        const marker = document.getElementById(`turn-marker-${i}`);
                        if (marker) {
                            marker.classList.remove('current-turn');
                        }
                    }
                }
            }

            hideAllTurnMarkers() {
                // Hide all turn markers
                for (let i = 0; i < GAME_CONFIG.TOTAL_PLAYERS; i++) {
                    const marker = document.getElementById(`turn-marker-${i}`);
                    if (marker) {
                        marker.style.display = 'none';
                    }
                }
            }

            updateClockwiseStartPlayer() {
                // For clockwise mode, move to next player after each round
                const turnOrderType = document.getElementById('turn-order-select')?.value || 'A';
                if (turnOrderType === 'C' && this.clockwiseStartPlayer !== undefined) {
                    this.clockwiseStartPlayer = (this.clockwiseStartPlayer + 1) % GAME_CONFIG.TOTAL_PLAYERS;
                    console.log('Updated clockwise start player to:', this.clockwiseStartPlayer);
                }
            }

            showFirstPlayerMarker() {
                // Show marker for the first player in current turn order (all modes)
                const turnOrder = this.getTurnOrder();
                if (turnOrder.length > 0) {
                    const firstPlayer = turnOrder[0];
                    this.hideAllTurnMarkers();
                    
                    const marker = document.getElementById(`turn-marker-${firstPlayer.id}`);
                    if (marker) {
                        marker.style.display = 'block';
                        // Don't add current-turn class - this is the persistent first player marker
                        console.log(`Showing first player marker for player ${firstPlayer.id} (${firstPlayer.name})`);
                    }
                }
            }

            validateGameState() {
                const gameData = this.stateManager.getGameData();
                // Validate only the table economy (exclude superJackpot)
                const playerBalances = gameData.players.reduce((sum, player) => sum + (player.balance || 0), 0);
                const totalBalance = playerBalances + (gameData.jackpot || 0) + (gameData.insuranceJackpot || 0) + (gameData.bankRake || 0);
                const expectedTotal = (GAME_CONFIG.TOTAL_PLAYERS * GAME_CONFIG.INITIAL_BALANCE) - (gameData.superJackpotFromTable || 0);
                
                // Detailed balance breakdown
                const playerBalancesDetail = gameData.players.reduce((sum, player) => sum + (player.balance || 0), 0);
                const jackpot = gameData.jackpot || 0;
                const superJackpot = gameData.superJackpot || 0;
                const insuranceJackpot = gameData.insuranceJackpot || 0;
                const bankRake = gameData.bankRake || 0;
                
                // Calculate difference and percentage
                const difference = totalBalance - expectedTotal;
                const percentage = Math.abs(difference) / expectedTotal * 100;
                const acceptanceThreshold = 0.2; // 0.2% acceptance threshold
                
                console.log('=== BALANCE VALIDATION ===');
                console.log(`Player balances: $${playerBalancesDetail}`);
                console.log(`Jackpot: $${jackpot}`);
                console.log(`Super Jackpot: $${superJackpot}`);
                console.log(`Insurance: $${insuranceJackpot}`);
                console.log(`Bank rake: $${bankRake}`);
                console.log(`Total: $${totalBalance}`);
                console.log(`Expected: $${expectedTotal}`);
                console.log(`Difference: $${difference}`);
                console.log(`Percentage: ${percentage.toFixed(4)}%`);
                console.log(`Acceptance threshold: ${acceptanceThreshold}%`);
                
                if (percentage > acceptanceThreshold) {
                    console.error(`Balance leak detected! Expected: ${expectedTotal}, Actual: ${totalBalance}, Difference: ${percentage.toFixed(4)}%`);
                    return false;
                } else {
                    console.log(`✅ Balance within acceptable range (${percentage.toFixed(4)}% < ${acceptanceThreshold}%)`);
                }
                console.log('========================');
                
                return true;
            }
        }

        // Sound Manager
        class SoundManager {
            constructor() {
                this.soundsEnabled = true;
                this.audioContext = null;
                this.sounds = {};
                this.initializeAudio();
            }
            
            initializeAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.createSounds();
                } catch (error) {
                    console.warn('Audio not supported:', error);
                }
            }
            
            createSounds() {
                // Card selection sound (short beep)
                this.sounds.cardSelect = this.createTone(800, 0.1, 'sine');
                
                // Win sound (glad, ascending melody)
                this.sounds.win = this.createMelody([523, 659, 784, 1047], 0.15);
                
                // Loss sound (ledsam, descending tone)
                this.sounds.loss = this.createTone(300, 0.4, 'sawtooth');
                
                // Refund sound (neutral, simple tone)
                this.sounds.refund = this.createTone(440, 0.2, 'sine');
                
                // Jackpot sound (trumpetljud)
                this.sounds.jackpot = this.createTrumpetSound();
                
                // Bot jackpot sound (different celebration sound)
                this.sounds.botJackpot = this.createBotJackpotSound();
                
                // Insurance win sound (protective/secure sound)
                this.sounds.insuranceWin = this.createInsuranceWinSound();
                
                // Bank draw sound (dramatic tone)
                this.sounds.bankDraw = this.createTone(200, 0.5, 'triangle');
                
                // Round start sound
                this.sounds.roundStart = this.createMelody([440, 554, 659], 0.2);
                
                // Card drag sound (raspigt dragljud)
                this.sounds.cardDrag = this.createRaspySound();
            }
            
            createTone(frequency, duration, waveType = 'sine') {
                return () => {
                    if (!this.soundsEnabled || !this.audioContext) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                    oscillator.type = waveType;
                    
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration);
                };
            }
            
            createMelody(frequencies, noteDuration) {
                return () => {
                    if (!this.soundsEnabled || !this.audioContext) return;
                    
                    frequencies.forEach((freq, index) => {
                        setTimeout(() => {
                            const oscillator = this.audioContext.createOscillator();
                            const gainNode = this.audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.audioContext.destination);
                            
                            oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                            oscillator.type = 'sine';
                            
                            gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + noteDuration);
                            
                            oscillator.start(this.audioContext.currentTime);
                            oscillator.stop(this.audioContext.currentTime + noteDuration);
                        }, index * noteDuration * 1000);
                    });
                };
            }
            
            createRaspySound() {
                return () => {
                    console.log('createRaspySound called, soundsEnabled:', this.soundsEnabled, 'audioContext:', !!this.audioContext);
                    if (!this.soundsEnabled || !this.audioContext) return;
                    
                    const duration = 0.3;
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    // Skapa raspigt ljud med låg frekvens och filter
                    oscillator.frequency.setValueAtTime(150, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(80, this.audioContext.currentTime + duration);
                    oscillator.type = 'sawtooth';
                    
                    // Lägg till filter för raspigt ljud
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(200, this.audioContext.currentTime);
                    filter.Q.setValueAtTime(10, this.audioContext.currentTime);
                    
                    // Gain för att kontrollera volym (högre volym)
                    gainNode.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    
                    oscillator.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration);
                };
            }
            
            createTrumpetSound() {
                return () => {
                    if (!this.soundsEnabled || !this.audioContext) return;
                    
                    const duration = 1.5;
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    // Trumpetljud - stigande melodi
                    oscillator.frequency.setValueAtTime(220, this.audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(440, this.audioContext.currentTime + 0.5);
                    oscillator.frequency.linearRampToValueAtTime(660, this.audioContext.currentTime + 1.0);
                    oscillator.frequency.linearRampToValueAtTime(880, this.audioContext.currentTime + 1.5);
                    oscillator.type = 'sawtooth';
                    
                    // Filter för trumpetljud
                    filter.type = 'bandpass';
                    filter.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    filter.Q.setValueAtTime(5, this.audioContext.currentTime);
                    
                    // Gain för trumpetljud (högre volym)
                    gainNode.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    
                    oscillator.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration);
                };
            }

            createBotJackpotSound() {
                return () => {
                    console.log('🤖 Playing bot jackpot sound!');
                    if (!this.soundsEnabled || !this.audioContext) {
                        console.log('Bot jackpot sound disabled - soundsEnabled:', this.soundsEnabled, 'audioContext:', !!this.audioContext);
                        return;
                    }
                    
                    const duration = 2.0;
                    
                    // Create multiple oscillators for rich bot celebration sound
                    const createOscillator = (freq, type, delay = 0) => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();
                        
                        osc.frequency.setValueAtTime(freq, this.audioContext.currentTime + delay);
                        osc.type = type;
                        
                        gain.gain.setValueAtTime(0.15, this.audioContext.currentTime + delay);
                        gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + delay + duration);
                        
                        osc.connect(gain);
                        gain.connect(this.audioContext.destination);
                        
                        osc.start(this.audioContext.currentTime + delay);
                        osc.stop(this.audioContext.currentTime + delay + duration);
                    };
                    
                    // Bot celebration melody - more electronic/digital sounding
                    createOscillator(523, 'square', 0);      // C5
                    createOscillator(659, 'square', 0.2);    // E5
                    createOscillator(784, 'square', 0.4);    // G5
                    createOscillator(1047, 'square', 0.6);   // C6
                    createOscillator(1319, 'square', 0.8);   // E6
                    
                    // Add some harmonic richness
                    createOscillator(262, 'sine', 0.1);     // Lower octave
                    createOscillator(330, 'sine', 0.3);     // Harmony
                };
            }

            createInsuranceWinSound() {
                return () => {
                    console.log('🛡️ Playing insurance win sound!');
                    if (!this.soundsEnabled || !this.audioContext) {
                        console.log('Insurance win sound disabled - soundsEnabled:', this.soundsEnabled, 'audioContext:', !!this.audioContext);
                        return;
                    }
                    
                    const duration = 1.5;
                    
                    // Create protective/secure sounding melody
                    const createOscillator = (freq, type, delay = 0, vol = 0.1) => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();
                        
                        osc.frequency.setValueAtTime(freq, this.audioContext.currentTime + delay);
                        osc.type = type;
                        
                        gain.gain.setValueAtTime(vol, this.audioContext.currentTime + delay);
                        gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + delay + duration);
                        
                        osc.connect(gain);
                        gain.connect(this.audioContext.destination);
                        
                        osc.start(this.audioContext.currentTime + delay);
                        osc.stop(this.audioContext.currentTime + delay + duration);
                    };
                    
                    // Insurance protection melody - stable, secure tones
                    createOscillator(440, 'sine', 0, 0.15);      // A4 - foundation
                    createOscillator(554, 'sine', 0.2, 0.12);    // C#5 - security
                    createOscillator(659, 'sine', 0.4, 0.12);    // E5 - protection
                    createOscillator(880, 'sine', 0.6, 0.15);    // A5 - completion
                    
                    // Add harmonic richness for "shield" effect
                    createOscillator(220, 'triangle', 0.1, 0.08); // Lower octave
                    createOscillator(330, 'triangle', 0.3, 0.08); // Harmony
                };
            }
            
            playSound(soundName) {
                if (this.sounds[soundName]) {
                    this.sounds[soundName]();
                }
            }
            
            setEnabled(enabled) {
                this.soundsEnabled = enabled;
            }
            
            isEnabled() {
                return this.soundsEnabled;
            }
        }

        // Bot Controller
        class BotController {
            constructor(stateManager, gameLogic) {
                this.stateManager = stateManager;
                this.gameLogic = gameLogic;
                this.botTimeouts = new Map();
            }

            setBotStrategy(botId, strategy) {
                const player = this.stateManager.getPlayer(botId);
                if (player && player.isBot) {
                    this.stateManager.updatePlayer(botId, { strategy });
                }
            }

            getBotStrategy(botId) {
                const player = this.stateManager.getPlayer(botId);
                return player && player.isBot ? player.strategy : null;
            }

            async makeBotMove(botId) {
                const player = this.stateManager.getPlayer(botId);
                if (!player) {
                    console.log(`Player ${botId} not found`);
                    return false;
                }

                // Check if human player strategy is manual - if so, skip automatic move
                if (player.isHuman && player.strategy === 'manual') {
                    console.log(`Player ${botId} is human with manual strategy - skipping automatic move`);
                    return false;
                }

                // Get strategy from UI dropdown (for bots) or player strategy (for human players)
                let strategy;
                if (player.isHuman) {
                    // For human players, get strategy from player object
                    strategy = player.strategy;
                } else {
                    // For bots, get strategy from UI dropdown
                    const strategySelect = document.getElementById(`bot-strategy-${botId}`);
                    strategy = strategySelect ? strategySelect.value : 'random';
                }
                const availableCards = this.stateManager.getAvailableCards();
                
                console.log(`Player ${botId} (${player.name}) strategy: ${strategy}, available cards:`, availableCards);
                
                if (availableCards.length === 0) {
                    console.log(`No available cards for player ${botId}`);
                    return false;
                }

                let selectedRank = null;

                switch (strategy) {
                    case 'random':
                        selectedRank = this.getRandomCard(availableCards);
                        break;
                    case 'lowest':
                        selectedRank = this.getLowestCard(availableCards);
                        break;
                    case 'highest':
                        selectedRank = this.getHighestCard(availableCards);
                        break;
                    case 'manual':
                        return this.waitForManualSelection(botId);
                    default:
                        selectedRank = this.getRandomCard(availableCards);
                }

                if (selectedRank) {
                    // Assign a random suit to the bot's card
                    const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
                    const suit = suits[Math.floor(Math.random() * suits.length)];
                    const card = { rank: selectedRank, suit };
                    const success = this.stateManager.selectCard(botId, card);
                    
                    if (success) {
                        // Update the table card to show who selected it
                        // This will be handled by the UI controller
                        console.log(`Bot ${botId} (${player.name}) selected card ${selectedRank}`);
                    }
                    
                    console.log(`Bot ${botId} selected ${selectedRank} of ${suit}, success: ${success}`);
                    return success;
                }

                console.log(`Bot ${botId} failed to select a card`);
                return false;
            }

            getRandomCard(availableCards) {
                if (availableCards.length === 0) return null;
                return availableCards[Math.floor(Math.random() * availableCards.length)];
            }

            getLowestCard(availableCards) {
                const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9'];
                const sortedCards = availableCards.sort((a, b) => rankOrder.indexOf(a) - rankOrder.indexOf(b));
                return sortedCards[0];
            }

            getHighestCard(availableCards) {
                const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9'];
                const sortedCards = availableCards.sort((a, b) => rankOrder.indexOf(b) - rankOrder.indexOf(a));
                return sortedCards[0];
            }

            waitForManualSelection(botId) {
                return new Promise((resolve) => {
                    console.log(`=== Manual selection for bot ${botId} - showing admin interface ===`);
                    
                    // Store the resolve function for this bot
                    this.pendingManualSelection = { botId, resolve };
                    
                    // Signal to UIController to show admin interface
                    if (window.game && window.game.uiController) {
                        window.game.uiController.showAdminManualSelection(botId, resolve);
                    } else {
                        console.error('UIController not available for admin selection');
                        // Fallback to random selection
                        const availableCards = this.stateManager.getAvailableCards();
                        const selectedRank = this.getRandomCard(availableCards);
                        if (selectedRank) {
                            const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
                            const suit = suits[Math.floor(Math.random() * suits.length)];
                            const card = { rank: selectedRank, suit };
                            this.stateManager.selectCard(botId, card);
                        }
                        resolve(true);
                    }
                });
            }


            async processAllBotMoves() {
                const gameData = this.stateManager.getGameData();
                const bots = gameData.players.filter(p => p.isBot && !p.selectedCard);
                
                for (const bot of bots) {
                    await this.makeBotMove(bot.id);
                    
                    if (bot.id < bots[bots.length - 1].id) {
                        await this.delay(GAME_CONFIG.BOT_DELAY);
                    }
                }
            }

            animateCardToPlayer(cardElement, playerId) {
                console.log(`=== animateCardToPlayer called for player ${playerId} ===`);
                const playerSeat = document.getElementById(`player-${playerId}`);
                if (!playerSeat) {
                    console.error(`Player seat not found for ID: ${playerId}`);
                    return;
                }
                
                // Create a copy of the card for animation
                const animatedCard = cardElement.cloneNode(true);
                animatedCard.style.position = 'fixed';
                animatedCard.style.zIndex = '1000';
                animatedCard.style.pointerEvents = 'none';
                
                // Add to game container
                this.elements.gameContainer.appendChild(animatedCard);
                
                const seatRect = playerSeat.getBoundingClientRect();
                const cardRect = cardElement.getBoundingClientRect();
                const gameRect = this.elements.gameContainer.getBoundingClientRect();
                
                // Calculate relative positions
                const targetX = seatRect.left - gameRect.left + (seatRect.width / 2) - 20; // Center on seat
                const targetY = seatRect.top - gameRect.top + (seatRect.height / 2) - 30; // Center on seat
                const startX = cardRect.left - gameRect.left;
                const startY = cardRect.top - gameRect.top;
                
                console.log(`Animating card from (${startX}, ${startY}) to (${targetX}, ${targetY})`);
                
                // Set initial position
                animatedCard.style.left = `${startX}px`;
                animatedCard.style.top = `${startY}px`;
                animatedCard.style.transition = 'all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                
                // Animate to player position
                setTimeout(() => {
                    console.log(`Moving card to player position: (${targetX}, ${targetY})`);
                    animatedCard.style.left = `${targetX}px`;
                    animatedCard.style.top = `${targetY}px`;
                    animatedCard.style.transform = 'scale(0.6)';
                }, 50);
                
                // Remove the animated card after animation
                setTimeout(() => {
                    console.log(`Removing animated card for player ${playerId}`);
                    if (animatedCard.parentNode) {
                        animatedCard.parentNode.removeChild(animatedCard);
                    }
                }, 1000);
            }

            disableCardSelection() {
                console.log('Disabling card selection');
                const tableCards = document.querySelectorAll('.table-card');
                tableCards.forEach(card => {
                    if (card._cardClickHandler) {
                        card.removeEventListener('click', card._cardClickHandler);
                        card._cardClickHandler = null;
                    }
                    card.classList.add('unavailable');
                    card.style.pointerEvents = 'none'; // Disable all mouse events
                    card.style.cursor = 'not-allowed';
                });
            }


            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // UI Controller
        class UIController {
            constructor(stateManager, gameLogic, botController) {
                this.stateManager = stateManager;
                this.gameLogic = gameLogic;
                this.botController = botController;
                this.soundManager = new SoundManager();
                this.animationQueue = [];
                this.isAnimating = false;
                // Timer used to auto-start the next round; cleared on state changes
                this.autoStartTimer = null;
                
                // Insurance system
                this.insuranceTimer = null;
                this.insuranceTimeLeft = 0;
                this.humanInsuranceTimer = null;
                this.humanCountdownInterval = null;
                
                this.initializeElements();
                this.setupEventListeners();
                this.initializeInsuranceSettings();
                this.setupStateListeners();
                this.setupBankOverrideUI();
            }

            initializeElements() {
                console.log('Initializing UI elements...');
                this.elements = {
                    gameContainer: document.getElementById('game-container'),
                    playerSeats: document.querySelector('.player-seats'),
                    bankCard: document.getElementById('bank-card'),
                    jackpotAmount: document.getElementById('jackpot-amount'),
                    superJackpotAmount: document.getElementById('super-jackpot-amount'),
                    insuranceAmount: document.getElementById('insurance-amount'),
                    startRoundBtn: document.getElementById('start-round-btn'),
                    adminPanelBtn: document.getElementById('admin-panel-btn'),
                    adminPanel: document.getElementById('admin-panel'),
                    botControlBtn: document.getElementById('bot-control-btn'),
                    botControlPanel: document.getElementById('bot-control-panel'),
                    historyBtn: document.getElementById('history-btn'),
                    historyPanel: document.getElementById('history-panel'),
                    gameState: document.getElementById('game-state'),
                    gameTimer: document.getElementById('game-timer'),
                    totalBalance: document.getElementById('total-balance'),
                    expectedBalance: document.getElementById('expected-balance'),
                    playerBalances: document.getElementById('player-balances'),
                    adminJackpot: document.getElementById('admin-jackpot'),
                    adminSuperJackpot: document.getElementById('admin-super-jackpot'),
                    adminInsurance: document.getElementById('admin-insurance'),
                    adminBankRake: document.getElementById('admin-bank-rake'),
                    adminBankRakeDisplay: document.getElementById('admin-bank-rake-display'),
                    adminRound: document.getElementById('admin-round'),
                    currentRound: document.getElementById('current-round'),
                    
                    // Insurance elements
                    insuranceModal: document.getElementById('insurance-modal'),
                    insurancePlayers: document.getElementById('insurance-players'),
                    insuranceCountdown: document.getElementById('insurance-countdown'),
                    modalInsuranceCost: document.getElementById('modal-insurance-cost'),
                    modalInsurancePot: document.getElementById('modal-insurance-pot'),
                    confirmInsuranceBtn: document.getElementById('confirm-insurance-btn'),
                    skipInsuranceBtn: document.getElementById('skip-insurance-btn'),
                    insuranceTimer: document.getElementById('insurance-timer'),
                    insuranceCostInput: document.getElementById('insurance-cost'),
                    insuranceMinPotInput: document.getElementById('insurance-min-pot'),
                };
                
                console.log('UI elements initialized:', this.elements);
            }

            setupBankOverrideUI() {
                // Build Testing Tools section dynamically inside admin panel
                const panel = this.elements.adminPanel;
                if (!panel) return;
                const section = document.createElement('div');
                section.className = 'admin-section';
                section.innerHTML = `
                    <h4>Testing Tools</h4>
                    <div class="control-group">
                        <label for="bank-override-rank">Next Bank Card (Rank):</label>
                        <select id="bank-override-rank">
                            <option value="A">A</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="4">4</option>
                            <option value="5">5</option>
                            <option value="6">6</option>
                            <option value="7">7</option>
                            <option value="8">8</option>
                            <option value="9">9</option>
                            <option value="10">10</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="bank-override-suit">Next Bank Card (Suit):</label>
                        <select id="bank-override-suit">
                            <option value="hearts">♥ hearts</option>
                            <option value="diamonds">♦ diamonds</option>
                            <option value="clubs">♣ clubs</option>
                            <option value="spades">♠ spades</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <button id="set-bank-override" class="control-btn">Set Next Bank Card</button>
                        <button id="clear-bank-override" class="control-btn secondary">Clear</button>
                    </div>
                    <div id="bank-override-display" style="font-size:12px;color:#ccc;margin-top:6px;">Next bank card: random</div>
                `;
                // Safely append at end of admin panel
                try {
                    panel.appendChild(section);
                } catch (e) {
                    console.warn('Could not append Testing Tools section, admin panel structure unexpected:', e);
                }

                // Wire up events
                const setBtn = document.getElementById('set-bank-override');
                const clearBtn = document.getElementById('clear-bank-override');
                const rankSel = document.getElementById('bank-override-rank');
                const suitSel = document.getElementById('bank-override-suit');
                const display = document.getElementById('bank-override-display');
                if (setBtn && clearBtn && rankSel && suitSel && display) {
                    setBtn.addEventListener('click', () => {
                        const rank = rankSel.value;
                        const suit = suitSel.value;
                        this.stateManager.setBankOverride({ rank, suit });
                        display.textContent = `Next bank card: ${rank} of ${suit}`;
                        console.log('🔧 Bank override set to:', rank, suit);
                    });
                    clearBtn.addEventListener('click', () => {
                        this.stateManager.clearBankOverride();
                        display.textContent = 'Next bank card: random';
                        console.log('🔧 Bank override cleared');
                    });
                }
            }

            setupEventListeners() {
                console.log('Setting up event listeners...');
                
                if (this.elements.startRoundBtn) {
                    this.elements.startRoundBtn.addEventListener('click', () => {
                        console.log('Start round button clicked');
                        this.startNewRound();
                    });
                } else {
                    console.error('Start round button not found!');
                }
                
                if (this.elements.adminPanelBtn) {
                    this.elements.adminPanelBtn.addEventListener('click', () => this.toggleAdminPanel());
                }
                
                if (this.elements.botControlBtn) {
                    this.elements.botControlBtn.addEventListener('click', () => this.toggleBotControlPanel());
                }
                
                // History panel event listeners
                if (this.elements.historyBtn) {
                    this.elements.historyBtn.addEventListener('click', () => this.toggleHistoryPanel());
                }
                
                // Make admin panel draggable
                this.makeAdminPanelDraggable();
                
                // Make bot control panel draggable
                this.makeBotControlPanelDraggable();
                
                // Make history panel draggable
                this.makeHistoryPanelDraggable();
                
                // Sound toggle control
                const soundToggle = document.getElementById('sound-toggle');
                if (soundToggle) {
                    soundToggle.addEventListener('change', (e) => {
                        this.soundManager.setEnabled(e.target.checked);
                        console.log('Sound effects:', e.target.checked ? 'enabled' : 'disabled');
                    });
                }
                
                // Close admin panel button
                const closeAdminBtn = document.getElementById('close-admin-btn');
                if (closeAdminBtn) {
                    closeAdminBtn.addEventListener('click', () => this.toggleAdminPanel());
                }

                // Close bot control panel button
                const closeBotControlBtn = document.getElementById('close-bot-control-btn');
                if (closeBotControlBtn) {
                    closeBotControlBtn.addEventListener('click', () => this.toggleBotControlPanel());
                }
                
                const closeHistoryBtn = document.getElementById('close-history-btn');
                if (closeHistoryBtn) {
                    closeHistoryBtn.addEventListener('click', () => this.toggleHistoryPanel());
                }

                // Rules button
                const rulesBtn = document.getElementById('rules-btn');
                if (rulesBtn) {
                    rulesBtn.addEventListener('click', () => this.showRules());
                }

                // Close rules button
                const closeRulesBtn = document.getElementById('close-rules-btn');
                if (closeRulesBtn) {
                    closeRulesBtn.addEventListener('click', () => this.hideRules());
                }

                // Turn order select
                const turnOrderSelect = document.getElementById('turn-order-select');
                if (turnOrderSelect) {
                    turnOrderSelect.addEventListener('change', (e) => {
                        console.log('Turn order changed to:', e.target.value);
                        // Hide all markers when changing turn order
                        this.gameLogic.hideAllTurnMarkers();
                        // Reset clockwise start player for new mode
                        if (e.target.value === 'C') {
                            this.gameLogic.clockwiseStartPlayer = undefined;
                        }
                    });
                }

                // Matrix button
                const matrixBtn = document.getElementById('matrix-btn');
                if (matrixBtn) {
                    matrixBtn.addEventListener('click', () => this.showMatrix());
                }

                // Close matrix button
                const closeMatrixBtn = document.getElementById('close-matrix-btn');
                if (closeMatrixBtn) {
                    closeMatrixBtn.addEventListener('click', () => this.hideMatrix());
                }
                
                // Rate controls
                const jackpotRate = document.getElementById('jackpot-rate');
                const bankRate = document.getElementById('bank-rate');
                
                if (jackpotRate) {
                    // Initialize with current values
                    jackpotRate.value = Math.round(GAME_CONFIG.JACKPOT_RATE * 100);
                    
                    jackpotRate.addEventListener('change', (e) => {
                        GAME_CONFIG.JACKPOT_RATE = parseFloat(e.target.value) / 100;
                        console.log('Jackpot rate updated to:', GAME_CONFIG.JACKPOT_RATE, '(', e.target.value, '%)');
                    });
                }
                
                if (bankRate) {
                    // Initialize with current values
                    bankRate.value = Math.round(GAME_CONFIG.BANK_RATE * 100);
                    
                    bankRate.addEventListener('change', (e) => {
                        GAME_CONFIG.BANK_RATE = parseFloat(e.target.value) / 100;
                        console.log('Bank rate updated to:', GAME_CONFIG.BANK_RATE, '(', e.target.value, '%)');
                    });
                }
                
                // Super jackpot rate control
                const superJackpotRate = document.getElementById('super-jackpot-rate');
                if (superJackpotRate) {
                    // Initialize with current values
                    superJackpotRate.value = Math.round(GAME_CONFIG.SUPER_JACKPOT_RATE * 100);
                    
                    superJackpotRate.addEventListener('change', (e) => {
                        const newRate = parseFloat(e.target.value) / 100;
                        if (newRate >= 0 && newRate <= 0.5) {
                            GAME_CONFIG.SUPER_JACKPOT_RATE = newRate;
                            console.log('Super jackpot rate updated to:', GAME_CONFIG.SUPER_JACKPOT_RATE, '(', e.target.value, '%)');
                        } else {
                            e.target.value = Math.round(GAME_CONFIG.SUPER_JACKPOT_RATE * 100); // Reset to current value
                        }
                    });
                }
                
                // Number of tables control
                const numberOfTables = document.getElementById('number-of-tables');
                if (numberOfTables) {
                    // Initialize with current values
                    numberOfTables.value = GAME_CONFIG.NUMBER_OF_TABLES;
                    
                    numberOfTables.addEventListener('change', (e) => {
                        const newTables = parseInt(e.target.value);
                        if (newTables >= 1 && newTables <= 100) {
                            GAME_CONFIG.NUMBER_OF_TABLES = newTables;
                            console.log('Number of tables updated to:', GAME_CONFIG.NUMBER_OF_TABLES);
                        } else {
                            e.target.value = GAME_CONFIG.NUMBER_OF_TABLES; // Reset to current value
                        }
                    });
                }
                
                // Admin panel is now always visible, so we don't auto-close it
                // document.addEventListener('click', (e) => {
                //     if (!this.elements.adminPanel.contains(e.target) && 
                //         !this.elements.adminPanelBtn.contains(e.target)) {
                //         this.elements.adminPanel.classList.add('hidden');
                //     }
                // });

                // Make rules modal draggable
                this.makeRulesModalDraggable();
                
                // Make matrix modal draggable
                this.makeMatrixModalDraggable();
                
                // Add pause/resume button listeners
                const pauseBtn = document.getElementById('pause-game-btn');
                const resumeBtn = document.getElementById('resume-game-btn');
                
                if (pauseBtn) {
                    pauseBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (!this.stateManager.isGamePaused()) {
                            console.log('⏸️ Pause button clicked - pausing game');
                            this.stateManager.pauseGame();
                            this.updatePauseButtons();
                            console.log('Game paused by admin');
                        } else {
                            console.log('⏸️ Game already paused, ignoring pause button click');
                        }
                    });
                }
                
                if (resumeBtn) {
                    resumeBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (this.stateManager.isGamePaused()) {
                            console.log('🔄 Resume button clicked - resuming game');
                            console.log('🔄 Game paused state:', this.stateManager.isGamePaused());
                            console.log('🔄 Paused state data:', this.stateManager.pausedState);
                            this.stateManager.resumeGame();
                            this.updatePauseButtons();
                            console.log('🔄 Game resumed by admin');
                        } else {
                            console.log('🔄 Game not paused, ignoring resume button click');
                        }
                    });
                }
                
                // Insurance event listeners
                if (this.elements.confirmInsuranceBtn) {
                    this.elements.confirmInsuranceBtn.addEventListener('click', () => {
                        this.confirmInsurancePurchases();
                    });
                }
                
                if (this.elements.skipInsuranceBtn) {
                    this.elements.skipInsuranceBtn.addEventListener('click', () => {
                        this.skipInsurance();
                    });
                }
                
                // Insurance timer setting
                if (this.elements.insuranceTimer) {
                    this.elements.insuranceTimer.addEventListener('change', (e) => {
                        const newTimer = parseInt(e.target.value);
                        if (newTimer >= 5 && newTimer <= 30) {
                            console.log(`Insurance timer updated to ${newTimer} seconds`);
                        }
                    });
                }
                
                // Insurance cost setting
                if (this.elements.insuranceCostInput) {
                    this.elements.insuranceCostInput.addEventListener('change', (e) => {
                        const newCost = parseInt(e.target.value);
                        if (newCost >= 1 && newCost <= 100) {
                            GAME_CONFIG.INSURANCE_COST = newCost;
                            console.log(`Insurance cost updated to $${newCost}`);
                        } else {
                            e.target.value = GAME_CONFIG.INSURANCE_COST; // Reset to current value
                        }
                    });
                }
                
                // Insurance minimum pot setting
                if (this.elements.insuranceMinPotInput) {
                    this.elements.insuranceMinPotInput.addEventListener('change', (e) => {
                        const newMinPot = parseInt(e.target.value);
                        if (newMinPot >= 10 && newMinPot <= 500) {
                            GAME_CONFIG.INSURANCE_MIN_POT = newMinPot;
                            console.log(`Insurance minimum pot updated to $${newMinPot}`);
                        } else {
                            e.target.value = GAME_CONFIG.INSURANCE_MIN_POT; // Reset to current value
                        }
                    });
                }
                
                // Human insurance icon click handlers
                this.setupHumanInsuranceListeners();
                
                // Insurance behavior dropdown for human player
                this.setupInsuranceBehaviorListener();
                
                console.log('Event listeners set up');
            }
            
            setupHumanInsuranceListeners() {
                // Set up click handlers for human insurance icons (will be called after seats are created)
                document.addEventListener('click', (e) => {
                    // Check if click is on the icon or any of its children
                    const icon = e.target.closest('.human-insurance-icon');
                    if (icon && !icon.classList.contains('disabled')) {
                        const playerId = parseInt(icon.id.replace('human-insurance-', ''));
                        console.log(`Human insurance icon clicked for player ${playerId}`);
                        this.handleHumanInsuranceClick(playerId);
                    }
                });
            }
            
            getHumanInsuranceBehavior() {
                const insuranceSelect = document.getElementById('insurance-select-0');
                if (insuranceSelect) {
                    return insuranceSelect.value;
                }
                return 'ask'; // Default to ask
            }
            
            setHumanInsuranceBehavior(behavior) {
                const insuranceSelect = document.getElementById('insurance-select-0');
                if (insuranceSelect) {
                    insuranceSelect.value = behavior;
                }
            }
            
            setupInsuranceBehaviorListener() {
                // Set up event listener for insurance behavior dropdown
                document.addEventListener('change', (e) => {
                    if (e.target.classList.contains('insurance-select')) {
                        const playerId = parseInt(e.target.id.replace('insurance-select-', ''));
                        const behavior = e.target.value;
                        console.log(`🛡️ Insurance behavior changed for player ${playerId}: ${behavior}`);
                        
                        // Store the preference (could be saved to localStorage or game state)
                        if (playerId === 0) { // Human player
                            console.log(`🛡️ Human player insurance behavior set to: ${behavior}`);
                        }
                    }
                });
                
                // Set up event listener for strategy buttons
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('strategy-btn')) {
                        const strategy = e.target.getAttribute('data-strategy');
                        const playerId = 0; // Human player
                        console.log(`Strategy changed to: ${strategy}`);
                        
                        // Update active button
                        const buttons = e.target.parentElement.querySelectorAll('.strategy-btn');
                        buttons.forEach(btn => btn.classList.remove('active'));
                        e.target.classList.add('active');
                        
                        // Update player strategy
                        if (this.stateManager) {
                            this.stateManager.updatePlayerStrategy(playerId, strategy);
                        }
                    }
                });
            }
            
            handleHumanInsuranceClick(playerId) {
                console.log(`🛡️ handleHumanInsuranceClick called for player ${playerId}`);
                const gameData = this.stateManager.getGameData();
                const player = gameData.players.find(p => p.id === playerId);
                
                console.log(`Player found: ${player ? player.name : 'NOT FOUND'}`);
                console.log(`Current state: ${this.stateManager.getState()}`);
                console.log(`Insurance purchase state: ${GAME_STATES.INSURANCE_PURCHASE}`);
                
                if (!player) {
                    console.log('Early return: player not found');
                    return;
                }
                
                // Check if insurance phase is active
                const currentState = this.stateManager.getState();
                console.log(`Current state check: ${currentState} === ${GAME_STATES.INSURANCE_PURCHASE}? ${currentState === GAME_STATES.INSURANCE_PURCHASE}`);
                if (currentState !== GAME_STATES.INSURANCE_PURCHASE) {
                    console.log('Insurance can only be purchased during insurance phase');
                    console.log(`Current state: ${currentState}, Required state: ${GAME_STATES.INSURANCE_PURCHASE}`);
                    return;
                }
                
                // Check if player can afford insurance
                if (player.balance < GAME_CONFIG.INSURANCE_COST) {
                    console.log(`Player ${player.name} cannot afford insurance ($${GAME_CONFIG.INSURANCE_COST})`);
                    return;
                }
                
                // Check if insurance pot meets minimum requirement (only for purchases, not cancellations)
                if (!player.hasInsurance) {
                    const insurancePot = gameData.insuranceJackpot || 0;
                    if (insurancePot < GAME_CONFIG.INSURANCE_MIN_POT) {
                        console.log(`🛡️ Insurance pot too small: $${insurancePot} < $${GAME_CONFIG.INSURANCE_MIN_POT} - purchase not allowed`);
                        return;
                    }
                }
                
                // Toggle insurance purchase
                if (player.hasInsurance) {
                    // Cancel insurance
                    this.stateManager.updatePlayer(playerId, { hasInsurance: false });
                    this.stateManager.updatePlayerBalance(playerId, GAME_CONFIG.INSURANCE_COST); // Refund
                    console.log(`${player.name} cancelled insurance purchase`);
                } else {
                    // Buy insurance
                    this.stateManager.updatePlayer(playerId, { hasInsurance: true });
                    this.stateManager.updatePlayerBalance(playerId, -GAME_CONFIG.INSURANCE_COST);
                    
                    // Add insurance cost to insurance jackpot
                    gameData.insuranceJackpot += GAME_CONFIG.INSURANCE_COST;
                    
                    console.log(`${player.name} purchased insurance for $${GAME_CONFIG.INSURANCE_COST}`);
                }
                
                // Update player display
                this.updatePlayerDisplay(playerId);
                
                // Add/remove insurance marker and update insurance jackpot
                const updatedPlayer = this.stateManager.getGameData().players.find(p => p.id === playerId);
                if (updatedPlayer && updatedPlayer.hasInsurance) {
                    this.addInsuranceMarker(playerId);
                    this.updateInsuranceJackpotDisplay();
                } else {
                    // If insurance cancelled, remove marker
                    const marker = document.querySelector(`.insurance-marker[data-player-id="${playerId}"]`);
                    if (marker) {
                        marker.remove();
                    }
                    // Also subtract from pot if cancelling
                    if (player.hasInsurance && !updatedPlayer.hasInsurance) {
                        gameData.insuranceJackpot = Math.max(0, gameData.insuranceJackpot - GAME_CONFIG.INSURANCE_COST);
                        this.updateInsuranceJackpotDisplay();
                    }
                }
                
                // Update button text to show current state
                const buyBtn = document.getElementById('buy-insurance-btn');
                if (buyBtn) {
                    const updatedPlayer = this.stateManager.getGameData().players.find(p => p.id === playerId);
                    if (updatedPlayer && updatedPlayer.hasInsurance) {
                        buyBtn.textContent = 'Cancel Insurance';
                        buyBtn.style.background = '#27ae60';
                    } else {
                        buyBtn.textContent = 'Buy Insurance';
                        buyBtn.style.background = '#e74c3c';
                    }
                }
            }
            
            initializeInsuranceSettings() {
                // Initialize insurance setting inputs with current GAME_CONFIG values
                if (this.elements.insuranceCostInput) {
                    this.elements.insuranceCostInput.value = GAME_CONFIG.INSURANCE_COST;
                }
                if (this.elements.insuranceMinPotInput) {
                    this.elements.insuranceMinPotInput.value = GAME_CONFIG.INSURANCE_MIN_POT;
                }
                if (this.elements.insuranceTimer) {
                    this.elements.insuranceTimer.value = GAME_CONFIG.INSURANCE_TIMER;
                }
            }

            updatePauseButtons() {
                const pauseBtn = document.getElementById('pause-game-btn');
                const resumeBtn = document.getElementById('resume-game-btn');
                const gameState = document.getElementById('game-state');
                
                if (this.stateManager.isGamePaused()) {
                    if (pauseBtn) {
                        pauseBtn.disabled = true;
                        pauseBtn.textContent = 'Game Paused';
                        pauseBtn.style.backgroundColor = '#666';
                    }
                    if (resumeBtn) {
                        resumeBtn.disabled = false;
                        resumeBtn.textContent = 'Resume Game';
                        resumeBtn.style.backgroundColor = '#28a745';
                    }
                    if (gameState) {
                        gameState.textContent = '⏸️ GAME PAUSED - Click Resume to continue';
                        gameState.style.color = '#ff6b6b';
                        gameState.style.fontWeight = 'bold';
                    }
                } else {
                    if (pauseBtn) {
                        pauseBtn.disabled = false;
                        pauseBtn.textContent = 'Pause Game';
                        pauseBtn.style.backgroundColor = '#dc3545';
                    }
                    if (resumeBtn) {
                        resumeBtn.disabled = true;
                        resumeBtn.textContent = 'Game Running';
                        resumeBtn.style.backgroundColor = '#666';
                    }
                    if (gameState) {
                        gameState.style.color = '';
                        gameState.style.fontWeight = '';
                        // Clear paused banner text immediately on resume
                        gameState.textContent = '';
                    }
                }
            }

            showRules() {
                const rulesModal = document.getElementById('rules-modal');
                if (rulesModal) {
                    rulesModal.classList.remove('hidden');
                }
            }

            hideRules() {
                const rulesModal = document.getElementById('rules-modal');
                if (rulesModal) {
                    rulesModal.classList.add('hidden');
                }
            }

            showMatrix() {
                const matrixModal = document.getElementById('matrix-modal');
                if (matrixModal) {
                    matrixModal.classList.remove('hidden');
                }
            }

            hideMatrix() {
                const matrixModal = document.getElementById('matrix-modal');
                if (matrixModal) {
                    matrixModal.classList.add('hidden');
                }
            }

            setupBotStrategyListeners() {
                // Add event listeners for all bot strategy dropdowns and human strategy buttons
                for (let i = 0; i < GAME_CONFIG.TOTAL_PLAYERS; i++) {
                    const player = this.stateManager.getPlayer(i);
                    
                    if (!player) {
                        console.log(`Player ${i} not found, skipping...`);
                        continue;
                    }
                    
                    if (player.isHuman) {
                        // Human player gets strategy buttons
                        const strategyButtons = document.querySelectorAll(`#player-${i} .strategy-btn, #human-strategy-${i} .strategy-btn`);
                        strategyButtons.forEach(button => {
                            button.addEventListener('click', (e) => {
                                e.preventDefault();
                                const strategy = button.dataset.strategy;
                                console.log(`Human player strategy changed to: ${strategy}`);
                                
                                // Update active button in both locations
                                const allButtons = document.querySelectorAll(`#player-${i} .strategy-btn, #human-strategy-${i} .strategy-btn`);
                                allButtons.forEach(btn => btn.classList.remove('active'));
                                button.classList.add('active');
                                
                                // Update player strategy in state
                                this.stateManager.updatePlayerStrategy(i, strategy);
                            });
                        });
                    } else {
                        // Bot controls moved to Bot Control Panel
                        // No individual controls needed here anymore
                    }
                }
            }

            setupStateListeners() {
                this.stateManager.addStateListener((newState, oldState) => {
                    this.handleStateChange(newState, oldState);
                });
            }

            handleStateChange(newState, oldState) {
                console.log(`UI: State changed from ${oldState} to ${newState}`);
                // If we are leaving round_summary, cancel any pending auto-start
                if (oldState === GAME_STATES.ROUND_SUMMARY && this.autoStartTimer) {
                    clearTimeout(this.autoStartTimer);
                    this.autoStartTimer = null;
                }
                
                switch (newState) {
                    case GAME_STATES.WAITING_FOR_ROUND_START:
                        this.updateWaitingState();
                        break;
                    case GAME_STATES.CARD_SELECTION:
                        this.updateCardSelectionState();
                        break;
                    case GAME_STATES.REVEALING_CARDS:
                        this.updateRevealingCardsState();
                        break;
                    case GAME_STATES.BANK_DRAW:
                        this.updateBankDrawState();
                        break;
                    case GAME_STATES.DISTRIBUTE_WINNINGS:
                        this.updateDistributeWinningsState();
                        break;
                    case GAME_STATES.ROUND_SUMMARY:
                        this.updateRoundSummaryState();
                        break;
                }
            }

            initializeGame() {
                console.log('Initializing game UI...');
                this.createPlayerSeats();
                this.updateGameDisplay();
                // updateAdminPanel() is now called automatically from updateGameDisplay()
                // Clear any existing result text from previous games
                this.clearPlayerResultClasses();
                console.log('Game UI initialized');
            }

            createPlayerSeats() {
                console.log('Creating player seats...');
                this.elements.playerSeats.innerHTML = '';
                
                const gameData = this.stateManager.getGameData();
                console.log('Game data for seats:', gameData);
                
                // Table is 900px x 700px, so center is at 450, 350
                const centerX = 450;
                const centerY = 350;
                const radiusX = 350; // Horizontal radius
                const radiusY = 250; // Vertical radius
                
                gameData.players.forEach((player, index) => {
                    // Calculate angle for each player (starting from top, going clockwise)
                    const angle = (index * 2 * Math.PI) / GAME_CONFIG.TOTAL_PLAYERS - Math.PI / 2;
                    const x = centerX + radiusX * Math.cos(angle) - 60; // -60 to center the seat
                    let y = centerY + radiusY * Math.sin(angle) - 40; // -40 to center the seat
                    
                    // Move specific players higher up (closer to edge of table)
                    if (player.id === 8 || player.id === 0 || player.id === 1) {
                        y -= 50; // Move 50px higher up
                    }
                    
                    // Move bot2 and bot7 2% higher up (additional 2%)
                    if (player.id === 2 || player.id === 7) {
                        y -= radiusY * 0.04; // 4% of vertical radius (2% + 2% more)
                    }
                    
                    const seat = document.createElement('div');
                    seat.className = `player-seat ${player.isHuman ? 'human' : ''}`;
                    seat.id = `player-${player.id}`;
                    seat.style.left = `${x}px`;
                    seat.style.top = `${y}px`;
                    
                    seat.innerHTML = `
                        <div class="turn-marker" id="turn-marker-${player.id}">👑</div>
                        <div class="player-name">${player.name}</div>
                        <div class="player-balance">$${player.balance}</div>
                        <div class="bot-controls" id="bot-controls-${player.id}">
                            ${player.isHuman ? `
                                <div class="strategy-buttons">
                                    <button class="strategy-btn ${player.strategy === 'random' ? 'active' : ''}" data-strategy="random">Random</button>
                                    <button class="strategy-btn ${player.strategy === 'lowest' ? 'active' : ''}" data-strategy="lowest">Lowest</button>
                                    <button class="strategy-btn ${player.strategy === 'highest' ? 'active' : ''}" data-strategy="highest">Highest</button>
                                    <button class="strategy-btn ${player.strategy === 'manual' ? 'active' : ''}" data-strategy="manual">Manual</button>
                                </div>
                            ` : `
                                <!-- Bot controls moved to Bot Control Panel -->
                            `}
                            <div class="manual-timer" id="manual-timer-${player.id}" style="display: none;">
                                <span class="timer-text">5s</span>
                            </div>
                        </div>
                        <div class="player-card" id="card-${player.id}" style="background: linear-gradient(145deg, #fff, #f0f0f0); border: 2px solid #333; color: #333;"></div>
                    `;
                    
                    // For "You" player, create strategy buttons outside the seat to the left
                    if (player.id === 0) {
                        const strategyContainer = document.createElement('div');
                        strategyContainer.className = 'human-strategy-container';
                        strategyContainer.id = `human-strategy-${player.id}`;
                        strategyContainer.innerHTML = `
                            <div class="strategy-buttons">
                                <button class="strategy-btn ${player.strategy === 'random' ? 'active' : ''}" data-strategy="random">Random</button>
                                <button class="strategy-btn ${player.strategy === 'lowest' ? 'active' : ''}" data-strategy="lowest">Lowest</button>
                                <button class="strategy-btn ${player.strategy === 'highest' ? 'active' : ''}" data-strategy="highest">Highest</button>
                                <button class="strategy-btn ${player.strategy === 'manual' ? 'active' : ''}" data-strategy="manual">Manual</button>
                            </div>
                            <div class="insurance-behavior" id="insurance-behavior-${player.id}">
                                <label for="insurance-select-${player.id}">Insurance:</label>
                                <select class="insurance-select" id="insurance-select-${player.id}">
                                    <option value="ask" selected>Ask before round</option>
                                    <option value="always">Always buy</option>
                                    <option value="never">Never buy</option>
                                </select>
                            </div>
                        `;
                        
                        // Position strategy container outside the player's golden frame (seat)
                        // Player seat is 120px wide, so place buttons to the left of it
                        const strategyX = x - 80; // Position to the left of the player seat, half of last step
                        const strategyY = y + 10;  // Align with top of seat
                        strategyContainer.style.left = `${strategyX}px`;
                        strategyContainer.style.top = `${strategyY}px`;
                        
                        this.elements.playerSeats.appendChild(strategyContainer);
                        
                        // Hide the strategy buttons inside the seat for "You" player
                        const seatControls = seat.querySelector('.bot-controls');
                        if (seatControls) {
                            seatControls.style.display = 'none';
                        }
                    }
                    
                    // Human players can click directly on table cards when it's their turn
                    // No need for seat click handler
                    
                    this.elements.playerSeats.appendChild(seat);
                    
                    // Create chip stack next to player seat
                    const chipStack = document.createElement('div');
                    chipStack.className = 'chip-stack-container';
                    chipStack.id = `chip-stack-${player.id}`;
                    chipStack.innerHTML = this.generateChipStack(player.balance);
                    
                    // Position chip stack next to player seat
                    // For "You" player (id 0), move chip stack to the right to avoid covering controls
                    let stackX, stackY;
                    if (player.id === 0) {
                        stackX = x + 130; // To the right of seat
                        stackY = y + 20;  // Align with middle of seat
                    } else {
                        stackX = x + 130; // To the right of seat
                        stackY = y + 20;  // Align with middle of seat
                    }
                    
                    chipStack.style.left = `${stackX}px`;
                    chipStack.style.top = `${stackY}px`;
                    
                    this.elements.playerSeats.appendChild(chipStack);
                });
                
                // Setup bot strategy listeners after seats are created
                this.setupBotStrategyListeners();
            }

            updatePlayerSeats() {
                console.log('Updating player seats...');
                const gameData = this.stateManager.getGameData();
                
                if (!gameData || !gameData.players || gameData.players.length === 0) {
                    console.log('No game data available, skipping player seat update');
                    return;
                }
                
                gameData.players.forEach(player => {
                    // Update balance
                    const balanceElement = document.querySelector(`#player-${player.id} .player-balance`);
                    if (balanceElement) {
                        balanceElement.textContent = `$${Math.round(player.balance)}`;
                    }
                    
                    // Clear player card - IMPORTANT: Clear ALL content including any child elements
                    const cardElement = document.querySelector(`#player-${player.id} .player-card`);
                    if (cardElement) {
                        // Remove all child nodes
                        while (cardElement.firstChild) {
                            cardElement.removeChild(cardElement.firstChild);
                        }
                        // Clear innerHTML to be sure
                        cardElement.innerHTML = '';
                        // Reset class and styles
                        cardElement.className = 'player-card';
                        cardElement.style.background = '';
                        cardElement.style.border = '';
                        cardElement.style.color = '';
                        console.log(`🎴 Cleared card area for player ${player.id} (${player.name})`);
                    }
                    
                    // Clear result classes
                    const seatElement = document.querySelector(`#player-${player.id}`);
                    if (seatElement) {
                        seatElement.classList.remove('win', 'loss', 'refund', 'jackpot', 'card-selected');
                    }
                });
                
                // Re-setup bot strategy listeners to preserve functionality
                this.setupBotStrategyListeners();
            }

            showCardSelectionModal(playerId) {
                console.log('=== showCardSelectionModal called with playerId:', playerId, '===');
                const player = this.stateManager.getPlayer(playerId);
                console.log('Player details:', player);
                
                // Only proceed if this is a human player
                if (!player || !player.isHuman) {
                    console.log('=== showCardSelectionModal: Not a human player, skipping ===');
                    return;
                }
                
                const availableCards = this.stateManager.getAvailableCards();
                console.log('Available cards:', availableCards);
                
                // Additional debugging for first player
                if (playerId === 0) {
                    console.log('=== FIRST PLAYER DEBUG ===');
                    console.log('Game state:', this.stateManager.getState());
                    console.log('Player strategy:', player.strategy);
                    console.log('Player isHuman:', player.isHuman);
                    console.log('Available cards count:', availableCards.length);
                }
                
                // Don't clean up duplicate cards during human player's turn
                // This prevents bot cards from disappearing when it's the human's turn
                console.log('Skipping duplicate card cleanup during human player turn');
                
                // Clear all existing event listeners first
                const tableCards = document.querySelectorAll('.table-card');
                console.log('Found table cards:', tableCards.length);
                tableCards.forEach(card => {
                    if (card._cardClickHandler) {
                        card.removeEventListener('click', card._cardClickHandler);
                        card._cardClickHandler = null;
                    }
                });
                
                // Enable table cards for selection
                tableCards.forEach(card => {
                    const rank = card.dataset.rank;
                    console.log(`Processing card ${rank}, available: ${availableCards.includes(rank)}`);
                    if (availableCards.includes(rank)) {
                        card.classList.remove('unavailable');
                        card.style.pointerEvents = 'auto';
                        card.style.cursor = 'pointer';
                        // Find the card-rank element inside this card
                        const cardRankElement = card.querySelector('.card-rank');
                        
                        if (cardRankElement) {
                            // Create new event handler for the card-rank element
                            cardRankElement._cardClickHandler = (e) => {
                            console.log('=== HUMAN PLAYER CARD CLICKED ===');
                            console.log('Card clicked, calling selectTableCard with playerId:', playerId);
                                console.log('Card element:', card);
                                console.log('Card rank:', card.dataset.rank);
                                console.log('Event target:', e.target);
                                console.log('Event currentTarget:', e.currentTarget);
                                console.log('Player ID from handler:', playerId);
                                console.log('Game state at click:', this.stateManager.getState());
                            e.preventDefault();
                            e.stopPropagation();
                            this.selectTableCard(card, playerId);
                        };
                            cardRankElement.addEventListener('click', cardRankElement._cardClickHandler, true); // Use capture phase
                            console.log(`Added click handler to card-rank element ${rank} for human player`);
                        } else {
                            console.log(`Warning: No .card-rank element found inside card ${rank}`);
                        }
                        
                        // Add test event listeners to the card-rank element if it exists
                        if (cardRankElement) {
                            // Add a simple test to verify the card-rank is clickable
                            cardRankElement.addEventListener('mousedown', () => {
                                console.log(`Mouse down on card-rank ${rank} - card is responsive for human player`);
                            });
                            
                            // Add hover test to verify card-rank is interactive
                            cardRankElement.addEventListener('mouseenter', () => {
                                console.log(`Mouse entered card-rank ${rank} - card is interactive`);
                            });
                            
                            // Add click test to verify card-rank is clickable
                            cardRankElement.addEventListener('click', (e) => {
                                console.log(`=== CARD-RANK CLICK TEST: Card ${rank} was clicked ===`);
                                console.log(`Event target:`, e.target);
                                console.log(`Card element:`, card);
                                console.log(`Card-rank element:`, cardRankElement);
                                console.log(`Card classes:`, card.className);
                                console.log(`Card pointer events:`, card.style.pointerEvents);
                            }, false); // Use bubble phase for testing
                        }
                        
                        // Test if the event listener was actually added
                        console.log(`Card ${rank} event listener test:`, {
                            hasOnClick: card.onclick !== null,
                            hasAddEventListener: typeof card.addEventListener === 'function',
                            eventListeners: card.getEventListeners ? card.getEventListeners() : 'not available'
                        });
                        
                        // Debug card CSS properties
                        const computedStyle = window.getComputedStyle(card);
                        const rect = card.getBoundingClientRect();
                        console.log(`Card ${rank} CSS debug:`, {
                            pointerEvents: computedStyle.pointerEvents,
                            display: computedStyle.display,
                            visibility: computedStyle.visibility,
                            opacity: computedStyle.opacity,
                            zIndex: computedStyle.zIndex,
                            position: computedStyle.position,
                            rect: {
                                top: rect.top,
                                left: rect.left,
                                width: rect.width,
                                height: rect.height,
                                visible: rect.width > 0 && rect.height > 0
                            }
                        });
                        
                        // Also check if the card is actually clickable
                        console.log(`Card ${rank} clickability test:`, {
                            hasClickHandler: card.onclick !== null,
                            hasEventListener: card.addEventListener ? 'yes' : 'no',
                            stylePointerEvents: card.style.pointerEvents,
                            computedPointerEvents: computedStyle.pointerEvents,
                            isVisible: rect.width > 0 && rect.height > 0,
                            isInViewport: rect.top >= 0 && rect.left >= 0
                        });
                    } else {
                        // Don't mark selected cards as unavailable - they should remain visible
                        // card.classList.add('unavailable');
                        // card.style.pointerEvents = 'none';
                        console.log(`Card ${rank} is already selected, keeping it visible`);
                    }
                });
                console.log('=== Human player card selection setup complete ===');
                
                // Debug: Check if click handlers are still attached after setup
                const testCards = document.querySelectorAll('.table-card');
                testCards.forEach((card, index) => {
                    const cardRankElement = card.querySelector('.card-rank');
                    if (cardRankElement) {
                        console.log(`Post-setup check - Card ${index}:`, {
                            hasClickHandler: cardRankElement._cardClickHandler !== undefined,
                            cardRankElement: cardRankElement,
                            cardRankText: cardRankElement.textContent
                        });
                    }
                });
                
                // Debug: Check if any elements are covering the cards
                const gameTable = document.querySelector('.game-table');
                if (gameTable) {
                    const allElements = gameTable.querySelectorAll('*');
                    console.log(`Found ${allElements.length} elements in game table`);
                    
                    // Check for elements with high z-index that might be covering cards
                    allElements.forEach((el, index) => {
                        const style = window.getComputedStyle(el);
                        const zIndex = parseInt(style.zIndex);
                        if (zIndex > 100) {
                            console.log(`High z-index element ${index}:`, {
                                tagName: el.tagName,
                                className: el.className,
                                id: el.id,
                                zIndex: zIndex,
                                position: style.position,
                                pointerEvents: style.pointerEvents
                            });
                        }
                    });
                    
                    // Test if any elements are covering the cards
                    const tableCards = document.querySelectorAll('.table-card');
                    tableCards.forEach((card, index) => {
                        const rect = card.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        
                        // Check what element is at the center of each card
                        const elementAtCenter = document.elementFromPoint(centerX, centerY);
                        console.log(`Card ${index} center element:`, {
                            card: card,
                            centerElement: elementAtCenter,
                            isCard: elementAtCenter === card,
                            centerElementTag: elementAtCenter ? elementAtCenter.tagName : 'none',
                            centerElementClass: elementAtCenter ? elementAtCenter.className : 'none'
                        });
                    });
                }
            }

            selectTableCard(cardElement, playerId) {
                console.log('=== selectTableCard called ===');
                console.log('PlayerId:', playerId);
                console.log('Card element:', cardElement);
                console.log('Card rank:', cardElement.dataset.rank);
                console.log('Card classes:', cardElement.className);
                console.log('Card pointer events:', cardElement.style.pointerEvents);
                
                const rank = cardElement.dataset.rank;
                console.log('Selected rank:', rank);
                
                // Check if card is already selected
                if (cardElement.classList.contains('selected')) {
                    console.log('Card already selected, ignoring click');
                    return;
                }
                
                // Check if player already has a selected card
                const player = this.stateManager.getPlayer(playerId);
                if (player && player.selectedCard) {
                    console.log('Player already has a selected card, ignoring click');
                    return;
                }
                
                // Assign a random suit when card is selected
                const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
                const suit = suits[Math.floor(Math.random() * suits.length)];
                const selectedCard = { rank, suit };
                console.log('Selected card:', selectedCard);
                
                console.log('=== About to call stateManager.selectCard ===');
                console.log('Current game state:', this.stateManager.getState());
                console.log('Player ID:', playerId);
                console.log('Selected card:', selectedCard);
                console.log('Current selected cards:', this.stateManager.getGameData().selectedCards);
                
                const selectionResult = this.stateManager.selectCard(playerId, selectedCard);
                console.log('Selection result:', selectionResult);
                
                if (selectionResult) {
                    console.log('Card selection successful for player:', playerId);
                    
                    // Clear the status text to avoid confusion
                    this.elements.gameState.textContent = 'Players selecting cards...';
                    
                    // Play card selection sound
                    this.soundManager.playSound('cardSelect');
                    
                    // Clear countdown timer if it exists
                    this.stopManualCountdown();
                    
                    // Get player name for display
                    const player = this.stateManager.getPlayer(playerId);
                    const playerName = player ? player.name : `Player ${playerId}`;
                    
                    // Mark card as selected with player name
                    cardElement.classList.add('selected');
                    cardElement.setAttribute('data-selected-by', playerName);
                    
                    // White card styling for all players
                    cardElement.style.background = 'linear-gradient(145deg, #fff, #f0f0f0)';
                    cardElement.style.border = '2px solid #333';
                    cardElement.style.color = '#333';
                    cardElement.style.fontWeight = 'bold';
                    
                    // Show player name on card
                    const originalText = cardElement.textContent;
                    cardElement.textContent = `${originalText}\n${playerName}`;
                    
                    // Update displays
                    this.updatePlayerDisplay(playerId);
                    this.updateGameDisplay();
                    
                    // Animate card to player seat for human player too
                    this.animateCardToPlayerSeat(cardElement, playerId);
                    
                    // Animate chip from player to card for human player
                    setTimeout(() => {
                        this.animateChipToCard(playerId, cardElement);
                    }, 200);
                    
                    // Remove card from table after a short delay
                    setTimeout(() => {
                        if (cardElement && cardElement.parentNode) {
                            cardElement.remove();
                            console.log(`Removed selected card from table for player ${playerId}`);
                        }
                    }, 500); // Short delay to allow visual feedback
                    
                    // Check if all cards are selected and continue game
                    console.log('=== Checking if all cards are selected ===');
                    const allSelected = this.stateManager.allCardsSelected();
                    const selectedCount = this.stateManager.getGameData().selectedCards.size;
                    const totalPlayers = GAME_CONFIG.TOTAL_PLAYERS;
                    
                    console.log(`All selected: ${allSelected}, Selected count: ${selectedCount}, Total players: ${totalPlayers}`);
                    
                    if (allSelected) {
                        console.log('=== All cards selected, moving to reveal phase ===');
                        this.stateManager.setState(GAME_STATES.REVEALING_CARDS);
                    } else {
                        console.log('=== Not all cards selected, continuing with remaining players ===');
                        console.log('Current game state before continue:', this.stateManager.getState());
                        
                        // Always continue with remaining players, regardless of player type
                        console.log('=== Continuing with remaining players ===');
                        
                        // Simple continuation - just call the function directly
                        setTimeout(() => {
                            console.log('=== Calling continueWithRemainingPlayers after timeout ===');
                            try {
                                this.continueWithRemainingPlayers();
                            } catch (error) {
                                console.error('Error in continueWithRemainingPlayers:', error);
                            }
                        }, 1000);
                    }
                } else {
                    console.log('=== Card selection failed ===');
                    console.log('Current game state:', this.stateManager.getState());
                    console.log('Expected state:', GAME_STATES.CARD_SELECTION);
                    console.log('Current selected cards:', this.stateManager.getGameData().selectedCards);
                    
                    // Check if card is already selected and show who selected it
                    const selectedBy = cardElement.getAttribute('data-selected-by');
                    if (selectedBy) {
                        alert(`This card is already selected by ${selectedBy}!`);
                    } else {
                        alert('Card already selected or invalid selection!');
                    }
                }
            }

            startManualCountdown(playerId, playerName) {
                console.log(`Starting manual countdown for ${playerName} (ID: ${playerId})`);
                
                // First, aggressively clean up any existing timers
                this.stopManualCountdown();
                console.log(`Cleaned up any existing timers before starting new one`);
                
                // Additional cleanup - ensure no timer intervals are left running
                if (this.manualTimerInterval) {
                    clearInterval(this.manualTimerInterval);
                    this.manualTimerInterval = null;
                }
                if (this.countdownTimer) {
                    clearInterval(this.countdownTimer);
                    this.countdownTimer = null;
                }
                
                // Clear any timer intervals that might be stored elsewhere
                if (window.gameTimerInterval) {
                    clearInterval(window.gameTimerInterval);
                    window.gameTimerInterval = null;
                }
                if (window.manualTimerInterval) {
                    clearInterval(window.manualTimerInterval);
                    window.manualTimerInterval = null;
                }
                
                // Nuclear option - clear ALL possible timer intervals
                // This is aggressive but necessary to prevent leftover timers
                for (let i = 1; i < 10000; i++) {
                    clearInterval(i);
                }
                console.log(`Cleared ALL timer intervals (nuclear option)`);
                
                // Add a small delay to ensure all timers are completely stopped
                setTimeout(() => {
                    this.startManualCountdownDelayed(playerId, playerName);
                }, 100);
            }
            
            startManualCountdownDelayed(playerId, playerName) {
                console.log(`Starting delayed manual countdown for ${playerName} (ID: ${playerId})`);
                
                const playerSeat = document.getElementById(`player-${playerId}`);
                if (!playerSeat) {
                    console.error(`Player seat not found for ID: ${playerId}`);
                    return;
                }

                console.log(`Player seat found:`, playerSeat);

                // Remove any existing timer element first
                const existingTimer = document.getElementById(`manual-timer-${playerId}`);
                if (existingTimer) {
                    existingTimer.remove();
                    console.log(`Removed existing timer element`);
                }

                // Create a completely new timer element with inline styles
                console.log(`Creating brand new timer element for player ${playerId}`);
                const timerElement = document.createElement('div');
                timerElement.id = `manual-timer-${playerId}`;
                
                // Apply proper timer styles inline to avoid any CSS interference
                timerElement.style.cssText = `
                    position: fixed !important;
                    top: 50% !important;
                    left: 50% !important;
                    transform: translate(-50%, -50%) !important;
                    margin-top: -80px !important;
                    width: 120px !important;
                    height: 40px !important;
                    background-color: rgba(255, 255, 255, 0.95) !important;
                    border: 2px solid #ff0000 !important;
                    font-size: 20px !important;
                    color: #ff0000 !important;
                    font-weight: bold !important;
                    display: block !important;
                    visibility: visible !important;
                    opacity: 1 !important;
                    z-index: 99999 !important;
                    text-align: center !important;
                    line-height: 40px !important;
                    border-radius: 5px !important;
                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3) !important;
                `;
                
                timerElement.textContent = '30';
                document.body.appendChild(timerElement);
                console.log(`Brand new timer element added to body with inline styles`);
                console.log(`Timer element initial text: ${timerElement.textContent}`);

                console.log(`Timer element:`, timerElement);

                // Show the timer
                timerElement.style.setProperty('display', 'block', 'important');
                timerElement.style.setProperty('visibility', 'visible', 'important');
                timerElement.style.setProperty('opacity', '1', 'important');

                console.log(`Timer styles applied - display: ${timerElement.style.display}, visibility: ${timerElement.style.visibility}, opacity: ${timerElement.style.opacity}`);
                const computedStyles = window.getComputedStyle(timerElement);
                const position = timerElement.getBoundingClientRect();
                console.log(`Timer element computed styles:`, {
                    display: computedStyles.display,
                    visibility: computedStyles.visibility,
                    opacity: computedStyles.opacity,
                    position: computedStyles.position,
                    top: computedStyles.top,
                    left: computedStyles.left,
                    zIndex: computedStyles.zIndex,
                    width: computedStyles.width,
                    height: computedStyles.height
                });
                console.log(`Timer element position:`, {
                    top: position.top,
                    left: position.left,
                    width: position.width,
                    height: position.height,
                    visible: position.width > 0 && position.height > 0
                });

                let timeLeft = 30;
                console.log(`Timer element created with inline styles, starting countdown from ${timeLeft}`);
                
                // Ensure timer element shows correct initial value
                timerElement.textContent = timeLeft;
                console.log(`Timer element text set to: ${timerElement.textContent}`);
                
                const countdown = setInterval(() => {
                    timeLeft--;
                    timerElement.textContent = timeLeft;
                    console.log(`Timer countdown: ${timeLeft} seconds remaining`);
                    
                    if (timeLeft <= 0) {
                        clearInterval(countdown);
                        console.log(`Manual countdown expired for ${playerName}`);
                        
                        // Hide timer
                        timerElement.style.setProperty('display', 'none', 'important');
                        timerElement.style.setProperty('visibility', 'hidden', 'important');
                        timerElement.style.setProperty('opacity', '0', 'important');
                        
                        // Auto-select a random card if no selection made
                        const gameData = this.stateManager.getGameData();
                        const player = gameData.players.find(p => p.id === playerId);
                        if (player && !player.selectedCard) {
                            console.log(`Auto-selecting card for ${playerName} due to timeout`);
                            this.makeRandomSelectionForPlayer(playerId, playerName);
                        }
                    }
                }, 1000);

                // Store the interval ID so we can clear it if player selects a card
                this.manualTimerInterval = countdown;
                console.log(`Timer countdown started successfully`);
                
                // Debug: Check if click handlers are still attached after timer starts
                setTimeout(() => {
                    console.log(`=== POST-TIMER-START CHECK ===`);
                    const testCards = document.querySelectorAll('.table-card');
                    testCards.forEach((card, index) => {
                        const cardRankElement = card.querySelector('.card-rank');
                        if (cardRankElement) {
                            console.log(`Post-timer check - Card ${index}:`, {
                                hasClickHandler: cardRankElement._cardClickHandler !== undefined,
                                cardRankElement: cardRankElement,
                                cardRankText: cardRankElement.textContent,
                                cardPointerEvents: card.style.pointerEvents,
                                cardRankPointerEvents: cardRankElement.style.pointerEvents
                            });
                        }
                    });
                }, 1000);
            }

            stopManualCountdown() {
                console.log(`=== stopManualCountdown called ===`);
                console.log(`Current manualTimerInterval:`, this.manualTimerInterval);
                console.log(`Current countdownTimer:`, this.countdownTimer);
                
                // Clear both timer systems
                if (this.manualTimerInterval) {
                    clearInterval(this.manualTimerInterval);
                    this.manualTimerInterval = null;
                    console.log(`Cleared manualTimerInterval`);
                }
                
                if (this.countdownTimer) {
                    clearInterval(this.countdownTimer);
                    this.countdownTimer = null;
                    console.log(`Cleared countdownTimer`);
                }
                
                // Remove all manual timer elements
                const timers = document.querySelectorAll('[id^="manual-timer-"]');
                console.log(`Found ${timers.length} timer elements to remove`);
                timers.forEach(timer => {
                    console.log(`Removing timer element:`, timer);
                    timer.remove();
                });
                
                // Also remove any timer elements that might have different IDs
                const allTimers = document.querySelectorAll('div[id*="timer"]');
                console.log(`Found ${allTimers.length} total timer elements to check`);
                allTimers.forEach(timer => {
                    if (timer.id.includes('manual-timer') || timer.id.includes('timer')) {
                        console.log(`Removing additional timer element:`, timer);
                        timer.remove();
                    }
                });
                
                // Clear all unavailable classes from table cards
                this.clearUnavailableCards();
                console.log(`=== stopManualCountdown complete ===`);
            }
            
            clearUnavailableCards() {
                const tableCards = document.querySelectorAll('.table-card');
                tableCards.forEach(card => {
                    card.classList.remove('unavailable');
                    card.style.pointerEvents = 'auto';
                    card.style.cursor = 'pointer';
                });
                console.log('Cleared unavailable classes from all table cards');
            }

            cleanupDuplicateCards() {
                console.log('=== Cleaning up duplicate cards ===');
                const gameData = this.stateManager.getGameData();
                const selectedCards = Array.from(gameData.selectedCards.values());
                const selectedRanks = selectedCards.map(card => card.rank);
                
                console.log('Selected ranks:', selectedRanks);
                
                const tableCards = document.querySelectorAll('.table-card');
                console.log(`Found ${tableCards.length} table cards to check`);
                
                tableCards.forEach(card => {
                    const rank = card.dataset.rank;
                    if (selectedRanks.includes(rank)) {
                        // Check if this card is currently being animated to (has a chip animation in progress)
                        const isBeingAnimatedTo = card.classList.contains('selected') && 
                                                 card.getAttribute('data-selected-by') && 
                                                 !card.style.display || card.style.display !== 'none';
                        
                        if (!isBeingAnimatedTo) {
                            console.log(`Removing duplicate card ${rank} from table`);
                            card.remove();
                        } else {
                            console.log(`Keeping card ${rank} - currently being animated to`);
                        }
                    }
                });
                
                console.log('=== Duplicate card cleanup complete ===');
            }

            updatePlayerDisplay(playerId) {
                const player = this.stateManager.getPlayer(playerId);
                const seat = document.getElementById(`player-${playerId}`);
                const cardElement = document.getElementById(`card-${playerId}`);
                
                if (player && seat && cardElement) {
                    seat.querySelector('.player-balance').textContent = `$${Math.round(player.balance)}`;
                    
                    // Update chip stack (now outside player seat)
                    const chipStack = document.getElementById(`chip-stack-${playerId}`);
                    if (chipStack) {
                        chipStack.innerHTML = this.generateChipStack(player.balance);
                    }
                    
                    if (player.selectedCard) {
                        // Only add selected class if no result class is present
                        if (!seat.classList.contains('win') && !seat.classList.contains('loss') && 
                            !seat.classList.contains('refund') && !seat.classList.contains('jackpot')) {
                        seat.classList.add('selected');
                        }
                        
                        // DON'T clear the card area if it already has content
                        // This prevents cards from disappearing when other players select
                        const playerCardArea = seat.querySelector('.player-card');
                        if (playerCardArea && playerCardArea.innerHTML === '') {
                            // Only prepare empty card areas - animation will populate them
                            playerCardArea.style.background = '';
                            playerCardArea.style.border = '';
                            playerCardArea.style.color = '';
                            playerCardArea.classList.remove('hearts-jackpot');
                            
                            console.log(`🎴 Card area prepared for player ${playerId} (${player.name}) - waiting for animation`);
                        } else if (playerCardArea && playerCardArea.innerHTML !== '') {
                            console.log(`🎴 Card area for player ${playerId} already has content - keeping it`);
                        }
                    }
                }
            }

            updateGameDisplay() {
                const gameData = this.stateManager.getGameData();
                
                // Safety checks for display values
                const jackpot = isNaN(gameData.jackpot) ? 0 : gameData.jackpot;
                const superJackpot = isNaN(gameData.superJackpot) ? 0 : gameData.superJackpot;
                const insuranceJackpot = isNaN(gameData.insuranceJackpot) ? 0 : gameData.insuranceJackpot;
                const bankRake = isNaN(gameData.bankRake) ? 0 : gameData.bankRake;
                const totalBalance = this.stateManager.getTotalBalance();
                
                this.elements.jackpotAmount.textContent = `$${Math.round(jackpot)}`;
                if (this.elements.superJackpotAmount) {
                    this.elements.superJackpotAmount.textContent = `$${Math.round(superJackpot)}`;
                }
                this.elements.insuranceAmount.textContent = `$${Math.round(insuranceJackpot)}`;
                
                // Update jackpot chip stack
                if (window.updateJackpotChipStack) {
                    window.updateJackpotChipStack(jackpot);
                }
                
                // Bank Rake is now only in admin panel, not in main view
                // this.elements.bankRake.textContent = `$${Math.round(bankRake)}`;
                
                this.elements.currentRound.textContent = `Round ${gameData.round}`;
                this.elements.adminRound.textContent = gameData.round;
                
                // Always update admin panel to keep values in sync
                this.updateAdminPanel();
                
                this.elements.totalBalance.textContent = `$${isNaN(totalBalance) ? '0' : Math.round(totalBalance)}`;
                
                gameData.players.forEach(player => {
                    this.updatePlayerDisplay(player.id);
                });
            }

            updateAdminPanel() {
                const gameData = this.stateManager.getGameData();
                
                // Calculate detailed balance breakdown
                const playerBalances = gameData.players.reduce((sum, player) => sum + (player.balance || 0), 0);
                const jackpot = gameData.jackpot || 0;
                const superJackpot = gameData.superJackpot || 0;
                const insuranceJackpot = gameData.insuranceJackpot || 0;
                const bankRake = gameData.bankRake || 0;
                // Table economy only (exclude superJackpot from Total Balance)
                const totalBalance = playerBalances + jackpot + insuranceJackpot + bankRake;
                const expectedTotal = (GAME_CONFIG.TOTAL_PLAYERS * GAME_CONFIG.INITIAL_BALANCE) - (gameData.superJackpotFromTable || 0);
                
                // Update admin panel displays
                this.elements.totalBalance.textContent = `$${Math.round(totalBalance)}`;
                this.elements.expectedBalance.textContent = `$${Math.round(expectedTotal)}`;
                this.elements.playerBalances.textContent = `$${Math.round(playerBalances)}`;
                this.elements.adminJackpot.textContent = `$${Math.round(jackpot)}`;
                if (this.elements.adminSuperJackpot) {
                    this.elements.adminSuperJackpot.textContent = `$${Math.round(superJackpot)}`;
                }
                this.elements.adminInsurance.textContent = `$${Math.round(insuranceJackpot)}`;
                this.elements.adminBankRake.textContent = `$${Math.round(bankRake)}`;
                this.elements.adminBankRakeDisplay.textContent = `$${Math.round(bankRake)}`;
                this.elements.adminRound.textContent = gameData.round;
                
                // Color code the total balance with acceptance threshold
                const difference = totalBalance - expectedTotal;
                const percentage = Math.abs(difference) / expectedTotal * 100;
                const acceptanceThreshold = 0.2; // 0.2% acceptance threshold
                
                if (percentage > acceptanceThreshold) {
                    this.elements.totalBalance.style.color = '#ff4444'; // Red if not balanced
                } else {
                    this.elements.totalBalance.style.color = '#44ff44'; // Green if balanced
                }
                
                console.log('Admin panel updated with balance validation');
            }
            
            updateInsuranceJackpotDisplay() {
                const gameData = this.stateManager.getGameData();
                const insuranceJackpot = gameData.insuranceJackpot || 0;
                
                // Update main header insurance display
                if (this.elements.insuranceAmount) {
                    this.elements.insuranceAmount.textContent = Math.round(insuranceJackpot);
                }
                
                console.log(`Insurance jackpot display updated to $${Math.round(insuranceJackpot)}`);
            }

            updateWaitingState() {
                this.elements.startRoundBtn.disabled = false;
                this.elements.gameState.textContent = 'Waiting for round to start';
                this.elements.gameTimer.classList.add('hidden');
            }

            updateCardSelectionState() {
                console.log('Updating card selection state...');
                this.elements.startRoundBtn.disabled = true;
                this.elements.gameState.textContent = 'Players selecting cards...';
                this.elements.gameTimer.classList.add('hidden');
                
                // Clean up any duplicate cards from previous rounds
                this.cleanupDuplicateCards();
                
                // Place cards on table for selection
                this.placeCardsOnTable();
                
                // Show first player marker for turn order indication
                this.gameLogic.showFirstPlayerMarker();
                
                console.log('Starting bot moves...');
                this.processBotMovesWithTurnIndication();
            }

            updateRevealingCardsState() {
                console.log('Updating revealing cards state...');
                this.elements.gameState.textContent = 'Cards revealed - drawing bank card...';
                
                // Only reveal cards if we haven't already done so
                if (!this.cardsRevealed) {
                    this.cardsRevealed = true;
                // Update all player cards to show rank and suit
                this.revealAllPlayerCards();
                
                    // Don't create chip pile yet - wait for all chips to animate first
                } else {
                    console.log('Cards already revealed, skipping...');
                }
                
                // Only proceed to bank draw if we haven't already done so
                if (!this.bankDrawProcessed) {
                    this.bankDrawProcessed = true;
                    
                    // Automatically proceed to bank draw after a 2 second delay
                setTimeout(() => {
                    console.log('Automatically proceeding to bank draw...');
                        // Play bank draw sound
                        this.soundManager.playSound('bankDraw');
                        // Process bank draw first
                        const bankCard = this.gameLogic.processBankDraw();
                        // Set bank card in state for animation
                        this.stateManager.setBankCard(bankCard);
                        // Animate bank card reveal
                        this.animateBankDraw();
                        // Then move to distribute winnings state
                    this.stateManager.setState(GAME_STATES.DISTRIBUTE_WINNINGS);
                    }, 2000);
                }
            }

            updateBankDrawState() {
                this.elements.gameState.textContent = 'Bank drawing card...';
                this.animateBankDraw();
            }

            updateDistributeWinningsState() {
                this.elements.gameState.textContent = 'Distributing winnings...';
                this.animateWinningsDistribution();
                
                // Validate balance after winnings distribution
                setTimeout(() => {
                    this.gameLogic.validateGameState();
                }, 500);
                
                // Animate chips back to players after a delay
                setTimeout(() => {
                    this.animateChipsBackToPlayers();
                }, 1000);
            }

            updateRoundSummaryState() {
                this.elements.gameState.textContent = 'Round complete - click to start new round';
                this.elements.startRoundBtn.disabled = false;
                this.elements.startRoundBtn.textContent = 'Start New Round';
                
                // Record round history
                this.recordRoundHistory();
                
                // Update history panel if it's open
                if (!this.elements.historyPanel.classList.contains('hidden')) {
                    console.log('📊 History panel is open, updating...');
                    this.updateHistoryPanel();
                }
                
                // Update clockwise start player for next round
                this.gameLogic.updateClockwiseStartPlayer();
                
                // Hide all turn markers
                this.gameLogic.hideAllTurnMarkers();
                
                // Auto-start next round if enabled; guard against state changes while waiting
                if (GAME_CONFIG.AUTO_START_NEXT_ROUND) {
                    if (this.autoStartTimer) {
                        clearTimeout(this.autoStartTimer);
                        this.autoStartTimer = null;
                    }
                    console.log(`Auto-starting next round in ${GAME_CONFIG.ROUND_DELAY}ms...`);
                    this.autoStartTimer = setTimeout(() => {
                        this.autoStartTimer = null;
                        const stillRoundSummary = this.stateManager.getState() === GAME_STATES.ROUND_SUMMARY;
                        if (!this.stateManager.isGamePaused() && stillRoundSummary) {
                            console.log('Auto-starting new round...');
                            this.startNewRound();
                        } else {
                            console.log('Auto-start skipped - state changed or paused');
                        }
                    }, GAME_CONFIG.ROUND_DELAY);
                }
            }
            
            recordRoundHistory() {
                const gameData = this.stateManager.getGameData();
                
                // Get fresh player data to ensure balance is current
                const roundData = {
                    bankCard: gameData.bankCard,
                    players: gameData.players.map(player => {
                        // Get fresh player data to ensure balance is up to date
                        // Try multiple sources to get the most current balance
                        const freshPlayer = this.stateManager.getPlayer(player.id);
                        let balance = 0;
                        
                        if (freshPlayer && freshPlayer.balance !== undefined && freshPlayer.balance !== null) {
                            balance = freshPlayer.balance;
                        } else if (player.balance !== undefined && player.balance !== null) {
                            balance = player.balance;
                        }
                        
                        // Round to integer
                        balance = Math.round(balance);
                        
                        // Debug log for human player
                        if (player.isHuman) {
                            console.log(`📊 Recording history for ${player.name}:`, {
                                finalBalance: balance,
                                freshPlayerBalance: freshPlayer ? freshPlayer.balance : 'N/A',
                                playerBalance: player.balance,
                                freshPlayerExists: !!freshPlayer,
                                freshPlayerFull: freshPlayer
                            });
                        }
                        return {
                            id: player.id,
                            name: player.name,
                            isHuman: player.isHuman,
                            selectedCard: player.selectedCard,
                            bet: player.bet || this.getBetValue(player.selectedCard),
                            result: player.result,
                            winnings: player.actualWinnings || 0,
                            refund: player.refund || 0,
                            balance: balance // Get fresh balance from state manager
                        };
                    }),
                    heartsJackpotWin: gameData.currentRoundJackpotWin || false,
                    heartsJackpotWinner: gameData.currentRoundJackpotWinner || null,
                    heartsJackpotAmount: gameData.currentRoundJackpotAmount || 0,
                    insuranceWin: gameData.currentRoundInsuranceWin || false,
                    insuranceWinner: gameData.currentRoundInsuranceWinner || null,
                    insuranceAmount: gameData.currentRoundInsuranceAmount || 0
                };
                
                // Check for jackpot wins (this would need to be passed from the game logic)
                // For now, we'll add this information when we have it
                
                this.stateManager.addRoundToHistory(roundData);
                
                // Clear jackpot data for next round
                this.stateManager.setRoundJackpotWin(false, null, 0);
                this.stateManager.setRoundInsuranceWin(false, null, 0);
            }

            async processBotMoves() {
                const gameData = this.stateManager.getGameData();
                const bots = gameData.players.filter(p => p.isBot && !p.selectedCard);
                
                console.log(`Processing moves for ${bots.length} bots...`);
                
                for (const bot of bots) {
                    await this.botController.makeBotMove(bot.id);
                    this.updatePlayerDisplay(bot.id);
                    
                    // Update table card display for bot selection will be handled by UIController
                    
                    console.log(`${bot.name} selected card: ${bot.selectedCard?.rank}`);
                    
                    if (bot.id < bots[bots.length - 1].id) {
                        await this.delay(GAME_CONFIG.BOT_DELAY);
                    }
                }
                
                // Check if all cards are selected after bot moves
                if (this.stateManager.allCardsSelected()) {
                    console.log('All cards selected after bot moves, moving to reveal phase...');
                    this.stateManager.setState(GAME_STATES.REVEALING_CARDS);
                }
            }

            async processBotMovesWithTurnIndication() {
                const gameData = this.stateManager.getGameData();
                const turnOrder = this.gameLogic.getTurnOrder();
                const playersToMove = turnOrder.filter(p => !p.selectedCard);
                
                console.log(`Processing moves for ${playersToMove.length} players with turn indication...`);
                console.log('Turn order:', playersToMove.map(p => ({ id: p.id, name: p.name, isHuman: p.isHuman })));
                
                for (const player of playersToMove) {
                    // Check for pause before processing each player
                    if (this.stateManager.isGamePaused()) {
                        console.log('Game paused during player processing, stopping...');
                        return;
                    }
                    console.log(`=== Processing player: ${player.name} (ID: ${player.id}, isHuman: ${player.isHuman}) ===`);
                    // Show whose turn it is
                    this.showCurrentTurn(player.id);
                    
                    if (player.isHuman) {
                        console.log(`=== Human player turn - checking strategy ===`);
                        console.log(`Current game state: ${this.stateManager.getState()}`);
                        console.log(`Player details: ${JSON.stringify(player)}`);
                        console.log(`Player strategy: ${player.strategy}`);
                        
                        // Re-check player strategy in case it was changed during the game
                        const currentPlayer = this.stateManager.getPlayer(player.id);
                        const currentStrategy = currentPlayer ? currentPlayer.strategy : player.strategy;
                        console.log(`Current strategy after re-check: ${currentStrategy}`);
                        
                        // Check if human player strategy is manual
                        if (currentStrategy === 'manual') {
                            console.log(`=== Human player strategy is manual - enabling card selection ===`);
                            console.log(`Available cards: ${this.stateManager.getAvailableCards()}`);
                            console.log(`Selected cards: ${Array.from(this.stateManager.getGameData().selectedCards.entries())}`);
                            
                            // Clean up any existing admin selection interface
                            this.cleanupAdminSelection();
                            console.log('=== Cleaned up admin selection interface ===');
                            
                            // Show turn marker for clockwise mode
                            this.gameLogic.showTurnMarker(player.id);
                            
                            // Human player - enable card selection with countdown
                            this.elements.gameState.textContent = `${player.name}'s turn - click a card to select`;
                            
                            // Add a small delay to ensure DOM is ready
                            setTimeout(() => {
                            this.showCardSelectionModal(player.id);
                            this.startManualCountdown(player.id, player.name);
                            console.log(`=== Human player card selection enabled, waiting for input ===`);
                            }, 100);
                            
                            // Don't auto-proceed, wait for human input
                            return;
                        } else {
                            console.log(`=== Human player strategy is ${currentStrategy} - making automatic move ===`);
                            // Show turn marker for clockwise mode
                            this.gameLogic.showTurnMarker(player.id);
                            // Human player with non-manual strategy - make automatic move
                            await this.delay(1000); // Show turn indication for 1 second
                            await this.botController.makeBotMove(player.id);
                            this.updatePlayerDisplay(player.id);
                            
                            // Update table card display for human selection
                            if (player.selectedCard) {
                                console.log(`Updating table card display for ${player.name} (ID: ${player.id}) with card ${player.selectedCard.rank}`);
                                this.updateTableCardDisplay(player.selectedCard.rank, player.name);
                            }
                            
                            console.log(`${player.name} selected card: ${player.selectedCard?.rank}`);
                            
                            // Clear turn indication after a short delay to show the result
                            await this.delay(500);
                            this.clearCurrentTurn();
                        }
                    } else {
                        // Bot player - make move after delay
                        await this.delay(1000); // Show turn indication for 1 second
                        await this.botController.makeBotMove(player.id);
                        this.updatePlayerDisplay(player.id);
                        
                        // Update table card display for bot selection
                        if (player.selectedCard) {
                            console.log(`Updating table card display for ${player.name} (ID: ${player.id}) with card ${player.selectedCard.rank}`);
                            this.updateTableCardDisplay(player.selectedCard.rank, player.name);
                        }
                        
                        console.log(`${player.name} selected card: ${player.selectedCard?.rank}`);
                        
                        // Clear turn indication after a short delay to show the result
                        await this.delay(500);
                        this.clearCurrentTurn();
                        
                        if (player.id < playersToMove[playersToMove.length - 1].id) {
                            await this.delay(GAME_CONFIG.BOT_DELAY);
                        }
                    }
                }
                
                // Check if all cards are selected after all moves
                const allSelected = this.stateManager.allCardsSelected();
                console.log('All cards selected check:', allSelected, 'Selected cards count:', this.stateManager.getGameData().selectedCards.size);
                if (allSelected) {
                    console.log('All cards selected, moving to reveal phase...');
                    this.stateManager.setState(GAME_STATES.REVEALING_CARDS);
                }
            }

            async continueWithRemainingPlayers() {
                console.log('=== continueWithRemainingPlayers called ===');
                console.log('Current game state:', this.stateManager.getState());
                
                // Check for pause at start
                if (this.stateManager.isGamePaused()) {
                    console.log('Game paused, cannot continue with remaining players');
                    return;
                }
                
                const gameData = this.stateManager.getGameData();
                
                // Use turn order to get remaining players
                const turnOrder = this.gameLogic.getTurnOrder();
                const playersToMove = turnOrder.filter(p => !p.selectedCard);
                
                console.log(`Continuing with ${playersToMove.length} remaining players...`);
                console.log('Players to move (in turn order):', playersToMove.map(p => ({ id: p.id, name: p.name, isHuman: p.isHuman, selectedCard: p.selectedCard })));
                console.log('All players:', gameData.players.map(p => ({ id: p.id, name: p.name, selectedCard: p.selectedCard })));
                
                if (playersToMove.length === 0) {
                    console.log('No players to move, all cards selected!');
                    this.stateManager.setState(GAME_STATES.REVEALING_CARDS);
                    return;
                }
                
                // Process each remaining player in turn order
                for (const player of playersToMove) {
                    // Check for pause before processing each player
                    if (this.stateManager.isGamePaused()) {
                        console.log('Game paused during remaining player processing, stopping...');
                        return;
                    }
                    console.log(`Processing player: ${player.name} (ID: ${player.id})`);
                    
                    if (player.isHuman) {
                        console.log(`=== Human player turn in continueWithRemainingPlayers - checking strategy ===`);
                        console.log(`Player strategy: ${player.strategy}`);
                        
                        // Check if human player strategy is manual
                        if (player.strategy === 'manual') {
                            console.log('Human player strategy is manual - enabling card selection');
                            
                            // Clean up any existing admin selection interface
                            this.cleanupAdminSelection();
                            console.log('=== Cleaned up admin selection interface in continueWithRemainingPlayers ===');
                            
                            // Show turn marker
                            this.gameLogic.showTurnMarker(player.id);
                            
                            this.elements.gameState.textContent = `${player.name}'s turn - click a card to select`;
                            this.showCardSelectionModal(player.id);
                            this.startManualCountdown(player.id, player.name);
                            break; // Stop here for human player
                        } else {
                            console.log(`Human player strategy is ${player.strategy} - making automatic move in continueWithRemainingPlayers`);
                            // Human player with non-manual strategy - make automatic move
                            this.showCurrentTurn(player.id);
                            this.gameLogic.showTurnMarker(player.id);
                            await this.delay(1000);
                            
                            // Make human move
                            const success = await this.botController.makeBotMove(player.id);
                            if (success) {
                                this.updatePlayerDisplay(player.id);
                                
                                // Update table card display for human selection
                                if (player.selectedCard) {
                                    console.log(`Updating table card display for ${player.name} (ID: ${player.id}) with card ${player.selectedCard.rank}`);
                                    this.updateTableCardDisplay(player.selectedCard.rank, player.name);
                                }
                                
                                console.log(`${player.name} selected card: ${player.selectedCard?.rank}`);
                            }
                            
                            // Clear turn indication after a short delay to show the result
                            await this.delay(500);
                            this.clearCurrentTurn();
                        }
                    } else {
                        console.log('Bot player turn - making move');
                        this.showCurrentTurn(player.id);
                        this.gameLogic.showTurnMarker(player.id);
                        await this.delay(1000);
                        
                        // Make bot move
                        const success = await this.botController.makeBotMove(player.id);
                        if (success) {
                            this.updatePlayerDisplay(player.id);
                            
                            // Update table card display for bot selection
                            if (player.selectedCard) {
                                console.log(`Updating table card display for ${player.name} (ID: ${player.id}) with card ${player.selectedCard.rank}`);
                                this.updateTableCardDisplay(player.selectedCard.rank, player.name);
                            }
                            
                            console.log(`${player.name} selected card: ${player.selectedCard?.rank}`);
                        }
                        
                        await this.delay(500);
                        this.clearCurrentTurn();
                    }
                }
                
                // Check if all cards are selected after processing
                if (this.stateManager.allCardsSelected()) {
                    console.log('All cards selected, moving to reveal phase...');
                    this.stateManager.setState(GAME_STATES.REVEALING_CARDS);
                }
            }

            animateBankDraw() {
                console.log('Animating bank draw...');
                
                // Get the bank card first
                const bankCard = this.stateManager.getBankCard();
                if (bankCard) {
                    console.log('🏦 Bank card revealed:', bankCard);
                    
                    // Update the content immediately with the correct card (vertically stacked)
                    this.elements.bankCard.innerHTML = `
                        <div class="card-content" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%;">
                            <div class="card-rank">${bankCard.rank}</div>
                            <div class="card-suit">${this.getSuitSymbol(bankCard.suit)}</div>
                        </div>
                    `;
                    
                    // Then add the revealed class for animation
                    setTimeout(() => {
                        this.elements.bankCard.classList.add('revealed');
                        console.log('🎴 Bank card animation complete');
                    }, 100);
                } else {
                    console.error('❌ No bank card found!');
                }
            }

            animateWinningsDistribution() {
                console.log('Animating winnings distribution...');
                const gameData = this.stateManager.getGameData();
                
                console.log('Player results:', gameData.players.map(p => ({ name: p.name, result: p.result })));
                
                // Add delay before showing results to let players see the bank card
                setTimeout(() => {
                    gameData.players.forEach(player => {
                        const seat = document.getElementById(`player-${player.id}`);
                        if (seat && player.result) {
                            console.log(`Setting result for ${player.name}: ${player.result}`);
                            
                            // Remove selected class to prevent conflict with result colors
                            seat.classList.remove('selected');
                            seat.classList.add(player.result);
                            
                            const resultText = document.createElement('div');
                            resultText.className = 'result-text';
                            resultText.textContent = this.getResultText(player.result, player);
                            seat.appendChild(resultText);
                            
                            // Play appropriate sound based on result (only for human player)
                            if (player.id === 0) { // Human player
                                if (player.result === RESULT_TYPES.WIN) {
                                    this.soundManager.playSound('win');
                                } else if (player.result === RESULT_TYPES.LOSS) {
                                    this.soundManager.playSound('loss');
                                } else if (player.result === RESULT_TYPES.REFUND) {
                                    this.soundManager.playSound('refund');
                                } else if (player.result === RESULT_TYPES.JACKPOT) {
                                    // Jackpot sound and animation already played in processJackpotPayout
                                    console.log(`Jackpot result displayed for player ${player.id}`);
                                }
                            }
                        }
                    });
                    
                    setTimeout(() => {
                        this.updateGameDisplay();
                        this.stateManager.setState(GAME_STATES.ROUND_SUMMARY);
                    }, 2000);
                }, 1000); // 1 second delay before showing results
            }

            getResultText(result, player) {
                const betValue = player.selectedCard ? this.getBetValue(player.selectedCard) : 0;
                
                switch (result) {
                    case RESULT_TYPES.WIN: 
                        // Use the stored actual winnings (bet back + winnings from losing player)
                        const actualWinnings = player.actualWinnings || betValue;
                        return `WIN! +$${Math.round(actualWinnings)}`;
                    case RESULT_TYPES.LOSS: 
                        return `LOSS -$${Math.round(betValue)}`;
                    case RESULT_TYPES.REFUND: 
                        // Calculate actual refund amount (bet minus jackpot contribution)
                        const jackpotContribution = betValue * GAME_CONFIG.JACKPOT_RATE;
                        const actualRefund = betValue - jackpotContribution;
                        return `REFUND +$${Math.round(actualRefund)}`;
                    case RESULT_TYPES.JACKPOT: 
                        // Use the stored jackpot amount if available, otherwise fall back to bet value
                        const jackpotWinnings = player.jackpotAmount || betValue;
                        return `JACKPOT! +$${Math.round(jackpotWinnings)}`;
                    default: return '';
                }
            }

            getSuitSymbol(suit) {
                const symbols = {
                    hearts: '<span style="color: red;">♥</span>',
                    diamonds: '<span style="color: red;">♦</span>',
                    clubs: '<span style="color: black;">♣</span>',
                    spades: '<span style="color: black;">♠</span>'
                };
                return symbols[suit] || '?';
            }
            
            createJackpotAnimation(playerId, jackpotAmount = 0) {
                console.log(`Creating jackpot animation for player ${playerId} with amount $${jackpotAmount}`);
                const playerSeat = document.getElementById(`player-${playerId}`);
                if (!playerSeat) {
                    console.error(`Player seat not found for ID: ${playerId}`);
                    return;
                }
                
                const seatRect = playerSeat.getBoundingClientRect();
                const centerX = seatRect.left + seatRect.width / 2;
                const centerY = seatRect.top + seatRect.height / 2;
                
                // Create stars
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        const star = document.createElement('div');
                        star.className = 'jackpot-star';
                        star.textContent = '★';
                        star.style.left = centerX + 'px';
                        star.style.top = centerY + 'px';
                        
                        // Random position around the player
                        const angle = (i / 8) * Math.PI * 2;
                        const distance = 50 + Math.random() * 30;
                        const x = centerX + Math.cos(angle) * distance;
                        const y = centerY + Math.sin(angle) * distance;
                        
                        star.style.left = x + 'px';
                        star.style.top = y + 'px';
                        
                        document.body.appendChild(star);
                        
                        // Remove after animation
                        setTimeout(() => {
                            if (star.parentNode) {
                                star.parentNode.removeChild(star);
                            }
                        }, 2000);
                    }, i * 100);
                }
                
                // Create gold coins
                for (let i = 0; i < 6; i++) {
                    setTimeout(() => {
                        const gold = document.createElement('div');
                        gold.className = 'jackpot-gold';
                        gold.textContent = '💰';
                        gold.style.left = centerX + 'px';
                        gold.style.top = centerY + 'px';
                        
                        // Random position around the player
                        const angle = (i / 6) * Math.PI * 2 + Math.PI / 6;
                        const distance = 40 + Math.random() * 25;
                        const x = centerX + Math.cos(angle) * distance;
                        const y = centerY + Math.sin(angle) * distance;
                        
                        gold.style.left = x + 'px';
                        gold.style.top = y + 'px';
                        
                        document.body.appendChild(gold);
                        
                        // Remove after animation
                        setTimeout(() => {
                            if (gold.parentNode) {
                                gold.parentNode.removeChild(gold);
                            }
                        }, 2000);
                    }, i * 150);
                }
                
                // Create jackpot amount display (gold box)
                if (jackpotAmount > 0) {
                    console.log(`🏆 Creating gold jackpot display for $${jackpotAmount}`);
                    const jackpotDisplay = document.createElement('div');
                    jackpotDisplay.className = 'jackpot-amount-display';
                    jackpotDisplay.innerHTML = `
                        <div class="jackpot-title">🏆 JACKPOT! 🏆</div>
                        <div class="jackpot-amount">+$${Math.round(jackpotAmount)}</div>
                    `;
                    
                    // Position above the player seat
                    jackpotDisplay.style.position = 'fixed';
                    jackpotDisplay.style.left = (centerX - 100) + 'px';
                    jackpotDisplay.style.top = (centerY - 80) + 'px';
                    jackpotDisplay.style.zIndex = '10000';
                    
                    document.body.appendChild(jackpotDisplay);
                    
                    // Remove after 4 seconds
                    setTimeout(() => {
                        if (jackpotDisplay.parentNode) {
                            jackpotDisplay.parentNode.removeChild(jackpotDisplay);
                        }
                    }, 4000);
                }
            }

            createInsuranceWinAnimation(playerId, insuranceAmount = 0) {
                console.log(`🛡️ Creating insurance win animation for player ${playerId} with amount $${insuranceAmount}`);
                const playerSeat = document.getElementById(`player-${playerId}`);
                if (!playerSeat) {
                    console.error(`Player seat not found for ID: ${playerId}`);
                    return;
                }
                
                const seatRect = playerSeat.getBoundingClientRect();
                const centerX = seatRect.left + seatRect.width / 2;
                const centerY = seatRect.top + seatRect.height / 2;
                
                // Create shield particles
                for (let i = 0; i < 6; i++) {
                    setTimeout(() => {
                        const shield = document.createElement('div');
                        shield.className = 'insurance-particle';
                        shield.textContent = '🛡️';
                        shield.style.position = 'fixed';
                        shield.style.left = centerX + 'px';
                        shield.style.top = centerY + 'px';
                        shield.style.fontSize = '24px';
                        shield.style.zIndex = '9999';
                        shield.style.pointerEvents = 'none';
                        shield.style.animation = 'insuranceParticle 2s ease-out forwards';
                        
                        // Random position around the player
                        const angle = (i / 6) * Math.PI * 2;
                        const distance = 40 + Math.random() * 20;
                        const x = centerX + Math.cos(angle) * distance;
                        const y = centerY + Math.sin(angle) * distance;
                        
                        setTimeout(() => {
                            shield.style.left = x + 'px';
                            shield.style.top = y + 'px';
                            shield.style.opacity = '0';
                        }, 100);
                        
                        document.body.appendChild(shield);
                        
                        // Remove after animation
                        setTimeout(() => {
                            if (shield.parentNode) {
                                shield.parentNode.removeChild(shield);
                            }
                        }, 2000);
                    }, i * 100);
                }
                
                // Create insurance amount display (blue shield box)
                if (insuranceAmount > 0) {
                    console.log(`🛡️ Creating insurance win display for $${insuranceAmount}`);
                    const insuranceDisplay = document.createElement('div');
                    insuranceDisplay.className = 'insurance-win-display';
                    insuranceDisplay.innerHTML = `
                        <div class="insurance-win-title">🛡️ INSURANCE WIN! 🛡️</div>
                        <div class="insurance-win-amount">+$${Math.round(insuranceAmount)}</div>
                    `;
                    
                    // Position above the player seat
                    insuranceDisplay.style.position = 'fixed';
                    insuranceDisplay.style.left = (centerX - 100) + 'px';
                    insuranceDisplay.style.top = (centerY - 80) + 'px';
                    insuranceDisplay.style.zIndex = '10000';
                    
                    document.body.appendChild(insuranceDisplay);
                    
                    // Remove after 4 seconds
                    setTimeout(() => {
                        if (insuranceDisplay.parentNode) {
                            insuranceDisplay.parentNode.removeChild(insuranceDisplay);
                        }
                    }, 4000);
                }
            }

            // Big fireworks for Super Jackpot
            createSuperJackpotAnimation(playerId, totalAmount = 0) {
                const playerSeat = document.getElementById(`player-${playerId}`);
                if (!playerSeat) return;
                const seatRect = playerSeat.getBoundingClientRect();
                const centerX = seatRect.left + seatRect.width / 2;
                const centerY = seatRect.top + seatRect.height / 2;

                // Create multiple firework bursts
                for (let burst = 0; burst < 6; burst++) {
                    setTimeout(() => {
                        for (let i = 0; i < 24; i++) {
                            const star = document.createElement('div');
                            star.textContent = ['💥','✨','🔥','🎆','🎇'][i % 5];
                            star.style.position = 'fixed';
                            star.style.left = centerX + 'px';
                            star.style.top = centerY + 'px';
                            star.style.fontSize = (18 + Math.random() * 10) + 'px';
                            star.style.zIndex = '10000';
                            star.style.pointerEvents = 'none';

                            const angle = (i / 24) * Math.PI * 2;
                            const distance = 80 + Math.random() * 80;
                            const x = centerX + Math.cos(angle) * distance;
                            const y = centerY + Math.sin(angle) * distance;

                            document.body.appendChild(star);
                            star.animate([
                                { transform: 'translate(0,0) scale(0.6)', opacity: 1 },
                                { transform: `translate(${x - centerX}px, ${y - centerY}px) scale(1.4)`, opacity: 0 }
                            ], { duration: 1200, easing: 'ease-out', fill: 'forwards' });

                            setTimeout(() => { star.remove(); }, 1400);
                        }
                    }, burst * 200);
                }

                // Big label
                const label = document.createElement('div');
                label.textContent = `💎 SUPER JACKPOT! +$${Math.round(totalAmount)}`;
                label.style.position = 'fixed';
                label.style.left = (centerX - 150) + 'px';
                label.style.top = (centerY - 120) + 'px';
                label.style.width = '300px';
                label.style.textAlign = 'center';
                label.style.fontWeight = '900';
                label.style.fontSize = '24px';
                label.style.color = '#ffd700';
                label.style.textShadow = '0 0 10px #ffec8b, 0 0 20px #ffd700';
                label.style.zIndex = '10001';
                document.body.appendChild(label);
                setTimeout(() => label.remove(), 2200);
            }

            getBetValue(card) {
                return CARD_VALUES[card.rank] || 0;
            }
            

            generateChipStack(balance) {
                const chips = [];
                let remainingBalance = balance;
                
                // Generate different colored chips based on balance
                const chipValues = [100, 50, 25, 10, 5, 1];
                const chipColors = ['#ff0000', '#0000ff', '#00ff00', '#ffff00', '#ff00ff', '#00ffff'];
                
                chipValues.forEach((value, index) => {
                    const count = Math.floor(remainingBalance / value);
                    if (count > 0) {
                        for (let i = 0; i < Math.min(count, 3); i++) { // Max 3 chips per value for 3 columns
                            chips.push(`<div class="chip" style="background: ${chipColors[index]}; border-color: ${chipColors[index]};"></div>`);
                        }
                        remainingBalance -= count * value;
                    }
                });
                
                // If still have balance, add small chips
                if (remainingBalance > 0) {
                    for (let i = 0; i < Math.min(remainingBalance, 3); i++) {
                        chips.push(`<div class="chip" style="background: #888; border-color: #888;"></div>`);
                    }
                }
                
                // Fill empty slots to maintain 3-column grid
                while (chips.length < 9) {
                    chips.push(`<div class="chip" style="background: transparent; border-color: transparent;"></div>`);
                }
                
                return chips.join('');
            }

            animateChipToCard(playerId, cardElement) {
                console.log(`Animating chip from player ${playerId} to chip pile`);
                
                const player = this.stateManager.getPlayer(playerId);
                if (!player || !player.selectedCard) return;
                
                const betValue = this.getBetValue(player.selectedCard);
                const chipStack = document.getElementById(`chip-stack-${playerId}`);
                if (!chipStack) {
                    console.error(`Chip stack not found for player ${playerId}`);
                    return;
                }
                
                // Get chip stack position
                const stackRect = chipStack.getBoundingClientRect();
                console.log(`Chip stack position: (${stackRect.left}, ${stackRect.top})`);
                
                // Validate position
                if (stackRect.left < 0 || stackRect.top < 0) {
                    console.error('Invalid chip stack position, skipping chip animation');
                    return;
                }
                
                // Create animated chip
                const animatedChip = document.createElement('div');
                animatedChip.className = 'animated-chip';
                animatedChip.style.position = 'fixed';
                animatedChip.style.left = `${stackRect.left}px`;
                animatedChip.style.top = `${stackRect.top}px`;
                animatedChip.style.width = '20px';
                animatedChip.style.height = '16px';
                animatedChip.style.borderRadius = '50%';
                animatedChip.style.background = this.getChipColor(betValue);
                animatedChip.style.border = `3px solid ${this.getChipColor(betValue)}`;
                animatedChip.style.zIndex = '1000';
                animatedChip.style.transition = 'all 0.8s ease-out';
                animatedChip.style.boxShadow = '0 3px 6px rgba(0,0,0,0.4)';
                
                document.body.appendChild(animatedChip);
                
                // Animate directly to chip pile area
                setTimeout(() => {
                    const gameTable = document.querySelector('.game-table');
                    if (gameTable) {
                        const tableRect = gameTable.getBoundingClientRect();
                        const targetX = tableRect.left + tableRect.width/2 + 40; // 40px to the right of center
                        const targetY = tableRect.top + tableRect.height/2 - 4; // Center vertically
                        
                        console.log(`Animating chip to pile position: (${targetX}, ${targetY})`);
                        animatedChip.style.left = `${targetX}px`;
                        animatedChip.style.top = `${targetY}px`;
                    } else {
                        console.error('Game table not found for chip animation');
                        animatedChip.remove();
                    }
                }, 100);
                
                // Make the chip permanent and part of the pile
                setTimeout(() => {
                    const gameTable = document.querySelector('.game-table');
                    if (gameTable) {
                    animatedChip.style.position = 'absolute';
                    animatedChip.style.pointerEvents = 'none';
                    animatedChip.style.transition = 'none';
                    
                        const tableRect = gameTable.getBoundingClientRect();
                        const currentRect = animatedChip.getBoundingClientRect();
                        
                        // Calculate offset for this specific chip to create a vertical stack
                        const existingChips = gameTable.querySelectorAll('.animated-chip');
                        const chipIndex = existingChips.length;
                        const offsetX = 0; // No horizontal offset for vertical stack
                        const offsetY = chipIndex * 6; // 6px vertical offset per chip for better visibility with larger chips
                        
                        animatedChip.style.left = `${currentRect.left - tableRect.left + offsetX}px`;
                        animatedChip.style.top = `${currentRect.top - tableRect.top + offsetY}px`;
                        animatedChip.style.zIndex = `${100 + chipIndex}`; // Higher z-index for newer chips
                        
                        console.log(`Making chip permanent at position: (${currentRect.left - tableRect.left + offsetX}, ${currentRect.top - tableRect.top + offsetY})`);
                        
                        // Remove from body and add to game table
                        if (animatedChip.parentNode === document.body) {
                            document.body.removeChild(animatedChip);
                        }
                        gameTable.appendChild(animatedChip);
                    } else {
                        console.error('Game table not found for final chip placement');
                        animatedChip.remove();
                    }
                }, 1000);
            }

            getChipColor(value) {
                if (value >= 100) return '#ff0000';
                if (value >= 50) return '#0000ff';
                if (value >= 25) return '#00ff00';
                if (value >= 10) return '#ffff00';
                if (value >= 5) return '#ff00ff';
                return '#00ffff';
            }

            animateChipsBackToPlayers() {
                console.log('Animating chips back to players based on results');
                
                const gameData = this.stateManager.getGameData();
                const gameTable = document.querySelector('.game-table');
                if (!gameTable) return;
                
                const animatedChips = gameTable.querySelectorAll('.animated-chip');
                console.log(`Found ${animatedChips.length} chips to animate back`);
                
                animatedChips.forEach((chip, index) => {
                    // Find which player this chip belongs to (based on order)
                    const player = gameData.players[index];
                    if (!player) return;
                    
                    const playerSeat = document.getElementById(`player-${player.id}`);
                    if (!playerSeat) return;
                    
                    const seatRect = playerSeat.getBoundingClientRect();
                    const tableRect = gameTable.getBoundingClientRect();
                    
                    // Calculate target position (player's chip stack area)
                    const targetX = seatRect.left - tableRect.left + 130; // 130px to the right of player seat
                    const targetY = seatRect.top - tableRect.top + 20; // 20px down from top of seat
                    
                    // Update chip color based on result
                    if (player.result === 'win') {
                        // Keep colorful chips for winners
                        console.log(`${player.name} won - keeping colorful chip`);
                    } else if (player.result === 'refund') {
                        // Make chips gray for refunds
                        chip.style.background = '#888';
                        chip.style.borderColor = '#888';
                        console.log(`${player.name} got refund - making chip gray`);
                    } else if (player.result === 'loss') {
                        // Losers don't get chips back - fade out
                        chip.style.opacity = '0';
                        chip.style.transform = 'scale(0)';
                        console.log(`${player.name} lost - removing chip`);
                        return; // Don't animate back
                    }
                    
                    // Animate chip back to player
                    setTimeout(() => {
                        chip.style.left = `${targetX}px`;
                        chip.style.top = `${targetY}px`;
                        chip.style.transition = 'all 1.0s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    }, index * 200); // Stagger animations by 200ms per chip
                    
                    // Remove chip after animation
                    setTimeout(() => {
                        if (chip.parentNode) {
                            chip.remove();
                        }
                    }, 1000 + (index * 200));
                });
            }

            startNewRound() {
                console.log('Start new round clicked');
                if (this.stateManager.startNewRound()) {
                    // Play round start sound
                    this.soundManager.playSound('roundStart');
                    
                    // Reset flags
                    this.bankDrawProcessed = false;
                    this.cardsRevealed = false;
                    // Don't recreate player seats - just update them to preserve dropdown values
                    this.updatePlayerSeats();
                    this.updateGameDisplay();
                    this.resetBankCardDisplay();
                    this.clearPlayerResultClasses();
                    this.clearCardSelectedClasses();
                    this.placeCardsOnTable();
                    
                    // Remove animated chips from previous round
                    const animatedChips = document.querySelectorAll('.animated-chip');
                    animatedChips.forEach(chip => chip.remove());
                    
                    console.log('New round started successfully');
                } else {
                    console.log('Failed to start new round');
                }
            }

            placeCardsOnTable() {
                // Remove existing cards
                const existingCards = document.querySelectorAll('.table-card');
                existingCards.forEach(card => card.remove());
                
                // Create cards on table
                const cardRanks = ['A', '2', '3', '4', '5', '6', '7', '8', '9'];
                // Position the card selection ring slightly up and to the left of the bank card
                const centerX = 435; // Move left from bank card center (half the previous offset)
                const centerY = 335; // Move up from bank card center (half the previous offset)
                const radius = 140; // Slightly bigger radius for better spacing
                
                cardRanks.forEach((rank, index) => {
                    const card = document.createElement('div');
                    card.className = 'table-card';
                    card.dataset.rank = rank;
                    
                    // Calculate card value (bet amount)
                    const cardValue = this.getBetValue({ rank: rank, suit: 'spades' });
                    
                    // Create card content with rank and value (vertically stacked)
                    card.innerHTML = `
                        <div class="card-content">
                            <div class="card-rank">${rank}</div>
                            <div class="card-value">$${cardValue}</div>
                        </div>
                    `;
                    
                    // Position cards in a circle around the bank card
                    const angle = (index * 2 * Math.PI) / cardRanks.length;
                    const x = centerX + radius * Math.cos(angle) - 20; // -20 to center the smaller card
                    const y = centerY + radius * Math.sin(angle) - 30; // -30 to center the smaller card
                    
                    card.style.left = `${x}px`;
                    card.style.top = `${y}px`;
                    
                    // Add to the game table container, not the general game container
                    const gameTable = document.querySelector('.game-table');
                    if (gameTable) {
                        gameTable.appendChild(card);
                    } else {
                        this.elements.gameContainer.appendChild(card);
                    }
                });
            }


            toggleAdminPanel() {
                this.elements.adminPanel.classList.toggle('hidden');
                if (!this.elements.adminPanel.classList.contains('hidden')) {
                    this.updateAdminPanel();
                }
            }
            
            toggleBotControlPanel() {
                this.elements.botControlPanel.classList.toggle('hidden');
                if (!this.elements.botControlPanel.classList.contains('hidden')) {
                    this.updateBotControlPanel();
                }
            }
            
            toggleHistoryPanel() {
                this.elements.historyPanel.classList.toggle('hidden');
                if (!this.elements.historyPanel.classList.contains('hidden')) {
                    console.log('📊 History panel opened, updating...');
                    this.updateHistoryPanel();
                }
            }
            
            updateBotControlPanel() {
                const botList = document.getElementById('bot-list');
                if (!botList) return;
                
                const gameData = this.stateManager.getGameData();
                const bots = gameData.players.filter(player => !player.isHuman);
                
                botList.innerHTML = '';
                
                bots.forEach((bot, index) => {
                    const botItem = document.createElement('div');
                    botItem.className = 'bot-item';
                    botItem.innerHTML = `
                        <div class="bot-item-header">
                            <div class="bot-name">Bot ${bot.id}</div>
                        </div>
                        <div class="bot-controls-row">
                            <div class="bot-control-group">
                                <label>Name:</label>
                                <input type="text" id="bot-name-${bot.id}" value="${bot.name}" maxlength="15">
                            </div>
                            <div class="bot-control-group">
                                <label>Strategy:</label>
                                <select id="bot-strategy-${bot.id}">
                                    <option value="random" ${bot.strategy === 'random' ? 'selected' : ''}>Random</option>
                                    <option value="lowest" ${bot.strategy === 'lowest' ? 'selected' : ''}>Lowest</option>
                                    <option value="highest" ${bot.strategy === 'highest' ? 'selected' : ''}>Highest</option>
                                    <option value="manual" ${bot.strategy === 'manual' ? 'selected' : ''}>Manual</option>
                                </select>
                            </div>
                            <div class="bot-control-group">
                                <label>Insurance:</label>
                                <select id="bot-insurance-${bot.id}">
                                    <option value="ask" ${bot.insuranceBehavior === 'ask' ? 'selected' : ''}>Ask before round</option>
                                    <option value="always" ${bot.insuranceBehavior === 'always' ? 'selected' : ''}>Always buy</option>
                                    <option value="never" ${bot.insuranceBehavior === 'never' ? 'selected' : ''}>Never buy</option>
                                </select>
                            </div>
                        </div>
                    `;
                    
                    botList.appendChild(botItem);
                });
                
                // Set up event listeners for bot controls
                this.setupBotControlListeners();
            }
            
            setupBotControlListeners() {
                const gameData = this.stateManager.getGameData();
                const bots = gameData.players.filter(player => !player.isHuman);
                
                bots.forEach(bot => {
                    // Name change
                    const nameInput = document.getElementById(`bot-name-${bot.id}`);
                    if (nameInput) {
                        nameInput.addEventListener('change', (e) => {
                            const newName = e.target.value.trim() || `Bot ${bot.id}`;
                            this.stateManager.updatePlayerName(bot.id, newName);
                            console.log(`Bot ${bot.id} name changed to: ${newName}`);
                        });
                    }
                    
                    // Strategy change
                    const strategySelect = document.getElementById(`bot-strategy-${bot.id}`);
                    if (strategySelect) {
                        strategySelect.addEventListener('change', (e) => {
                            this.stateManager.updatePlayerStrategy(bot.id, e.target.value);
                            console.log(`Bot ${bot.id} strategy changed to: ${e.target.value}`);
                        });
                    }
                    
                    // Insurance behavior change
                    const insuranceSelect = document.getElementById(`bot-insurance-${bot.id}`);
                    if (insuranceSelect) {
                        insuranceSelect.addEventListener('change', (e) => {
                            this.stateManager.updatePlayerInsuranceBehavior(bot.id, e.target.value);
                            console.log(`Bot ${bot.id} insurance behavior changed to: ${e.target.value}`);
                        });
                    }
                });
            }
            
            makeAdminPanelDraggable() {
                const panel = this.elements.adminPanel;
                const header = panel.querySelector('.admin-header');
                let isDragging = false;
                let currentX;
                let currentY;
                let initialX;
                let initialY;
                let xOffset = 0;
                let yOffset = 0;
                
                header.addEventListener('mousedown', dragStart);
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', dragEnd);
                
                function dragStart(e) {
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                    
                    if (e.target === header || header.contains(e.target)) {
                        isDragging = true;
                    }
                }
                
                function drag(e) {
                    if (isDragging) {
                        e.preventDefault();
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                        
                        xOffset = currentX;
                        yOffset = currentY;
                        
                        panel.style.transform = `translate(${currentX}px, ${currentY}px)`;
                    }
                }
                
                function dragEnd(e) {
                    initialX = currentX;
                    initialY = currentY;
                    isDragging = false;
                }
            }
            
            makeBotControlPanelDraggable() {
                const panel = this.elements.botControlPanel;
                const header = panel.querySelector('.bot-control-header');
                let isDragging = false;
                let currentX;
                let currentY;
                let initialX;
                let initialY;
                let xOffset = 0;
                let yOffset = 0;
                
                header.addEventListener('mousedown', dragStart);
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', dragEnd);
                
                function dragStart(e) {
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                    
                    if (e.target === header || header.contains(e.target)) {
                        isDragging = true;
                    }
                }
                
                function drag(e) {
                    if (isDragging) {
                        e.preventDefault();
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                        
                        xOffset = currentX;
                        yOffset = currentY;
                        
                        panel.style.transform = `translate(${currentX}px, ${currentY}px)`;
                    }
                }
                
                function dragEnd(e) {
                    initialX = currentX;
                    initialY = currentY;
                    isDragging = false;
                }
            }
            
            formatCardDisplay(card) {
                if (typeof card === 'object' && card.rank && card.suit) {
                    const suitSymbols = {
                        'hearts': '♥',
                        'diamonds': '♦',
                        'clubs': '♣',
                        'spades': '♠'
                    };
                    return `${card.rank}${suitSymbols[card.suit] || card.suit}`;
                }
                return card || 'Unknown';
            }
            
            updateHistoryPanel() {
                const historyList = document.getElementById('history-list');
                if (!historyList) return;
                
                // Get game history from state manager
                const gameData = this.stateManager.getGameData();
                const history = gameData.gameHistory || [];
                
                historyList.innerHTML = '';
                
                if (history.length === 0) {
                    historyList.innerHTML = '<div style="color: #bdc3c7; text-align: center; padding: 20px;">No rounds played yet</div>';
                    return;
                }
                
                // Show last 20 rounds (most recent first)
                const recentHistory = history.slice(-20).reverse();
                
                recentHistory.forEach((round, index) => {
                    const entry = document.createElement('div');
                    entry.className = 'history-entry';
                    
                    // Add special styling for jackpot/insurance wins
                    if (round.heartsJackpotWin || round.insuranceWin) {
                        if (round.heartsJackpotWin) {
                            entry.classList.add('jackpot-win');
                        }
                        if (round.insuranceWin) {
                            entry.classList.add('insurance-win');
                        }
                    }
                    
                    let html = `
                        <div class="history-round">Round ${round.roundNumber}</div>
                    `;
                    
                    // Add human player result
                    const humanPlayer = round.players.find(p => p.isHuman);
                    if (humanPlayer) {
                        const cardDisplay = this.formatCardDisplay(humanPlayer.selectedCard);
                        const betAmount = Math.round(humanPlayer.bet || 0);
                        const balanceAfter = Math.round(humanPlayer.balance || 0);
                        
                        html += `<div class="history-player human">You (${cardDisplay}): `;
                        if (humanPlayer.result === 'win') {
                            html += `<span class="history-result win">Won $${Math.round(humanPlayer.winnings || 0)}</span>`;
                        } else if (humanPlayer.result === 'loss') {
                            html += `<span class="history-result loss">Lost $${betAmount}</span>`;
                        } else if (humanPlayer.result === 'refund') {
                            html += `<span class="history-result refund">Refunded $${Math.round(humanPlayer.refund || 0)}</span>`;
                        }
                        html += `<div style="font-size: 11px; color: #95a5a6; margin-top: 3px;">Bet: $${betAmount} | Balance: $${balanceAfter}</div>`;
                        html += `</div>`;
                    }
                    
                    // Add jackpot wins
                    if (round.heartsJackpotWin) {
                        html += `<div class="history-jackpot">♥️ Hearts Jackpot: ${round.heartsJackpotWinner} won $${Math.round(round.heartsJackpotAmount)}</div>`;
                    }
                    if (round.superJackpotWin) {
                        html += `<div class="history-jackpot" style="color:#00e5ff;">💎 Super Jackpot: ${round.superJackpotWinner} won $${Math.round(round.superJackpotAmount)}</div>`;
                    }
                    
                    if (round.insuranceWin) {
                        html += `<div class="history-jackpot">🛡️ Insurance Jackpot: ${round.insuranceWinner} won $${Math.round(round.insuranceAmount)}</div>`;
                    }
                    
                    // Add bank card info
                    const bankCardDisplay = this.formatCardDisplay(round.bankCard);
                    html += `<div style="font-size: 11px; color: #bdc3c7; margin-top: 5px;">Bank: ${bankCardDisplay}</div>`;
                    
                    entry.innerHTML = html;
                    historyList.appendChild(entry);
                });
            }
            
            makeHistoryPanelDraggable() {
                const panel = this.elements.historyPanel;
                const header = panel.querySelector('.history-header');
                let isDragging = false;
                let currentX;
                let currentY;
                let initialX;
                let initialY;
                let xOffset = 0;
                let yOffset = 0;
                
                header.addEventListener('mousedown', dragStart);
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', dragEnd);
                
                function dragStart(e) {
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                    
                    if (e.target === header || header.contains(e.target)) {
                        isDragging = true;
                    }
                }
                
                function drag(e) {
                    if (isDragging) {
                        e.preventDefault();
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                        
                        xOffset = currentX;
                        yOffset = currentY;
                        
                        panel.style.transform = `translate(${currentX}px, ${currentY}px)`;
                    }
                }
                
                function dragEnd(e) {
                    initialX = currentX;
                    initialY = currentY;
                    isDragging = false;
                }
            }

            makeRulesModalDraggable() {
                const panel = document.getElementById('rules-modal');
                const header = panel ? panel.querySelector('.rules-header') : null;
                if (!panel || !header) return;
                
                let isDragging = false;
                let currentX;
                let currentY;
                let initialX;
                let initialY;
                let xOffset = 0;
                let yOffset = 0;
                
                header.addEventListener('mousedown', dragStart);
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', dragEnd);
                
                function dragStart(e) {
                    // Don't start dragging if clicking the close button
                    if (e.target.classList.contains('close-rules-btn')) {
                        return;
                    }
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                    
                    if (e.target === header || header.contains(e.target)) {
                        isDragging = true;
                    }
                }
                
                function drag(e) {
                    if (isDragging) {
                        e.preventDefault();
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                        
                        xOffset = currentX;
                        yOffset = currentY;
                        
                        panel.style.transform = `translate(${currentX}px, ${currentY}px)`;
                    }
                }
                
                function dragEnd(e) {
                    initialX = currentX;
                    initialY = currentY;
                    isDragging = false;
                }
            }
            
            makeMatrixModalDraggable() {
                const panel = document.getElementById('matrix-modal');
                const header = panel ? panel.querySelector('.matrix-header') : null;
                if (!panel || !header) return;
                
                let isDragging = false;
                let currentX;
                let currentY;
                let initialX;
                let initialY;
                let xOffset = 0;
                let yOffset = 0;
                
                header.addEventListener('mousedown', dragStart);
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', dragEnd);
                
                function dragStart(e) {
                    // Don't start dragging if clicking the close button
                    if (e.target.classList.contains('close-matrix-btn')) {
                        return;
                    }
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                    
                    if (e.target === header || header.contains(e.target)) {
                        isDragging = true;
                    }
                }
                
                function drag(e) {
                    if (isDragging) {
                        e.preventDefault();
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                        
                        xOffset = currentX;
                        yOffset = currentY;
                        
                        panel.style.transform = `translate(${currentX}px, ${currentY}px)`;
                    }
                }
                
                function dragEnd(e) {
                    initialX = currentX;
                    initialY = currentY;
                    isDragging = false;
                }
            }

            showRules() {
                const rulesModal = document.getElementById('rules-modal');
                if (rulesModal) {
                    rulesModal.classList.remove('hidden');
                    console.log('Rules modal opened');
                }
            }

            hideRules() {
                const rulesModal = document.getElementById('rules-modal');
                if (rulesModal) {
                    rulesModal.classList.add('hidden');
                    console.log('Rules modal closed');
                }
            }

            showMatrix() {
                const matrixModal = document.getElementById('matrix-modal');
                if (matrixModal) {
                    matrixModal.classList.remove('hidden');
                    // Regenerate matrix with current settings
                    this.generateDynamicMatrix();
                    console.log('Matrix modal opened');
                }
            }
            
            generateDynamicMatrix() {
                const table = document.getElementById('dynamic-matrix-table');
                if (!table) {
                    console.error('Matrix table element not found');
                    return;
                }
                
                // Clear existing content
                table.innerHTML = '';
                
                // Create header row
                const headerRow = table.insertRow();
                const headers = ['Card', 'Bet Value', 'k=A', 'k=2', 'k=3', 'k=4', 'k=5', 'k=6', 'k=7', 'k=8', 'k=9', 'k=10'];
                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.textContent = header;
                    headerRow.appendChild(th);
                });
                
                // Card ranks and their values (A through 9 for players)
                const cardRanks = ['A', '2', '3', '4', '5', '6', '7', '8', '9'];
                const bankRanks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10']; // Bank can draw 10
                const cardValues = { 'A': 10, '2': 15, '3': 23, '4': 34, '5': 51, '6': 76, '7': 114, '8': 171, '9': 256 };
                
                // Add rows for each card (A through 9)
                cardRanks.forEach(playerRank => {
                    const row = table.insertRow();
                    
                    // Card name
                    const cardCell = row.insertCell();
                    cardCell.textContent = playerRank;
                    cardCell.className = 'card-name';
                    
                    // Bet value for this card
                    const betCell = row.insertCell();
                    betCell.textContent = cardValues[playerRank];
                    betCell.className = 'bet-value';
                    
                    // Results for each possible bank card (A through 10)
                    bankRanks.forEach(bankRank => {
                        const cell = row.insertCell();
                        const result = this.calculateMatrixResult(playerRank, bankRank, cardValues[playerRank]);
                        cell.textContent = result.display;
                        cell.className = result.cssClass;
                    });
                });
                
                // Add jackpot row
                const jackpotRow = table.insertRow();
                const jackpotCardCell = jackpotRow.insertCell();
                jackpotCardCell.textContent = 'Jackpot';
                jackpotCardCell.className = 'jackpot-label';
                
                const jackpotBetCell = jackpotRow.insertCell();
                jackpotBetCell.textContent = '-';
                jackpotBetCell.className = 'jackpot-label';
                
                // Jackpot contributions for each bank card
                bankRanks.forEach(bankRank => {
                    const cell = jackpotRow.insertCell();
                    const jackpotValue = this.calculateJackpotContribution(bankRank);
                    cell.textContent = Math.round(jackpotValue);
                    cell.className = 'jackpot';
                });
                
                console.log('Dynamic matrix generated successfully');
            }
            
            calculateMatrixResult(playerRank, bankRank, betValue) {
                const playerIndex = this.getCardIndex(playerRank);
                const bankIndex = this.getCardIndex(bankRank);
                
                if (bankRank === '10') {
                    // Special case: Bank draws 10
                    if (playerRank === '9') {
                        // Player 9 wins when bank draws 10
                        return { display: `739`, cssClass: 'win' };
                    } else {
                        // All other players lose their entire bet when bank draws 10
                        return { display: `-${betValue}`, cssClass: 'loss' };
                    }
                } else if (bankRank === 'A') {
                    // Special case: Bank draws Ace - all players lose (no loser scenario, all money to jackpot)
                    return { display: `-${betValue}`, cssClass: 'loss' };
                } else if (playerRank === bankRank) {
                    // Loss - same card as bank
                    return { display: `-${betValue}`, cssClass: 'loss' };
                } else if (playerIndex < bankIndex) {
                    // Win - lower card than bank
                    const winAmount = this.calculateWinAmount(playerRank, bankRank, betValue);
                    return { display: `${winAmount}`, cssClass: 'win' };
                } else {
                    // Refund - higher card than bank
                    const jackpotContribution = Math.round(betValue * GAME_CONFIG.JACKPOT_RATE);
                    const refund = betValue - jackpotContribution;
                    return { display: `${refund}`, cssClass: 'refund' };
                }
            }
            
            calculateWinAmount(playerRank, bankRank, betValue) {
                // Simulate the actual cascade distribution logic
                const cardValues = { 'A': 10, '2': 15, '3': 23, '4': 34, '5': 51, '6': 76, '7': 114, '8': 171, '9': 256 };
                const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9'];
                
                const bankIndex = rankOrder.indexOf(bankRank);
                const playerIndex = rankOrder.indexOf(playerRank);
                
                // If player is same or higher than bank, they don't win
                if (playerIndex >= bankIndex) {
                    return 0;
                }
                
                // Get the losing player's bet (the bank card)
                const losingBet = cardValues[bankRank];
                
                // Calculate bank rate
                const bankRake = losingBet * GAME_CONFIG.BANK_RATE;
                let winnerPool = losingBet - bankRake;
                
                // Find all winners (all players with rank < bankRank)
                const winners = [];
                rankOrder.forEach((rank, idx) => {
                    if (idx < bankIndex && rank !== bankRank) {
                        winners.push({ rank, index: idx, bet: cardValues[rank] });
                    }
                });
                
                // Sort winners by rank (descending - highest first, for cascade)
                winners.sort((a, b) => b.index - a.index);
                
                // Special Rule 2: Bank draws 2 - only Ace wins
                if (bankRank === '2') {
                    if (playerRank === 'A') {
                        // Ace gets 50% of pool
                        const aceWinAmount = winnerPool * GAME_CONFIG.CASCADE_RATE;
                        return Math.round(betValue + aceWinAmount);
                    }
                    return 0;
                }
                
                // Normal cascade distribution
                // Find where this player ranks among winners
                const winnerIndices = winners.map(w => w.index);
                const position = winnerIndices.indexOf(playerIndex);
                
                if (position === -1) {
                    return 0; // Not a winner
                }
                
                // Simulate cascade: each winner takes 50% of remaining pool
                let currentPool = winnerPool;
                let playerWinShare = 0;
                
                for (let i = 0; i < winners.length; i++) {
                    let winAmount;
                    if (i === winners.length - 1) {
                        // Last winner (lowest) gets remaining pool
                        winAmount = currentPool;
                    } else {
                        // Each winner gets 50% of current pool
                        winAmount = currentPool * GAME_CONFIG.CASCADE_RATE;
                    }
                    
                    if (i === position) {
                        // This is the player we're calculating for
                        playerWinShare = winAmount;
                        break;
                    }
                    
                    currentPool -= winAmount;
                }
                
                // Player gets bet back + pool share
                return Math.round(betValue + playerWinShare);
            }
            
            getCardIndex(rank) {
                const cardOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
                return cardOrder.indexOf(rank);
            }
            
            calculateJackpotContribution(bankRank) {
                // Calculate total jackpot contribution for each bank card
                // This is the sum of jackpot contributions from all refund players
                const cardRanks = ['A', '2', '3', '4', '5', '6', '7', '8', '9'];
                const cardValues = { 'A': 10, '2': 15, '3': 23, '4': 34, '5': 51, '6': 76, '7': 114, '8': 171, '9': 256 };
                
                let totalJackpot = 0;
                const bankIndex = this.getCardIndex(bankRank);
                
                cardRanks.forEach(playerRank => {
                    const playerIndex = this.getCardIndex(playerRank);
                    const betValue = cardValues[playerRank];
                    
                    // If player card index > bank card index, it's a refund (contributes to jackpot)
                    if (playerIndex > bankIndex) {
                        totalJackpot += betValue * GAME_CONFIG.JACKPOT_RATE;
                    }
                });
                
                return totalJackpot;
            }

            hideMatrix() {
                const matrixModal = document.getElementById('matrix-modal');
                if (matrixModal) {
                    matrixModal.classList.add('hidden');
                    console.log('Matrix modal closed');
                }
            }

            resetBankCardDisplay() {
                console.log('Resetting bank card display to card back...');
                this.elements.bankCard.classList.remove('revealed');
                this.elements.bankCard.innerHTML = '<div class="card-back">🏦</div>';
            }

            clearPlayerResultClasses() {
                console.log('Clearing player result classes...');
                const gameData = this.stateManager.getGameData();
                gameData.players.forEach(player => {
                    const seat = document.getElementById(`player-${player.id}`);
                    if (seat) {
                        // Remove all result-related classes but keep card-selected for card visibility
                        seat.classList.remove('win', 'loss', 'refund', 'jackpot', 'selected', 'current-turn');
                        
                        // Remove ALL result text elements (not just the first one)
                        const resultTexts = seat.querySelectorAll('.result-text');
                        resultTexts.forEach(resultText => {
                            resultText.remove();
                        });
                        
                        console.log(`Cleared result classes for ${player.name}`);
                    }
                });
            }
            
            clearCardSelectedClasses() {
                console.log('Clearing card-selected classes for new round...');
                
                // Reset human insurance icons for new round
                this.resetHumanInsuranceIcons();
                
                const gameData = this.stateManager.getGameData();
                gameData.players.forEach(player => {
                    const seat = document.getElementById(`player-${player.id}`);
                    if (seat) {
                        // Remove card-selected class and clear card area for new round
                        seat.classList.remove('card-selected');
                        
                        // Clear the player's card area
                        const playerCardArea = seat.querySelector('.player-card');
                        if (playerCardArea) {
                            playerCardArea.innerHTML = '';
                            playerCardArea.style.background = '';
                            playerCardArea.style.border = '';
                            playerCardArea.style.color = '';
                            // Remove hearts-jackpot class for new round
                            playerCardArea.classList.remove('hearts-jackpot');
                        }
                        
                        console.log(`Cleared card-selected class for ${player.name}`);
                    }
                });
            }

            revealAllPlayerCards() {
                console.log('All cards are already revealed when they reach player seats - no need to reveal again');
                // Cards are now revealed immediately when they reach player seats
                // This function is kept for compatibility but does nothing
            }

            showCurrentTurn(playerId) {
                console.log(`=== showCurrentTurn called for player ${playerId} ===`);
                const seat = document.getElementById(`player-${playerId}`);
                if (seat) {
                    console.log(`Adding current-turn class to player ${playerId}`);
                    seat.classList.add('current-turn');
                    console.log(`Player ${playerId} seat classes:`, seat.className);
                    console.log(`Player ${playerId} seat element:`, seat);
                    
                    // Force a style update
                    seat.style.border = '3px solid #007bff';
                    seat.style.boxShadow = '0 0 15px #007bff';
                    console.log(`Applied forced blue border to player ${playerId}`);
                } else {
                    console.error(`Player seat not found for ID: ${playerId}`);
                }
            }

            clearCurrentTurn() {
                console.log('Clearing turn indication');
                const gameData = this.stateManager.getGameData();
                gameData.players.forEach(player => {
                    const seat = document.getElementById(`player-${player.id}`);
                    if (seat) {
                        seat.classList.remove('current-turn');
                        // Remove forced styles
                        seat.style.border = '';
                        seat.style.boxShadow = '';
                        console.log(`Cleared turn indication for player ${player.id}`);
                    }
                });
                // Clear current turn markers but keep first player marker visible
                this.gameLogic.clearCurrentTurnMarkers();
            }

            continueWithNextPlayer() {
                // Continue with the remaining players
                this.continueWithRemainingPlayers();
            }

            updateTableCardDisplay(rank, playerName) {
                console.log(`updateTableCardDisplay called with rank: ${rank}, playerName: ${playerName}`);
                
                // Clear countdown timer if it exists (for bot players in manual mode)
                this.stopManualCountdown();
                
                // Find the table card with this rank
                const tableCards = document.querySelectorAll('.table-card');
                console.log(`Found ${tableCards.length} table cards`);
                
                let selectedCard = null;
                tableCards.forEach(card => {
                    if (card.dataset.rank === rank) {
                        console.log(`Updating card ${rank} with player name: ${playerName}`);
                        card.classList.add('selected');
                        card.setAttribute('data-selected-by', playerName);
                        
                        // White card styling for all players
                        card.style.background = 'linear-gradient(145deg, #fff, #f0f0f0)';
                        card.style.border = '2px solid #333';
                        card.style.color = '#333';
                        card.style.fontWeight = 'bold';
                        
                        // Show player name on card only for human players
                        if (playerName === 'You') {
                            const originalText = card.textContent;
                            card.textContent = `${originalText}\n${playerName}`;
                        }
                        
                        selectedCard = card;
                        
                        // Animate chip from player to card
                        setTimeout(() => {
                            const gameData = this.stateManager.getGameData();
                            const player = gameData.players.find(p => p.name === playerName);
                            if (player) {
                                this.animateChipToCard(player.id, card);
                            }
                        }, 200);
                    }
                });
                
                // Add card-selected class to player seat
                const gameData = this.stateManager.getGameData();
                const player = gameData.players.find(p => p.name === playerName);
                if (player) {
                    const playerSeat = document.getElementById(`player-${player.id}`);
                    if (playerSeat) {
                        playerSeat.classList.add('card-selected');
                        console.log(`Added card-selected class to player ${playerName} (ID: ${player.id})`);
                        
                        // Animate card to player seat
                        if (selectedCard) {
                            this.animateCardToPlayerSeat(selectedCard, player.id);
                        }
                    }
                }
            }

            animateCardToPlayerSeat(cardElement, playerId) {
                console.log(`=== animateCardToPlayerSeat called for player ${playerId} ===`);
                
                // Play card drag sound
                console.log('Playing card drag sound...');
                this.soundManager.playSound('cardDrag');
                
                const playerSeat = document.getElementById(`player-${playerId}`);
                if (!playerSeat) {
                    console.error(`Player seat not found for ID: ${playerId}`);
                    return;
                }
                
                // Find the player's card area (the white area where cards are displayed)
                const playerCardArea = playerSeat.querySelector('.player-card');
                if (!playerCardArea) {
                    console.error(`Player card area not found for player ${playerId}`);
                    return;
                }
                
                // Get positions relative to viewport
                const cardRect = cardElement.getBoundingClientRect();
                const cardAreaRect = playerCardArea.getBoundingClientRect();
                
                console.log(`Card position: (${cardRect.left}, ${cardRect.top})`);
                console.log(`Target position: (${cardAreaRect.left}, ${cardAreaRect.top})`);
                
                // Create a copy for animation
                const animatedCard = cardElement.cloneNode(true);
                
                // Immediately clear all classes and styles to prevent conflicts
                animatedCard.className = '';
                animatedCard.removeAttribute('class');
                animatedCard.style.cssText = '';
                
                // IMPORTANT: Clean up the card content to show only rank during animation
                // Extract just the rank from the card (remove any player name or extra text)
                const rankElement = animatedCard.querySelector('.card-rank');
                const suitElement = animatedCard.querySelector('.card-suit');
                
                // Get the rank value - prioritize dataset, then element text (split on newline to remove player name)
                let cardRank = cardElement.dataset.rank || '';
                if (rankElement) {
                    const rankText = rankElement.textContent.trim().split('\n')[0];
                    if (rankText) cardRank = rankText;
                }
                if (!cardRank) cardRank = '?';
                
                // Get suit symbol if available
                let suitSymbol = '';
                if (suitElement) {
                    suitSymbol = suitElement.textContent.trim().split('\n')[0];
                }
                
                // Clear and set clean content for animation (just rank and suit, no player name)
                animatedCard.innerHTML = '';
                const cleanRank = document.createElement('div');
                cleanRank.className = 'card-rank';
                cleanRank.textContent = cardRank;
                animatedCard.appendChild(cleanRank);
                
                if (suitSymbol) {
                    const cleanSuit = document.createElement('div');
                    cleanSuit.className = 'card-suit';
                    cleanSuit.textContent = suitSymbol;
                    animatedCard.appendChild(cleanSuit);
                }
                
                // Set up the animated card with fixed positioning
                animatedCard.style.position = 'fixed';
                animatedCard.style.left = `${cardRect.left}px`;
                animatedCard.style.top = `${cardRect.top}px`;
                animatedCard.style.width = `${cardRect.width}px`;
                animatedCard.style.height = `${cardRect.height}px`;
                animatedCard.style.zIndex = '1000';
                animatedCard.style.pointerEvents = 'none';
                animatedCard.style.transition = 'all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                animatedCard.style.background = 'linear-gradient(145deg, #fff, #f0f0f0)';
                animatedCard.style.color = '#333';
                animatedCard.style.border = '2px solid #333';
                animatedCard.style.borderRadius = '10px';
                
                // Add to body to ensure proper positioning
                document.body.appendChild(animatedCard);
                
                // Hide the original card in the ring immediately
                cardElement.style.opacity = '0';
                cardElement.style.pointerEvents = 'none';
                
                // Also hide the card immediately to prevent it from being visible
                cardElement.style.display = 'none';
                
                // Animate to target position
                setTimeout(() => {
                    console.log(`Animating to target: (${cardAreaRect.left}, ${cardAreaRect.top})`);
                    animatedCard.style.left = `${cardAreaRect.left}px`;
                    animatedCard.style.top = `${cardAreaRect.top}px`;
                    animatedCard.style.width = `${cardAreaRect.width}px`;
                    animatedCard.style.height = `${cardAreaRect.height}px`;
                }, 50);
                
                // After animation, move card to player area and reveal it immediately
                setTimeout(() => {
                    console.log(`Moving card to player area for player ${playerId}`);
                    
                    // Get the player's selected card
                    const player = this.stateManager.getPlayer(playerId);
                    if (!player || !player.selectedCard) {
                        console.error(`No selected card found for player ${playerId}`);
                        return;
                    }
                    
                    // Player card area should already be empty from updatePlayerDisplay
                    console.log(`🎴 Player card area for ${playerId} should be empty, current content:`, playerCardArea.innerHTML);
                    
                    // Reset animated card styles for final positioning
                    animatedCard.style.position = 'relative';
                    animatedCard.style.left = '0';
                    animatedCard.style.top = '0';
                    animatedCard.style.width = '100%';
                    animatedCard.style.height = '100%';
                    animatedCard.style.transition = 'none';
                    animatedCard.style.boxShadow = '';
                    animatedCard.style.cursor = '';
                    animatedCard.style.opacity = '';
                    
                    // IMPORTANT: Clear any existing content and styles from the cloned card
                    animatedCard.innerHTML = '';
                    
                    // Calculate card value
                    const cardValue = this.getBetValue(player.selectedCard);
                    
                    // Reveal the card immediately with rank, suit, and value (vertically stacked)
                    // Set innerHTML fresh to ensure suit symbol is displayed
                    animatedCard.innerHTML = `
                        <div class="card-content">
                            <div class="card-rank">${player.selectedCard.rank}</div>
                            <div class="card-suit">${this.getSuitSymbol(player.selectedCard.suit)}</div>
                            <div class="card-value">$${cardValue}</div>
                        </div>
                    `;
                    
                    // Check if card is hearts for jackpot potential
                    if (player.selectedCard.suit === 'hearts') {
                        console.log(`💛 Adding hearts-jackpot class to animated card for player ${playerId} (${player.name}) with ${player.selectedCard.rank} of hearts`);
                        animatedCard.classList.add('hearts-jackpot');
                        // Hearts cards get gold border instead of regular border
                        animatedCard.style.border = '2px solid #ffd700';
                    } else {
                        animatedCard.classList.remove('hearts-jackpot');
                        // Regular cards get black border
                        animatedCard.style.border = '2px solid #333';
                    }
                    
                    // Move to player card area
                    playerCardArea.appendChild(animatedCard);
                    
                    // Remove from body
                    if (animatedCard.parentNode === document.body) {
                        document.body.removeChild(animatedCard);
                    }
                    
                    console.log(`Revealed card for ${player.name}: ${player.selectedCard.rank} of ${player.selectedCard.suit}`);
                }, 900);
                
                // Remove original card from ring
                setTimeout(() => {
                    if (cardElement && cardElement.parentNode) {
                        console.log(`Removing original card from ring for player ${playerId}`);
                        cardElement.remove();
                        console.log(`Removed original card from ring for player ${playerId}`);
                    } else {
                        console.log(`Original card already removed or not found for player ${playerId}`);
                    }
                }, 1000);
                
                // Keep the animated card in the player's card area - don't remove it
                // The animated card will now stay in the player's white card area
            }

            showAdminManualSelection(botId, resolve) {
                const player = this.stateManager.getPlayer(botId);
                const availableCards = this.stateManager.getAvailableCards();
                
                console.log(`Showing admin manual selection for ${player.name}, available cards:`, availableCards);
                
                // Store the resolve function for this bot
                this.pendingManualSelection = { botId, resolve };
                
                // Show admin instruction
                this.elements.gameState.textContent = `Admin: Click a card on the table for ${player.name}`;
                
                // Start countdown for admin manual selection
                this.startManualCountdown(botId, player.name);
                
                // Enable table cards for admin selection
                const tableCards = document.querySelectorAll('.table-card');
                console.log(`Found ${tableCards.length} table cards for admin selection`);
                tableCards.forEach(card => {
                    const rank = card.dataset.rank;
                    if (availableCards.includes(rank)) {
                        // Add admin selection styling
                        card.classList.add('admin-selectable');
                        card.style.border = '3px solid #ff6b35';
                        card.style.boxShadow = '0 0 15px #ff6b35';
                        card.style.cursor = 'pointer';
                        
                        // Add click handler for admin selection
                        card._adminClickHandler = (e) => {
                            console.log(`=== ADMIN CLICKED CARD ${rank} for ${player.name} ===`);
                            e.preventDefault();
                            e.stopPropagation();
                            this.selectCardForBot(botId, rank, resolve);
                        };
                        card.addEventListener('click', card._adminClickHandler, true); // Use capture phase
                        console.log(`Added admin click handler to card ${rank}`);
                        
                        // Add a simple test to verify the card is clickable
                        card.addEventListener('mousedown', () => {
                            console.log(`Mouse down on card ${rank} - card is responsive`);
                        });
                        
                        console.log(`Enabled admin selection for card ${rank}`);
                    } else {
                        // Don't mark already selected cards as unavailable - they should remain visible
                        // card.classList.add('unavailable');
                        // card.style.opacity = '0.5';
                        // card.style.cursor = 'not-allowed';
                        console.log(`Card ${rank} is already selected, keeping it visible`);
                    }
                });
            }

            selectCardForBot(botId, selectedRank, resolve) {
                console.log(`Admin selected card ${selectedRank} for bot ${botId}`);
                
                // Clear countdown timer if it exists
                if (this.countdownTimer) {
                    clearInterval(this.countdownTimer);
                    this.countdownTimer = null;
                    console.log('Countdown timer cleared due to admin card selection');
                    
                    // Hide the timer display
                    const playerSeat = document.getElementById(`player-${botId}`);
                    const timerElement = playerSeat ? playerSeat.querySelector('.manual-timer') : null;
                    if (timerElement) {
                        timerElement.style.display = 'none';
                        // Reset timer text for next use
                        const timerTextSpan = timerElement.querySelector('.timer-text');
                        if (timerTextSpan) {
                            timerTextSpan.textContent = '5s';
                        }
                    }
                }
                
                // Assign a random suit
                const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
                const suit = suits[Math.floor(Math.random() * suits.length)];
                const card = { rank: selectedRank, suit };
                
                // Select the card
                this.stateManager.selectCard(botId, card);
                
                // Clean up table cards
                this.cleanupAdminSelection();
                
                // Clear pending selection
                this.pendingManualSelection = null;
                
                // Resolve the promise
                resolve(true);
            }

            cleanupAdminSelection() {
                console.log('=== CLEANING UP ADMIN SELECTION ===');
                const tableCards = document.querySelectorAll('.table-card');
                console.log(`Found ${tableCards.length} table cards to clean up`);
                tableCards.forEach(card => {
                    const rank = card.dataset.rank;
                    console.log(`Cleaning up card ${rank}`);
                    
                    // Remove admin styling
                    card.classList.remove('admin-selectable');
                    card.style.border = '';
                    card.style.boxShadow = '';
                    card.style.cursor = '';
                    card.style.opacity = '';
                    
                    // Remove admin click handler
                    if (card._adminClickHandler) {
                        console.log(`Removing admin click handler from card ${rank}`);
                        card.removeEventListener('click', card._adminClickHandler, true); // Use capture phase
                        card._adminClickHandler = null;
                    } else {
                        console.log(`No admin click handler found on card ${rank}`);
                    }
                });
                console.log('=== ADMIN SELECTION CLEANUP COMPLETE ===');
            }


            makeRandomSelectionForPlayer(playerId, playerName) {
                console.log(`Making random selection for ${playerName} (ID: ${playerId})`);
                
                const availableCards = this.stateManager.getAvailableCards();
                if (availableCards.length > 0) {
                    const randomRank = availableCards[Math.floor(Math.random() * availableCards.length)];
                    const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
                    const suit = suits[Math.floor(Math.random() * suits.length)];
                    const card = { rank: randomRank, suit };
                    
                    console.log(`Random selection: ${randomRank} of ${suit}`);
                    
                    if (this.stateManager.selectCard(playerId, card)) {
                        console.log(`Random selection successful for ${playerName}`);
                        
                        // Play card selection sound
                        this.soundManager.playSound('cardSelect');
                        
                        // Update displays
                        this.updatePlayerDisplay(playerId);
                        this.updateGameDisplay();
                        
                        // Update table card display
                        this.updateTableCardDisplay(randomRank, playerName);
                        
                        // Check if all cards are selected
                        if (this.stateManager.allCardsSelected()) {
                            console.log('All cards selected, moving to reveal phase');
                            this.stateManager.setState(GAME_STATES.REVEALING_CARDS);
                        } else {
                            // Continue with remaining players
                            setTimeout(() => {
                                this.continueWithRemainingPlayers();
                            }, 1000);
                        }
                    }
                } else {
                    console.log(`No available cards for ${playerName}`);
                }
            }

            delay(ms) {
                return new Promise(resolve => {
                    const checkPause = () => {
                        if (this.stateManager && this.stateManager.isGamePaused()) {
                            // If paused, check again in 100ms
                            setTimeout(checkPause, 100);
                        } else {
                            // Not paused, resolve after the delay
                            setTimeout(resolve, ms);
                        }
                    };
                    checkPause();
                });
            }

            // Insurance System Functions
            showInsuranceModal() {
                const gameData = this.stateManager.getGameData();
                const insurancePot = gameData.insuranceJackpot || 0;
                
                // Check if insurance pot is large enough
                if (insurancePot < GAME_CONFIG.INSURANCE_MIN_POT) {
                    console.log(`Insurance pot too small: $${insurancePot} < $${GAME_CONFIG.INSURANCE_MIN_POT}`);
                    this.proceedWithoutInsurance();
                    return;
                }
                
                console.log('🛡️ Showing insurance purchase modal');
                
                // Update modal info
                if (this.elements.modalInsuranceCost) {
                    this.elements.modalInsuranceCost.textContent = GAME_CONFIG.INSURANCE_COST;
                } else {
                    console.error('modalInsuranceCost element not found');
                }
                
                if (this.elements.modalInsurancePot) {
                    this.elements.modalInsurancePot.textContent = Math.round(insurancePot);
                } else {
                    console.error('modalInsurancePot element not found');
                }
                
                // Generate player checkboxes
                this.generateInsurancePlayerList();
                
                // Show modal
                if (this.elements.insuranceModal) {
                    this.elements.insuranceModal.classList.remove('hidden');
                } else {
                    console.error('insuranceModal element not found');
                    this.proceedWithoutInsurance();
                    return;
                }
                
                // Start countdown timer
                this.startInsuranceTimer();
            }

            generateInsurancePlayerList() {
                const gameData = this.stateManager.getGameData();
                const playersContainer = this.elements.insurancePlayers;
                playersContainer.innerHTML = '';
                
                gameData.players.forEach(player => {
                    // Only show bot players who can afford insurance (exclude human players)
                    if (!player.isHuman && player.balance >= GAME_CONFIG.INSURANCE_COST) {
                        const playerDiv = document.createElement('div');
                        playerDiv.className = 'insurance-player';
                        
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.id = `insurance-${player.id}`;
                        checkbox.value = player.id;
                        
                        const label = document.createElement('label');
                        label.htmlFor = `insurance-${player.id}`;
                        
                        const playerInfo = document.createElement('div');
                        playerInfo.className = 'insurance-player-info';
                        
                        const playerName = document.createElement('div');
                        playerName.className = 'insurance-player-name';
                        playerName.textContent = player.name;
                        
                        const playerBalance = document.createElement('div');
                        playerBalance.className = 'insurance-player-balance';
                        playerBalance.textContent = `Balance: $${player.balance}`;
                        
                        playerInfo.appendChild(playerName);
                        playerInfo.appendChild(playerBalance);
                        
                        label.appendChild(playerInfo);
                        
                        playerDiv.appendChild(checkbox);
                        playerDiv.appendChild(label);
                        
                        playersContainer.appendChild(playerDiv);
                    }
                });
                
                // Add event listener for "Select All" checkbox
                this.setupSelectAllInsurance();
            }
            
            setupSelectAllInsurance() {
                const selectAllCheckbox = document.getElementById('select-all-bots');
                const playerCheckboxes = this.elements.insurancePlayers.querySelectorAll('input[type="checkbox"]');
                
                if (selectAllCheckbox) {
                    // Ensure select-all checkbox is unchecked by default
                    selectAllCheckbox.checked = false;
                    
                    // Remove any existing event listeners to prevent duplicates
                    selectAllCheckbox.removeEventListener('change', this.handleSelectAllChange);
                    
                    // Add event listener for select-all checkbox
                    this.handleSelectAllChange = (e) => {
                        const isChecked = e.target.checked;
                        playerCheckboxes.forEach(checkbox => {
                            checkbox.checked = isChecked;
                        });
                        console.log(`🛡️ ${isChecked ? 'Selected' : 'Deselected'} all bot insurance`);
                    };
                    
                    selectAllCheckbox.addEventListener('change', this.handleSelectAllChange);
                    
                    // Add event listeners to individual checkboxes to update select-all state
                    playerCheckboxes.forEach(checkbox => {
                        checkbox.removeEventListener('change', this.handleIndividualCheckboxChange);
                        
                        this.handleIndividualCheckboxChange = () => {
                            const checkedCount = this.elements.insurancePlayers.querySelectorAll('input[type="checkbox"]:checked').length;
                            const totalCount = playerCheckboxes.length;
                            
                            if (checkedCount === 0) {
                                selectAllCheckbox.checked = false;
                                selectAllCheckbox.indeterminate = false;
                            } else if (checkedCount === totalCount) {
                                selectAllCheckbox.checked = true;
                                selectAllCheckbox.indeterminate = false;
                            } else {
                                selectAllCheckbox.checked = false;
                                selectAllCheckbox.indeterminate = true;
                            }
                        };
                        
                        checkbox.addEventListener('change', this.handleIndividualCheckboxChange);
                    });
                }
            }

            startInsuranceTimer() {
                const gameData = this.stateManager.getGameData();
                const timerElement = this.elements.insuranceCountdown;
                
                // Get timer duration from admin panel or use default
                const timerInput = document.getElementById('insurance-timer');
                this.insuranceTimeLeft = timerInput ? parseInt(timerInput.value) : GAME_CONFIG.INSURANCE_TIMER;
                
                console.log(`🛡️ Starting insurance timer: ${this.insuranceTimeLeft} seconds`);
                
                this.updateInsuranceCountdown();
                
                this.insuranceTimer = setInterval(() => {
                    this.insuranceTimeLeft--;
                    this.updateInsuranceCountdown();
                    
                    if (this.insuranceTimeLeft <= 0) {
                        console.log('🛡️ Insurance timer expired - auto-confirming');
                        this.autoConfirmInsurance();
                    }
                }, 1000);
            }

            updateInsuranceCountdown() {
                if (this.elements.insuranceCountdown) {
                    this.elements.insuranceCountdown.textContent = `${this.insuranceTimeLeft}s`;
                }
            }

            confirmInsurancePurchases() {
                console.log('🛡️ Confirming insurance purchases');
                this.clearInsuranceTimer();
                
                const gameData = this.stateManager.getGameData();
                const checkboxes = this.elements.insurancePlayers.querySelectorAll('input[type="checkbox"]:checked');
                
                let totalInsuranceCost = 0;
                
                // Process bot insurance purchases from modal
                checkboxes.forEach(checkbox => {
                    const playerId = parseInt(checkbox.value);
                    const player = gameData.players.find(p => p.id === playerId);
                    
                    // Check insurance pot BEFORE each purchase (pot needs to be >= MIN before adding this purchase)
                    const currentInsurancePot = gameData.insuranceJackpot || 0;
                    if (currentInsurancePot < GAME_CONFIG.INSURANCE_MIN_POT) {
                        console.log(`🛡️ Cannot process insurance purchase for ${player ? player.name : 'player ' + playerId} - pot too small: $${currentInsurancePot} < $${GAME_CONFIG.INSURANCE_MIN_POT}`);
                        return; // Skip this purchase
                    }
                    
                    if (player && player.balance >= GAME_CONFIG.INSURANCE_COST && !player.hasInsurance) {
                        console.log(`🛡️ Player ${player.name} (${playerId}) bought insurance for $${GAME_CONFIG.INSURANCE_COST}`);
                        
                        // Deduct insurance cost from player balance
                        this.stateManager.updatePlayerBalance(playerId, -GAME_CONFIG.INSURANCE_COST);
                        
                        // Mark player as having insurance
                        this.stateManager.updatePlayer(playerId, { hasInsurance: true });
                        
                        // Add to insurance jackpot first
                        gameData.insuranceJackpot += GAME_CONFIG.INSURANCE_COST;
                        
                        // Add insurance marker to player seat
                        this.addInsuranceMarker(playerId);
                        
                        // Update player display immediately to show new balance
                        this.updatePlayerDisplay(playerId);
                        
                        totalInsuranceCost += GAME_CONFIG.INSURANCE_COST;
                    }
                });
                
                // Process human insurance purchases (already handled by click events, just check if they have insurance)
                gameData.players.forEach(player => {
                    if (player.isHuman && player.hasInsurance) {
                        // Human player insurance was already added to pot in handleHumanInsuranceClick
                        // Just make sure marker is added if missing
                        this.addInsuranceMarker(player.id);
                    }
                });
                
                // Update admin panel and insurance display immediately (pot already updated in loop above)
                if (totalInsuranceCost > 0) {
                    console.log(`🛡️ Processed $${totalInsuranceCost} in insurance purchases`);
                    this.updateAdminPanel();
                    this.updateInsuranceJackpotDisplay();
                }
                
                this.hideInsuranceModal();
                this.proceedToCardSelection();
            }

            skipInsurance() {
                console.log('🛡️ Skipping insurance phase');
                this.clearInsuranceTimer();
                this.hideInsuranceModal();
                this.proceedToCardSelection();
            }

            autoConfirmInsurance() {
                console.log('🛡️ Auto-confirming insurance (timer expired)');
                this.confirmInsurancePurchases();
            }

            clearInsuranceTimer() {
                if (this.insuranceTimer) {
                    clearInterval(this.insuranceTimer);
                    this.insuranceTimer = null;
                }
            }

            hideInsuranceModal() {
                if (this.elements.insuranceModal) {
                    this.elements.insuranceModal.classList.add('hidden');
                }
                // Disable human insurance icons after insurance phase
                this.disableHumanInsuranceIcons();
            }
            
            enableHumanInsuranceIcons() {
                console.log('🛡️ Enabling human insurance icons...');
                const gameData = this.stateManager.getGameData();
                gameData.players.forEach(player => {
                    if (player.isHuman) {
                        const icon = document.getElementById(`human-insurance-${player.id}`);
                        console.log(`🛡️ Human player ${player.id} (${player.name}): icon found = ${!!icon}, balance = $${player.balance}`);
                        if (icon) {
                            icon.classList.remove('disabled');
                            if (player.balance >= GAME_CONFIG.INSURANCE_COST) {
                                icon.style.display = 'block';
                                console.log(`🛡️ Enabled insurance icon for ${player.name}`);
                            } else {
                                icon.classList.add('disabled');
                                console.log(`🛡️ Disabled insurance icon for ${player.name} (insufficient balance)`);
                            }
                        } else {
                            console.log(`🛡️ No insurance icon found for player ${player.id}`);
                        }
                    }
                });
            }
            
            disableHumanInsuranceIcons() {
                const gameData = this.stateManager.getGameData();
                gameData.players.forEach(player => {
                    if (player.isHuman) {
                        const icon = document.getElementById(`human-insurance-${player.id}`);
                        if (icon) {
                            icon.classList.add('disabled');
                        }
                    }
                });
            }
            
            resetHumanInsuranceIcons() {
                const gameData = this.stateManager.getGameData();
                gameData.players.forEach(player => {
                    if (player.isHuman) {
                        const icon = document.getElementById(`human-insurance-${player.id}`);
                        if (icon) {
                            icon.classList.remove('purchased', 'disabled');
                        }
                    }
                });
            }
            
            startHumanInsurancePhase() {
                console.log('🛡️ Starting human insurance phase (5 seconds)');
                
                // Check human player's insurance behavior preference
                const insuranceBehavior = this.getHumanInsuranceBehavior();
                console.log(`🛡️ Human insurance behavior: ${insuranceBehavior}`);
                
                const gameData = this.stateManager.getGameData();
                const humanPlayer = gameData.players.find(p => p.isHuman);
                
                if (insuranceBehavior === 'always') {
                    // Check if insurance pot is large enough for "always buy"
                    const insurancePot = gameData.insuranceJackpot || 0;
                    console.log(`🛡️ Human 'always buy' - Insurance pot check: $${insurancePot} >= $${GAME_CONFIG.INSURANCE_MIN_POT}?`);
                    
                    if (insurancePot >= GAME_CONFIG.INSURANCE_MIN_POT) {
                        console.log('🛡️ Human player set to always buy insurance - purchasing automatically');
                        if (humanPlayer && !humanPlayer.hasInsurance) {
                            this.handleHumanInsuranceClick(humanPlayer.id);
                        }
                        // Skip countdown and proceed directly to bot phase
                        setTimeout(() => {
                            this.endHumanInsurancePhase();
                        }, 1000); // Short delay to show the purchase
                        return;
                    } else {
                        console.log(`🛡️ Human 'always buy' - Insurance pot too small: $${insurancePot} < $${GAME_CONFIG.INSURANCE_MIN_POT}`);
                        // Skip countdown and proceed directly to bot phase
                        setTimeout(() => {
                            this.endHumanInsurancePhase();
                        }, 1000);
                        return;
                    }
                } else if (insuranceBehavior === 'never') {
                    console.log('🛡️ Human player set to never buy insurance - skipping phase');
                    // Skip countdown and proceed directly to bot phase
                    setTimeout(() => {
                        this.endHumanInsurancePhase();
                    }, 1000); // Short delay for consistency
                    return;
                }
                
                // Check if insurance pot is large enough
                const insurancePot = gameData.insuranceJackpot || 0;
                console.log(`🛡️ Insurance pot check: $${insurancePot} >= $${GAME_CONFIG.INSURANCE_MIN_POT}?`);
                
                if (insurancePot < GAME_CONFIG.INSURANCE_MIN_POT) {
                    console.log(`Insurance pot too small: $${insurancePot} < $${GAME_CONFIG.INSURANCE_MIN_POT}`);
                    this.proceedWithoutInsurance();
                    return;
                }
                
                // Enable human insurance icons
                this.enableHumanInsuranceIcons();
                
                // Show countdown message
                this.showHumanInsuranceCountdown();
                
                // Start 5-second timer for human phase
                this.humanInsuranceTimer = setTimeout(() => {
                    console.log('🛡️ Human insurance phase ended, starting bot phase');
                    this.endHumanInsurancePhase();
                }, 5000);
            }
            
            showHumanInsuranceCountdown() {
                // Create or update countdown display
                let countdownElement = document.getElementById('human-insurance-countdown');
                if (!countdownElement) {
                    countdownElement = document.createElement('div');
                    countdownElement.id = 'human-insurance-countdown';
                    countdownElement.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: rgba(52, 152, 219, 0.9);
                        color: white;
                        padding: 20px 30px;
                        border-radius: 10px;
                        font-size: 18px;
                        font-weight: bold;
                        text-align: center;
                        z-index: 2000;
                        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                    `;
                    document.body.appendChild(countdownElement);
                }
                
                let timeLeft = 5;
                countdownElement.innerHTML = `
                    <div>🛡️ INSURANCE AVAILABLE 🛡️</div>
                    <div style="margin-top: 10px;">Insurance Pot: $${this.stateManager.getGameData().insuranceJackpot}</div>
                    <div style="margin-top: 10px;">Cost: $${GAME_CONFIG.INSURANCE_COST}</div>
                    <button id="buy-insurance-btn" style="margin-top: 15px; padding: 10px 20px; font-size: 16px; background: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">Buy Insurance</button>
                    <div style="margin-top: 10px; font-size: 24px; color: #FFD700;">${timeLeft}s</div>
                `;
                
                // Add click handler for buy insurance button
                const buyBtn = document.getElementById('buy-insurance-btn');
                if (buyBtn) {
                    // Set initial button state based on current insurance status
                    const humanPlayer = this.stateManager.getGameData().players.find(p => p.isHuman);
                    if (humanPlayer && humanPlayer.hasInsurance) {
                        buyBtn.textContent = 'Cancel Insurance';
                        buyBtn.style.background = '#27ae60';
                    } else {
                        buyBtn.textContent = 'Buy Insurance';
                        buyBtn.style.background = '#e74c3c';
                    }
                    
                    buyBtn.addEventListener('click', () => {
                        if (humanPlayer) {
                            this.handleHumanInsuranceClick(humanPlayer.id);
                        }
                    });
                }
                
                // Update countdown every second
                this.humanCountdownInterval = setInterval(() => {
                    timeLeft--;
                    if (timeLeft > 0) {
                        countdownElement.querySelector('div:last-child').textContent = `${timeLeft}s`;
                    } else {
                        clearInterval(this.humanCountdownInterval);
                    }
                }, 1000);
            }
            
            endHumanInsurancePhase() {
                // Clear timers
                if (this.humanInsuranceTimer) {
                    clearTimeout(this.humanInsuranceTimer);
                    this.humanInsuranceTimer = null;
                }
                if (this.humanCountdownInterval) {
                    clearInterval(this.humanCountdownInterval);
                    this.humanCountdownInterval = null;
                }
                
                // Remove countdown display
                const countdownElement = document.getElementById('human-insurance-countdown');
                if (countdownElement) {
                    countdownElement.remove();
                }
                
                // Disable human insurance icons
                this.disableHumanInsuranceIcons();
                
                // Process bot insurance based on their individual settings from Bot Control Panel
                this.processBotInsuranceFromPanel();
            }
            
            processBotInsuranceFromPanel() {
                console.log('🛡️ Processing bot insurance from Bot Control Panel settings');
                
                const gameData = this.stateManager.getGameData();
                const bots = gameData.players.filter(player => !player.isHuman);
                
                const botsNeedingManualDecision = [];
                
                bots.forEach(bot => {
                    const insuranceBehavior = bot.insuranceBehavior || 'ask'; // Default to 'ask' if not set
                    console.log(`🛡️ Bot ${bot.name} (ID: ${bot.id}) insurance behavior: ${insuranceBehavior}`);
                    
                    if (insuranceBehavior === 'always') {
                        // Bot always buys insurance - but only if pot is large enough
                        const insurancePot = gameData.insuranceJackpot || 0;
                        console.log(`🛡️ Bot ${bot.name} 'always buy' - Insurance pot check: $${insurancePot} >= $${GAME_CONFIG.INSURANCE_MIN_POT}?`);
                        
                        if (insurancePot >= GAME_CONFIG.INSURANCE_MIN_POT && bot.balance >= GAME_CONFIG.INSURANCE_COST && !bot.hasInsurance) {
                            console.log(`🛡️ Bot ${bot.name} automatically buying insurance`);
                            this.processBotInsurancePurchase(bot.id);
                        } else if (insurancePot < GAME_CONFIG.INSURANCE_MIN_POT) {
                            console.log(`🛡️ Bot ${bot.name} 'always buy' - Insurance pot too small: $${insurancePot} < $${GAME_CONFIG.INSURANCE_MIN_POT}`);
                        }
                    } else if (insuranceBehavior === 'never') {
                        // Bot never buys insurance
                        console.log(`🛡️ Bot ${bot.name} skipping insurance (never buy)`);
                    } else { // 'ask'
                        // Bot asks before round - add to list for manual decision
                        botsNeedingManualDecision.push(bot);
                    }
                });
                
                if (botsNeedingManualDecision.length > 0) {
                    console.log(`🛡️ ${botsNeedingManualDecision.length} bots need manual insurance decisions`);
                    this.showInsuranceModalForBots(botsNeedingManualDecision);
                } else {
                    console.log('🛡️ No bots need manual insurance decisions, proceeding to card selection');
                    setTimeout(() => {
                        this.proceedWithoutInsurance();
                    }, 1000);
                }
            }
            
            processBotInsurancePurchase(playerId) {
                const gameData = this.stateManager.getGameData();
                const player = gameData.players.find(p => p.id === playerId);
                
                if (!player) {
                    console.log(`🛡️ Player ${playerId} not found`);
                    return;
                }
                
                // Check if insurance pot meets minimum requirement BEFORE purchase
                const insurancePotBeforePurchase = gameData.insuranceJackpot || 0;
                if (insurancePotBeforePurchase < GAME_CONFIG.INSURANCE_MIN_POT) {
                    console.log(`🛡️ Bot ${player.name} cannot purchase insurance - pot too small: $${insurancePotBeforePurchase} < $${GAME_CONFIG.INSURANCE_MIN_POT}`);
                    return;
                }
                
                if (player.balance >= GAME_CONFIG.INSURANCE_COST && !player.hasInsurance) {
                    // Deduct insurance cost
                    player.balance -= GAME_CONFIG.INSURANCE_COST;
                    player.hasInsurance = true;
                    
                    // Add to insurance jackpot
                    gameData.insuranceJackpot += GAME_CONFIG.INSURANCE_COST;
                    
                    console.log(`🛡️ Bot ${player.name} purchased insurance. New balance: $${player.balance}`);
                    
                    // Update UI
                    this.updatePlayerSeats();
                    this.updateInsuranceJackpotDisplay();
                    this.addInsuranceMarker(playerId);
                }
            }
            
            showInsuranceModalForBots(bots) {
                console.log('🛡️ Showing insurance modal for bots that need manual decisions');
                
                // Update modal info
                if (this.elements.modalInsuranceCost) {
                    this.elements.modalInsuranceCost.textContent = GAME_CONFIG.INSURANCE_COST;
                }
                if (this.elements.modalInsurancePot) {
                    this.elements.modalInsurancePot.textContent = this.stateManager.getGameData().insuranceJackpot;
                }
                
                // Generate player checkboxes only for bots that need manual decisions
                this.generateInsurancePlayerListForBots(bots);
                
                // Show modal
                if (this.elements.insuranceModal) {
                    this.elements.insuranceModal.classList.remove('hidden');
                }
                
                // Start countdown timer
                this.startInsuranceTimer();
            }
            
            generateInsurancePlayerListForBots(bots) {
                const playersContainer = this.elements.insurancePlayers;
                playersContainer.innerHTML = '';
                
                bots.forEach(player => {
                    // Only show bots who can afford insurance
                    if (player.balance >= GAME_CONFIG.INSURANCE_COST) {
                        const playerDiv = document.createElement('div');
                        playerDiv.className = 'insurance-player';
                        
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.id = `insurance-${player.id}`;
                        checkbox.value = player.id;
                        
                        const label = document.createElement('label');
                        label.htmlFor = `insurance-${player.id}`;
                        
                        const playerInfo = document.createElement('div');
                        playerInfo.className = 'insurance-player-info';
                        
                        const playerName = document.createElement('div');
                        playerName.className = 'insurance-player-name';
                        playerName.textContent = player.name;
                        
                        const playerBalance = document.createElement('div');
                        playerBalance.className = 'insurance-player-balance';
                        playerBalance.textContent = `Balance: $${player.balance}`;
                        
                        playerInfo.appendChild(playerName);
                        playerInfo.appendChild(playerBalance);
                        
                        label.appendChild(playerInfo);
                        
                        playerDiv.appendChild(checkbox);
                        playerDiv.appendChild(label);
                        
                        playersContainer.appendChild(playerDiv);
                    }
                });
                
                // Add event listener for "Select All" checkbox
                this.setupSelectAllInsurance();
            }

            addInsuranceMarker(playerId) {
                const playerSeat = document.getElementById(`player-${playerId}`);
                if (playerSeat) {
                    // Remove any existing insurance marker
                    const existingMarker = playerSeat.querySelector('.insurance-marker');
                    if (existingMarker) {
                        existingMarker.remove();
                    }
                    
                    // Create new insurance marker with a simple red circle
                    const marker = document.createElement('div');
                    marker.className = 'insurance-marker';
                    marker.innerHTML = '<div style="width: 24px; height: 24px; border-radius: 50%; background: #e74c3c; border: 2px solid #fff; box-shadow: 0 0 10px rgba(231, 76, 60, 0.8);"></div>';
                    marker.title = 'Has Insurance';
                    
                    playerSeat.appendChild(marker);
                    console.log(`🛡️ Added insurance marker to player ${playerId}`);
                }
            }

            removeInsuranceMarkers() {
                const markers = document.querySelectorAll('.insurance-marker');
                markers.forEach(marker => marker.remove());
                console.log('🛡️ Removed all insurance markers');
            }

            proceedWithoutInsurance() {
                console.log('🛡️ Proceeding without insurance (UIController)');
                this.gameLogic.proceedWithoutInsurance();
            }

            proceedToCardSelection() {
                console.log('🛡️ Proceeding to card selection phase (UIController)');
                this.gameLogic.proceedToCardSelection();
            }

            createInsuranceWinAnimation(playerId, insuranceAmount = 0) {
                console.log(`🛡️ Creating insurance win animation for player ${playerId} with amount $${insuranceAmount}`);
                
                const playerSeat = document.getElementById(`player-${playerId}`);
                if (!playerSeat) {
                    console.error(`🛡️ Player seat not found for player ${playerId}`);
                    return;
                }
                
                // Create insurance win display
                const insuranceWinDisplay = document.createElement('div');
                insuranceWinDisplay.className = 'insurance-win-display';
                
                const title = document.createElement('div');
                title.className = 'insurance-win-title';
                title.textContent = '🛡️ INSURANCE WIN!';
                
                const amount = document.createElement('div');
                amount.className = 'insurance-win-amount';
                amount.textContent = `$${Math.round(insuranceAmount)}`;
                
                insuranceWinDisplay.appendChild(title);
                insuranceWinDisplay.appendChild(amount);
                
                // Position relative to player seat
                const rect = playerSeat.getBoundingClientRect();
                insuranceWinDisplay.style.position = 'absolute';
                insuranceWinDisplay.style.left = rect.left + 'px';
                insuranceWinDisplay.style.top = (rect.top - 60) + 'px';
                insuranceWinDisplay.style.zIndex = '2000';
                
                document.body.appendChild(insuranceWinDisplay);
                
                // Remove after animation
                setTimeout(() => {
                    if (insuranceWinDisplay.parentNode) {
                        insuranceWinDisplay.parentNode.removeChild(insuranceWinDisplay);
                    }
                }, 3000);
                
                console.log(`🛡️ Insurance win animation created for player ${playerId}`);
            }
        }

        // Main Game Class
        class NineCardGame {
            constructor() {
                this.stateManager = new StateManager();
                this.gameLogic = new GameLogic(this.stateManager);
                this.botController = new BotController(this.stateManager, this.gameLogic);
                this.uiController = new UIController(this.stateManager, this.gameLogic, this.botController);
                
                // Set UIController reference in GameLogic for jackpot animations
                this.gameLogic.setUIController(this.uiController);
                
                this.initializeGame();
            }

            initializeGame() {
                console.log('Initializing Nine Card Game...');
                
                this.stateManager.initializeGame();
                this.uiController.initializeGame();
                
                this.setupGameStateListeners();
                
                console.log('Game initialized successfully!');
            }

            setupGameStateListeners() {
                this.stateManager.addStateListener((newState, oldState) => {
                    this.handleGameStateChange(newState, oldState);
                });
            }

            handleGameStateChange(newState, oldState) {
                console.log(`Game state changed: ${oldState} -> ${newState}`);
                
                switch (newState) {
                    case GAME_STATES.WAITING_FOR_ROUND_START:
                        this.handleWaitingForRoundStart();
                        break;
                    case GAME_STATES.INSURANCE_PURCHASE:
                        this.handleInsurancePurchase();
                        break;
                    case GAME_STATES.CARD_SELECTION:
                        this.handleCardSelection();
                        break;
                    case GAME_STATES.REVEALING_CARDS:
                        this.handleRevealingCards();
                        break;
                    case GAME_STATES.BANK_DRAW:
                        this.handleBankDraw();
                        break;
                    case GAME_STATES.DISTRIBUTE_WINNINGS:
                        this.handleDistributeWinnings();
                        break;
                    case GAME_STATES.ROUND_SUMMARY:
                        this.handleRoundSummary();
                        break;
                }
            }

            handleWaitingForRoundStart() {
                console.log('Waiting for round to start...');
            }

            handleInsurancePurchase() {
                console.log('🛡️ Insurance purchase phase started...');
                
                // Check if insurance pot is large enough to enable purchases
                const gameData = this.stateManager.getGameData();
                const insurancePot = gameData.insuranceJackpot || 0;
                
                if (insurancePot < GAME_CONFIG.INSURANCE_MIN_POT) {
                    console.log(`🛡️ Insurance pot too small: $${insurancePot} < $${GAME_CONFIG.INSURANCE_MIN_POT} - skipping insurance phase`);
                    // Skip insurance phase and go directly to card selection
                    this.stateManager.setState(GAME_STATES.CARD_SELECTION);
                    return;
                }
                
                console.log(`🛡️ Insurance pot sufficient: $${insurancePot} >= $${GAME_CONFIG.INSURANCE_MIN_POT} - proceeding with insurance phase`);
                
                // Remove any existing insurance markers
                if (this.uiController && typeof this.uiController.removeInsuranceMarkers === 'function') {
                    this.uiController.removeInsuranceMarkers();
                } else {
                    console.log('🛡️ UIController removeInsuranceMarkers not available');
                }
                
                // Start with human insurance phase (5 seconds)
                if (this.uiController && typeof this.uiController.startHumanInsurancePhase === 'function') {
                    this.uiController.startHumanInsurancePhase();
                } else {
                    console.error('UIController not available for human insurance phase');
                    // Fallback to gameLogic if uiController is not available
                    if (this.gameLogic && typeof this.gameLogic.proceedWithoutInsurance === 'function') {
                        this.gameLogic.proceedWithoutInsurance();
                    } else {
                        console.error('GameLogic proceedWithoutInsurance not available either');
                    }
                }
            }

            handleCardSelection() {
                console.log('Card selection phase started...');
            }

            handleRevealingCards() {
                console.log('Cards revealed, waiting for bank draw...');
            }

            handleBankDraw() {
                console.log('Bank drawing card...');
            }

            handleDistributeWinnings() {
                console.log('Distributing winnings...');
            }

            handleRoundSummary() {
                console.log('Round summary...');
                this.stateManager.updateGameData({ round: this.stateManager.getGameData().round + 1 });
            }
        }

        // Game version and update check
        const GAME_VERSION = '1.121.0';
        const LAST_UPDATE = '2025-10-30';
        
        // Display version info
        function showVersionInfo() {
            const versionDiv = document.createElement('div');
            versionDiv.className = 'version-info';
            versionDiv.innerHTML = `
                <div>Version: ${GAME_VERSION}</div>
                <div>Updated: ${LAST_UPDATE}</div>
                <div>Press F12 for console</div>
            `;
            document.body.appendChild(versionDiv);
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                if (versionDiv.parentNode) {
                    versionDiv.parentNode.removeChild(versionDiv);
                }
            }, 5000);
        }

        // Check for updates (simple cache busting)
        function checkForUpdates() {
            const lastCheck = localStorage.getItem('nineCard_lastCheck');
            const now = new Date().toDateString();
            
            if (lastCheck !== now) {
                console.log('🔄 Checking for updates...');
                console.log(`Current version: ${GAME_VERSION}`);
                localStorage.setItem('nineCard_lastCheck', now);
            }
        }

        // Update jackpot chip stack function
        function updateJackpotChipStack(jackpotAmount) {
            const chipPile = document.getElementById('jackpot-chip-pile');
            if (!chipPile) {
                console.log('Jackpot chip pile not found');
                return;
            }
            
            // Clear existing chips
            chipPile.innerHTML = '';
            
            // Calculate number of chips to display (max 20, one chip per $50)
            const chipCount = Math.min(Math.floor(jackpotAmount / 50), 20);
            
            // Create and position chips with better spacing
            for (let i = 0; i < chipCount; i++) {
                const chip = document.createElement('div');
                chip.className = 'chip';
                chip.style.bottom = `${i * 4}px`; // Increased spacing
                chip.style.zIndex = chipCount - i;
                chipPile.appendChild(chip);
            }
            
            console.log(`Updated jackpot chip stack: $${jackpotAmount} = ${chipCount} chips`);
        }
        
        // Initialize game when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing Nine Card Game...');
            console.log(`🎯 Nine Card Game ${GAME_VERSION} - ${LAST_UPDATE}`);
            
            try {
                window.game = new NineCardGame();
                window.updateJackpotChipStack = updateJackpotChipStack;
                showVersionInfo();
                checkForUpdates();
                console.log('Game initialized successfully!');
                console.log('Type "game.getGameStats()" in console for game info');
            } catch (error) {
                console.error('Error initializing game:', error);
            }
        });
    </script>
</body>
</html>
